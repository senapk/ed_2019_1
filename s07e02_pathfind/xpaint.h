#ifndef XPAINT_H
#define XPAINT_H
/*
Autor: 
    nome: David Sena Oliveira
    email: sena.ufc@gmail.com

Principais fontes:
    png: https://lodev.org/lodepng
    tff: https://github.com/nothings/stb
    funções de desenho e matemáticas estão comentadas nas funções 

Licença: GPLv3

Versão: 0.4


- 0.5 11/05/2019
    - adaptação feita para aceitar includes de cpp.
- 0.4 26/04/2019
    - adicionas cores de background
    - alterada a função de xs_log(diretorio)

*/

#ifdef __cplusplus
extern "C" {
#endif

/*
###############################################
######## DEFINES e TIPOS BASICOS ##############
###############################################
*/

/* apelido para um char sem sinal */
typedef unsigned char uchar;

/* struct que representa uma cor RGB */
typedef struct{
    uchar r;
    uchar g;
    uchar b;
} XColor;

/* cria e retorna uma struct XColor passando rgb */
XColor make_xcolor(uchar r, uchar g, uchar b);

/* lista de cores default */
extern XColor RED;
extern XColor GREEN;
extern XColor BLUE;
extern XColor YELLOW;
extern XColor CYAN;
extern XColor MAGENTA;
extern XColor ORANGE;
extern XColor WHITE;
extern XColor BLACK;

/* variantes 
extern XColor RED_B;
extern XColor GREEN_B;
extern XColor BLUE_B;
extern XColor YELLOW_B;
extern XColor CYAN_B;
extern XColor MAGENTA_B;
extern XColor ORANGE_B;
extern XColor WHITE_B;
extern XColor BLACK_B;
*/

/*
###############################################
######## ABRINDO, FECHANDO, SALVANDO ##########
###############################################
*/

/* abre um bitmap com essas dimensões */
void x_open(unsigned int width, unsigned int height);

/* finaliza o bitmap liberando os recursos */
void x_close();

/* para salvar um png no arquivo
   não inclua a extensão .png no nome do arquivo
*/
void x_save(const char *filename);

/*  Define um diretório onde serão salvos todas imagens invocadas no comando x_step.

    Se directory for "", ele não salvará os estados.
    Utilize o path completo incluindo a /
    Exemplo xs_log("imgs/")

    00000.png 00001.png 00002.png 00003.png
*/
void xs_log(const char *directory);

/*
    Redefine o valor de salto do x_step
*/
void xs_jump(int value);

/*  salva o arquivo, mas permite ao usuário controlar
    os estados salvos intermediários através da interação com o terminal.
*/
int x_step(const char *filename);

/*
###############################################
#### PLOTANDO, ESCREVENDO, LIMPANDO ###########
###############################################
*/

/* a funcao plot pinta o pixel usando a cor */
void x_plot(int x, int y);

/* a funcao write escreve um texto text, na posição px, py.
   retorna o x da posição após o último caractere escrito.
*/
int x_write(int x, int y, const char * format, ...);

/* limpa a tela inteira com a mesma cor */
void x_clear(XColor color);

/*
###############################################
### FUNÇÕES SET: Cor, Fonte, Paleta de Cores ##
###############################################
*/

/* muda a cor do pincel para todas as funcoes de desenho */
void xs_color(XColor color);

/* define uma cor na palheta de caracteres */
void xs_palette(char c, XColor color);

/* mudar o tamanho da fonte em pixels */
void xs_font_size(int size);

/* muda a font passando o path da nova fonte */
void xs_font(const char* filename);

/*
###############################################
############## FUNÇÕES GET ####################
###############################################
*/

/* retorna altura e largura do bitmap criado */
int    xg_height();
int    xg_width();

/* retorna a cor corrente do pincel */
XColor xg_color();

/* retorna a cor do pixel dessa posicao do bitmap */
XColor xg_pixel(int x, int y);

/* retorna uma cor dado um char. 
   os char default da paleta são rgbmcybk
   outros podem ser definidos ou redefinidor com xs_palette
*/
XColor xg_palette(char c);

#ifdef __cplusplus
}
#endif




#ifdef __cplusplus
extern "C" {
#endif

/* ############################################### */
/* ############ FUNÇÕES DE DESENHO DE LINHAS ##### */
/* ############################################### */


/* Desenha as seguintes formas sem preenchimento */

/* desenha uma linha com espessura de 1 pixel entre os pontos (x0, y0) e (x1, y1) */
void xd_line(int x0, int y0, int x1, int y1);

/* desenha uma linha com espessura de thickness pixels entre os pontos (x0, y0) e (x1, y1) */
void xd_thick_line(float x0, float y0, float x1, float y1, int thickness);

/* desenha um circulo com centro (centerx, centerx) e raio radius */
void xd_circle(int centerx, int centery, int radius);

/* desenha uma elipse dentro do rect de ponto superior esquerdo(x0, y0) */
/* e ponto inferior direito (x1, y1) */
void xd_ellipse(int x0, int y0, int x1, int y1);

/* desenha uma curva de bezier entre os pontos (x0, y0) e (x2, y2) */
/* a curvatura eh dada pelo ponto (x1, y1) */
void xd_bezier(int x0, int y0, int x1, int y1, int x2, int y2);


/* ############################################### */
/* ### FUNÇÕES DE DESENHO FORMAS PREENCHIDAS ##### */
/* ############################################### */

/* desenha um arco dado o ponto de centro, raio, espessura */
/* o angulo de inicio e o angulo de fim */
/* o angulo de inicio deve ser sempre menor que o angulo de fim */
/* o desenho é feito no sentido anti horario */
/* o angulo pode superar 360 */
void xd_filled_arc(float centerx, float centery, int radius, int thickness, int degrees_begin, int degrees_end);

/* desenha um triangulo dados os 3 vertices */
void xd_filled_triangle(float v1x, float v1y, float v2x, float v2y, float v3x, float v3y);

/* desenha um retangulo dados os cantos superior esquerdo (x0, y0) e inferior direito (x1, y1) */
void xd_filled_rect(int x0, int y0, int x1, int y1);

/* desenha um circulo dado centro e raio */
void xd_filled_circle(int centerx, int centery, int radius);

/* desenha uma elipse dentro do rect de ponto superior esquerdo(x0, y0) */
/* e ponto inferior direito (x1, y1) */
void xd_filled_ellipse(int x0, int y0, int x1, int y1);


#ifdef __cplusplus
}
#endif




#ifdef __cplusplus
extern "C" {
#endif

/*
###############################################
####### ALGEBRA DE VETORES BIDIMENSIONAIS #####
###############################################
*/

/* Define um vetor bidimensional com x e y */
typedef struct{
    float x;
    float y;
} XY;

/* cria e retorna um vetor */
XY make_xy(float x, float y);

/* retorna o tamanho de um vetor da origem */
float xy_lenght(float x, float y);

/* retorna a distancia entre dois pontos */
float xy_distance(float ax, float ay, float bx, float by);

/* retorna a + b */
XY xy_sum(XY a, XY b);

/* retorna a - b */
XY xy_sub(XY a, XY b);

/* retorna (a.x * value, a.y * value) */
XY xy_dot(XY a, float value);

/* retorna o vetor normalizado */
XY xy_normalize(XY v);

/* retorna o vetor orthogonal */
XY xy_ortho(XY v);

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif

/*
###############################################
############ FUNÇÕES MATEMATICAS ##############
###############################################
*/

/*
Essas funções foram adicionadas para que a biblioteca
xpaint não dependesse de incluir a biblioteca math.h
nos parametros de compilação com o -lm 
*/

float xm_sqrt(const float m);
float xm_pow( float x, float y );
int   xm_floor(double x);
float xm_fmod(float a, float b);
int   xm_ceil(float n);
float xm_sin(float d);
float xm_cos(float d);
float xm_acos(float x);
float xm_fabs(float f);
/* generates a number [min, max] */
int   xm_rand(int min, int max);

/*
###################################################
#         INICIO DA IMPLEMENTACAO                 #  
#                                                 #
#   O código abaixo apenas será inserido se       #
#   você incluir o #define XFULL antes de incluir #
#   essa biblioteca.                              #
###################################################
*/

#ifdef __cplusplus
}
#endif





#endif /* XPAINT_H */
#ifndef H_ONLY /* inicio da implementacao */
/*
LodePNG version 20180611

Copyright (c) 2005-2018 Lode Vandevenne

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    in a product, an acknowledgment in the product documentation would be
    appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

    3. This notice may not be removed or altered from any source
    distribution.
*/

#ifndef LODEPNG_H
#define LODEPNG_H

#include <string.h> /*for size_t*/

extern const char* LODEPNG_VERSION_STRING;

/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary.
The "NO_COMPILE" defines are designed to be used to pass as defines to the
compiler command to disable them without modifying this header, e.g.
-DLODEPNG_NO_COMPILE_ZLIB for gcc.
In addition to those below, you can also define LODEPNG_NO_COMPILE_CRC to
allow implementing a custom lodepng_crc32.
*/
/*deflate & zlib. If disabled, you must specify alternative zlib functions in
the custom_zlib field of the compress and decompress settings*/
#ifndef LODEPNG_NO_COMPILE_ZLIB
#define LODEPNG_COMPILE_ZLIB
#endif
/*png encoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_PNG
#define LODEPNG_COMPILE_PNG
#endif
/*deflate&zlib decoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_DECODER
#define LODEPNG_COMPILE_DECODER
#endif
/*deflate&zlib encoder and png encoder*/
#ifndef LODEPNG_NO_COMPILE_ENCODER
#define LODEPNG_COMPILE_ENCODER
#endif
/*the optional built in harddisk file loading and saving functions*/
#ifndef LODEPNG_NO_COMPILE_DISK
#define LODEPNG_COMPILE_DISK
#endif
/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/
#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS
#define LODEPNG_COMPILE_ANCILLARY_CHUNKS
#endif
/*ability to convert error numerical codes to English text string*/
#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT
#define LODEPNG_COMPILE_ERROR_TEXT
#endif
/*Compile the default allocators (C's free, malloc and realloc). If you disable this,
you can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your
source files with custom allocators.*/
#ifndef LODEPNG_NO_COMPILE_ALLOCATORS
#define LODEPNG_COMPILE_ALLOCATORS
#endif
/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/
#ifdef __cplusplus
#ifndef LODEPNG_NO_COMPILE_CPP
#define LODEPNG_COMPILE_CPP
#endif
#endif

#ifdef LODEPNG_COMPILE_CPP
#include <vector>
#include <string>
#endif /*LODEPNG_COMPILE_CPP*/

#ifdef LODEPNG_COMPILE_PNG
/*The PNG color types (also used for raw).*/
typedef enum LodePNGColorType
{
  LCT_GREY = 0, /*greyscale: 1,2,4,8,16 bit*/
  LCT_RGB = 2, /*RGB: 8,16 bit*/
  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/
  LCT_GREY_ALPHA = 4, /*greyscale with alpha: 8,16 bit*/
  LCT_RGBA = 6 /*RGB with alpha: 8,16 bit*/
} LodePNGColorType;

#ifdef LODEPNG_COMPILE_DECODER
/*
Converts PNG data in memory to raw pixel data.
out: Output parameter. Pointer to buffer that will contain the raw pixel data.
     After decoding, its size is w * h * (bytes per pixel) bytes larger than
     initially. Bytes per pixel depends on colortype and bitdepth.
     Must be freed after usage with free(*out).
     Note: for 16-bit per channel colors, uses big endian format like PNG does.
w: Output parameter. Pointer to width of pixel data.
h: Output parameter. Pointer to height of pixel data.
in: Memory buffer with the PNG file.
insize: size of the in buffer.
colortype: the desired color type for the raw output image. See explanation on PNG color types.
bitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,
                               const unsigned char* in, size_t insize,
                               LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/
unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,
                          const unsigned char* in, size_t insize);

/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/
unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,
                          const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_DISK
/*
Load PNG from disk, from file with given name.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,
                             const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/
unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,
                               const char* filename);

/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/
unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,
                               const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_DECODER*/


#ifdef LODEPNG_COMPILE_ENCODER
/*
Converts raw pixel data into a PNG image in memory. The colortype and bitdepth
  of the output PNG image cannot be chosen, they are automatically determined
  by the colortype, bitdepth and content of the input pixel data.
  Note: for 16-bit per channel colors, needs big endian format like PNG does.
out: Output parameter. Pointer to buffer that will contain the PNG image data.
     Must be freed after usage with free(*out).
outsize: Output parameter. Pointer to the size in bytes of the out buffer.
image: The raw pixel data to encode. The size of this buffer should be
       w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.
w: width of the raw pixel data in pixels.
h: height of the raw pixel data in pixels.
colortype: the color type of the raw input image. See explanation on PNG color types.
bitdepth: the bit depth of the raw input image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,
                               const unsigned char* image, unsigned w, unsigned h,
                               LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32(unsigned char** out, size_t* outsize,
                          const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24(unsigned char** out, size_t* outsize,
                          const unsigned char* image, unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DISK
/*
Converts raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned lodepng_encode_file(const char* filename,
                             const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32_file(const char* filename,
                               const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24_file(const char* filename,
                               const unsigned char* image, unsigned w, unsigned h);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_ENCODER*/


#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{
#ifdef LODEPNG_COMPILE_DECODER
/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype
is the format to output the pixels to. Default is RGBA 8-bit per channel.*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                const unsigned char* in, size_t insize,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                const std::vector<unsigned char>& in,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts PNG file from disk to raw pixel data in memory.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                const std::string& filename,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif /* LODEPNG_COMPILE_DISK */
#endif /* LODEPNG_COMPILE_DECODER */

#ifdef LODEPNG_COMPILE_ENCODER
/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype
is that of the raw input data. The output PNG color type will be auto chosen.*/
unsigned encode(std::vector<unsigned char>& out,
                const unsigned char* in, unsigned w, unsigned h,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(std::vector<unsigned char>& out,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts 32-bit RGBA raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned encode(const std::string& filename,
                const unsigned char* in, unsigned w, unsigned h,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(const std::string& filename,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif /* LODEPNG_COMPILE_DISK */
#endif /* LODEPNG_COMPILE_ENCODER */
} /* namespace lodepng */
#endif /*LODEPNG_COMPILE_CPP*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*Returns an English description of the numerical error code.*/
const char* lodepng_error_text(unsigned code);
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

#ifdef LODEPNG_COMPILE_DECODER
/*Settings for zlib decompression*/
typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;
struct LodePNGDecompressSettings
{
  /* Check LodePNGDecoderSettings for more ignorable errors */
  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/

  /*use custom zlib decoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
                          const unsigned char*, size_t,
                          const LodePNGDecompressSettings*);
  /*use custom deflate decoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_inflate)(unsigned char**, size_t*,
                             const unsigned char*, size_t,
                             const LodePNGDecompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGDecompressSettings lodepng_default_decompress_settings;
void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Settings for zlib compression. Tweaking these settings tweaks the balance
between speed and compression ratio.
*/
typedef struct LodePNGCompressSettings LodePNGCompressSettings;
struct LodePNGCompressSettings /*deflate = compress*/
{
  /*LZ77 related settings*/
  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/
  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/
  unsigned windowsize; /*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*/
  unsigned minmatch; /*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/
  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/
  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/

  /*use custom zlib encoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
                          const unsigned char*, size_t,
                          const LodePNGCompressSettings*);
  /*use custom deflate encoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_deflate)(unsigned char**, size_t*,
                             const unsigned char*, size_t,
                             const LodePNGCompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGCompressSettings lodepng_default_compress_settings;
void lodepng_compress_settings_init(LodePNGCompressSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_PNG
/*
Color mode of an image. Contains all information required to decode the pixel
bits to RGBA colors. This information is the same as used in the PNG file
format, and is used both for PNG and raw image data in LodePNG.
*/
typedef struct LodePNGColorMode
{
  /*header (IHDR)*/
  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/
  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/

  /*
  palette (PLTE and tRNS)

  Dynamically allocated with the colors of the palette, including alpha.
  When encoding a PNG, to store your colors in the palette of the LodePNGColorMode, first use
  lodepng_palette_clear, then for each color use lodepng_palette_add.
  If you encode an image without alpha with palette, don't forget to put value 255 in each A byte of the palette.

  When decoding, by default you can ignore this palette, since LodePNG already
  fills the palette colors in the pixels of the raw RGBA output.

  The palette is only supported for color type 3.
  */
  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/
  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/

  /*
  transparent color key (tRNS)

  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.
  For greyscale PNGs, r, g and b will all 3 be set to the same.

  When decoding, by default you can ignore this information, since LodePNG sets
  pixels with this key to transparent already in the raw RGBA output.

  The color key is only supported for color types 0 and 2.
  */
  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/
  unsigned key_r;       /*red/greyscale component of color key*/
  unsigned key_g;       /*green component of color key*/
  unsigned key_b;       /*blue component of color key*/
} LodePNGColorMode;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_color_mode_init(LodePNGColorMode* info);
void lodepng_color_mode_cleanup(LodePNGColorMode* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);

void lodepng_palette_clear(LodePNGColorMode* info);
/*add 1 color to the palette*/
unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a);

/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info);
/*get the amount of color channels used, based on colortype in the struct.
If a palette is used, it counts as 1 channel.*/
unsigned lodepng_get_channels(const LodePNGColorMode* info);
/*is it a greyscale type? (only colortype 0 or 4)*/
unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);
/*has it got an alpha channel? (only colortype 2 or 6)*/
unsigned lodepng_is_alpha_type(const LodePNGColorMode* info);
/*has it got a palette? (only colortype 3)*/
unsigned lodepng_is_palette_type(const LodePNGColorMode* info);
/*only returns true if there is a palette and there is a value in the palette with alpha < 255.
Loops through the palette to check this.*/
unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);
/*
Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.
Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).
Returns false if the image can only have opaque pixels.
In detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,
or if "key_defined" is true.
*/
unsigned lodepng_can_have_alpha(const LodePNGColorMode* info);
/*Returns the byte size of a raw image buffer with given width, height and color mode*/
size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*The information of a Time chunk in PNG.*/
typedef struct LodePNGTime
{
  unsigned year;    /*2 bytes used (0-65535)*/
  unsigned month;   /*1-12*/
  unsigned day;     /*1-31*/
  unsigned hour;    /*0-23*/
  unsigned minute;  /*0-59*/
  unsigned second;  /*0-60 (to allow for leap seconds)*/
} LodePNGTime;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*Information about the PNG image, except pixels, width and height.*/
typedef struct LodePNGInfo
{
  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/
  unsigned compression_method;/*compression method of the original file. Always 0.*/
  unsigned filter_method;     /*filter method of the original file*/
  unsigned interlace_method;  /*interlace method of the original file: 0=none, 1=Adam7*/
  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*
  suggested background color chunk (bKGD)
  This color uses the same color mode as the PNG (except alpha channel), which can be 1-bit to 16-bit.

  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding
  the encoder writes the red one. For palette PNGs: When decoding, the RGB value
  will be stored, not a palette index. But when encoding, specify the index of
  the palette in background_r, the other two are then ignored.

  The decoder does not use this background color to edit the color of pixels.
  */
  unsigned background_defined; /*is a suggested background color given?*/
  unsigned background_r;       /*red component of suggested background color*/
  unsigned background_g;       /*green component of suggested background color*/
  unsigned background_b;       /*blue component of suggested background color*/

  /*
  non-international text chunks (tEXt and zTXt)

  The char** arrays each contain num strings. The actual messages are in
  text_strings, while text_keys are keywords that give a short description what
  the actual text represents, e.g. Title, Author, Description, or anything else.

  A keyword is minimum 1 character and maximum 79 characters long. It's
  discouraged to use a single line length longer than 79 characters for texts.

  Don't allocate these text buffers yourself. Use the init/cleanup functions
  correctly and use lodepng_add_text and lodepng_clear_text.
  */
  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/
  char** text_keys; /*the keyword of a text chunk (e.g. "Comment")*/
  char** text_strings; /*the actual text*/

  /*
  international text chunks (iTXt)
  Similar to the non-international text chunks, but with additional strings
  "langtags" and "transkeys".
  */
  size_t itext_num; /*the amount of international texts in this PNG*/
  char** itext_keys; /*the English keyword of the text chunk (e.g. "Comment")*/
  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/
  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/
  char** itext_strings; /*the actual international text - UTF-8 string*/

  /*time chunk (tIME)*/
  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/
  LodePNGTime time;

  /*phys chunk (pHYs)*/
  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/
  unsigned phys_x; /*pixels per unit in x direction*/
  unsigned phys_y; /*pixels per unit in y direction*/
  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/

  /*
  unknown chunks
  There are 3 buffers, one for each position in the PNG where unknown chunks can appear
  each buffer contains all unknown chunks for that position consecutively
  The 3 buffers are the unknown chunks between certain critical chunks:
  0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND
  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared
  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.
  */
  unsigned char* unknown_chunks_data[3];
  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGInfo;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_info_init(LodePNGInfo* info);
void lodepng_info_cleanup(LodePNGInfo* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
void lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/
unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/

void lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/
unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*
Converts raw buffer from one color type to another color type, based on
LodePNGColorMode structs to describe the input and output color type.
See the reference manual at the end of this header file to see which color conversions are supported.
return value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)
The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel
of the output color type (lodepng_get_bpp).
For < 8 bpp images, there should not be padding bits at the end of scanlines.
For 16-bit per channel colors, uses big endian format like PNG does.
Return value is LodePNG error code
*/
unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DECODER
/*
Settings for the decoder. This contains settings for the PNG and the Zlib
decoder, but not the Info settings from the Info structs.
*/
typedef struct LodePNGDecoderSettings
{
  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/

  /* Check LodePNGDecompressSettings for more ignorable errors */
  unsigned ignore_crc; /*ignore CRC checksums*/
  unsigned ignore_critical; /*ignore unknown critical chunks*/
  unsigned ignore_end; /*ignore issues at end of file if possible (missing IEND chunk, too large chunk, ...)*/

  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/
  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/
  unsigned remember_unknown_chunks;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGDecoderSettings;

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/
typedef enum LodePNGFilterStrategy
{
  /*every filter at zero*/
  LFS_ZERO,
  /*Use filter that gives minimum sum, as described in the official PNG filter heuristic.*/
  LFS_MINSUM,
  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending
  on the image, this is better or worse than minsum.*/
  LFS_ENTROPY,
  /*
  Brute-force-search PNG filters by compressing each filter for each scanline.
  Experimental, very slow, and only rarely gives better compression than MINSUM.
  */
  LFS_BRUTE_FORCE,
  /*use predefined_filters buffer: you specify the filter type for each scanline*/
  LFS_PREDEFINED
} LodePNGFilterStrategy;

/*Gives characteristics about the colors of the image, which helps decide which color model to use for encoding.
Used internally by default if "auto_convert" is enabled. Public because it's useful for custom algorithms.*/
typedef struct LodePNGColorProfile
{
  unsigned colored; /*not greyscale*/
  unsigned key; /*image is not opaque and color key is possible instead of full alpha*/
  unsigned short key_r; /*key values, always as 16-bit, in 8-bit case the byte is duplicated, e.g. 65535 means 255*/
  unsigned short key_g;
  unsigned short key_b;
  unsigned alpha; /*image is not opaque and alpha channel or alpha palette required*/
  unsigned numcolors; /*amount of colors, up to 257. Not valid if bits == 16.*/
  unsigned char palette[1024]; /*Remembers up to the first 256 RGBA colors, in no particular order*/
  unsigned bits; /*bits per channel (not for palette). 1,2 or 4 for greyscale only. 16 if 16-bit per channel required.*/
} LodePNGColorProfile;

void lodepng_color_profile_init(LodePNGColorProfile* profile);

/*Get a LodePNGColorProfile of the image.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
                                   const unsigned char* image, unsigned w, unsigned h,
                                   const LodePNGColorMode* mode_in);
/*The function LodePNG uses internally to decide the PNG color with auto_convert.
Chooses an optimal color model, e.g. grey if only grey pixels, palette if < 256 colors, ...*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
                                   const unsigned char* image, unsigned w, unsigned h,
                                   const LodePNGColorMode* mode_in);

/*Settings for the encoder.*/
typedef struct LodePNGEncoderSettings
{
  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/

  unsigned auto_convert; /*automatically choose output PNG color type. Default: true*/

  /*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than
  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to
  completely follow the official PNG heuristic, filter_palette_zero must be true and
  filter_strategy must be LFS_MINSUM*/
  unsigned filter_palette_zero;
  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.
  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/
  LodePNGFilterStrategy filter_strategy;
  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with
  the same length as the amount of scanlines in the image, and each value must <= 5. You
  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero
  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/
  const unsigned char* predefined_filters;

  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).
  If colortype is 3, PLTE is _always_ created.*/
  unsigned force_palette;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*add LodePNG identifier and version as a text chunk, for debugging*/
  unsigned add_id;
  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/
  unsigned text_compression;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGEncoderSettings;

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/


#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)
/*The settings, state and information for extended encoding and decoding.*/
typedef struct LodePNGState
{
#ifdef LODEPNG_COMPILE_DECODER
  LodePNGDecoderSettings decoder; /*the decoding settings*/
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  LodePNGEncoderSettings encoder; /*the encoding settings*/
#endif /*LODEPNG_COMPILE_ENCODER*/
  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/
  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/
  unsigned error;
#ifdef LODEPNG_COMPILE_CPP
  /* For the lodepng::State subclass. */
  virtual ~LodePNGState(){}
#endif
} LodePNGState;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_state_init(LodePNGState* state);
void lodepng_state_cleanup(LodePNGState* state);
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);
#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_DECODER
/*
Same as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and
getting much more information about the PNG image and color mode.
*/
unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize);

/*
Read the PNG header, but not the actual data. This returns only the information
that is in the header chunk of the PNG, such as width, height and color type. The
information is placed in the info_png field of the LodePNGState.
*/
unsigned lodepng_inspect(unsigned* w, unsigned* h,
                         LodePNGState* state,
                         const unsigned char* in, size_t insize);
#endif /*LODEPNG_COMPILE_DECODER*/


#ifdef LODEPNG_COMPILE_ENCODER
/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/
unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state);
#endif /*LODEPNG_COMPILE_ENCODER*/

/*
The lodepng_chunk functions are normally not needed, except to traverse the
unknown chunks stored in the LodePNGInfo struct, or add new ones to it.
It also allows traversing the chunks of an encoded PNG file yourself.

PNG standard chunk naming conventions:
First byte: uppercase = critical, lowercase = ancillary
Second byte: uppercase = public, lowercase = private
Third byte: must be uppercase
Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy
*/

/*
Gets the length of the data of the chunk. Total chunk length has 12 bytes more.
There must be at least 4 bytes to read from. If the result value is too large,
it may be corrupt data.
*/
unsigned lodepng_chunk_length(const unsigned char* chunk);

/*puts the 4-byte type in null terminated string*/
void lodepng_chunk_type(char type[5], const unsigned char* chunk);

/*check if the type is the given type*/
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);

/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/
unsigned char lodepng_chunk_ancillary(const unsigned char* chunk);

/*0: public, 1: private (see PNG standard)*/
unsigned char lodepng_chunk_private(const unsigned char* chunk);

/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);

/*get pointer to the data of the chunk, where the input points to the header of the chunk*/
unsigned char* lodepng_chunk_data(unsigned char* chunk);
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);

/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/
unsigned lodepng_chunk_check_crc(const unsigned char* chunk);

/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/
void lodepng_chunk_generate_crc(unsigned char* chunk);

/*iterate to next chunks. don't use on IEND chunk, as there is no next chunk then*/
unsigned char* lodepng_chunk_next(unsigned char* chunk);
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk);

/*
Appends chunk to the data in out. The given chunk should already have its chunk header.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returns error code (0 if it went ok)
*/
unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk);

/*
Appends new chunk to out. The chunk to append is given by giving its length, type
and data separately. The type is a 4-letter string.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returne error code (0 if it went ok)
*/
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
                              const char* type, const unsigned char* data);


/*Calculate CRC32 of buffer*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len);
#endif /*LODEPNG_COMPILE_PNG*/


#ifdef LODEPNG_COMPILE_ZLIB
/*
This zlib part can be used independently to zlib compress and decompress a
buffer. It cannot be used to create gzip files however, and it only supports the
part of zlib that is required for PNG, it does not support dictionaries.
*/

#ifdef LODEPNG_COMPILE_DECODER
/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/
unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings);

/*
Decompresses Zlib data. Reallocates the out buffer and appends the data. The
data must be according to the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Compresses data with Zlib. Reallocates the out buffer and appends the data.
Zlib adds a small header and trailer around the deflate data.
The data is output in the format of the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,
                               const unsigned char* in, size_t insize,
                               const LodePNGCompressSettings* settings);

/*
Find length-limited Huffman code for given frequencies. This function is in the
public interface only for tests, it's used internally by lodepng_deflate.
*/
unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen);

/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/
unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings);

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into buffer. The function allocates the out buffer, and
after usage you should free it.
out: output parameter, contains pointer to loaded buffer.
outsize: output parameter, size of the allocated out buffer
filename: the path to the file to load
return value: error code (0 means ok)
*/
unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);

/*
Save a file from buffer to disk. Warning, if it exists, this function overwrites
the file without warning!
buffer: the buffer to write
buffersize: size of the buffer to write
filename: the path to the file to save to
return value: error code (0 means ok)
*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/

#ifdef LODEPNG_COMPILE_CPP
/* The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers. */
namespace lodepng
{
#ifdef LODEPNG_COMPILE_PNG
class State : public LodePNGState
{
  public:
    State();
    State(const State& other);
    virtual ~State();
    State& operator=(const State& other);
};

#ifdef LODEPNG_COMPILE_DECODER
/* Same as other lodepng::decode, but using a State for more settings and information. */
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                State& state,
                const unsigned char* in, size_t insize);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                State& state,
                const std::vector<unsigned char>& in);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/* Same as other lodepng::encode, but using a State for more settings and information. */
unsigned encode(std::vector<unsigned char>& out,
                const unsigned char* in, unsigned w, unsigned h,
                State& state);
unsigned encode(std::vector<unsigned char>& out,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                State& state);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into an std::vector.
return value: error code (0 means ok)
*/
unsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename);

/*
Save the binary data in an std::vector to a file on disk. The file is overwritten
without warning.
*/
unsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename);
#endif /* LODEPNG_COMPILE_DISK */
#endif /* LODEPNG_COMPILE_PNG */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
/* Zlib-decompress an unsigned char buffer */
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);

/* Zlib-decompress an std::vector */
unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
                    const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);
#endif /* LODEPNG_COMPILE_DECODER */

#ifdef LODEPNG_COMPILE_ENCODER
/* Zlib-compress an unsigned char buffer */
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);

/* Zlib-compress an std::vector */
unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
                  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);
#endif /* LODEPNG_COMPILE_ENCODER */
#endif /* LODEPNG_COMPILE_ZLIB */
} /* namespace lodepng */
#endif /*LODEPNG_COMPILE_CPP*/

/*
TODO:
[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often
[.] check compatibility with various compilers  - done but needs to be redone for every newer version
[X] converting color to 16-bit per channel types
[ ] read all public PNG chunk types (but never let the color profile and gamma ones touch RGB values)
[ ] make sure encoder generates no chunks with size > (2^31)-1
[ ] partial decoding (stream processing)
[X] let the "isFullyOpaque" function check color keys and transparent palettes too
[X] better name for the variables "codes", "codesD", "codelengthcodes", "clcl" and "lldl"
[ ] don't stop decoding on errors like 69, 57, 58 (make warnings)
[ ] make warnings like: oob palette, checksum fail, data after iend, wrong/unknown crit chunk, no null terminator in text, ...
[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes
[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...
[ ] allow user to give data (void*) to custom allocator
*/

#endif /*LODEPNG_H inclusion guard*/

/*
LodePNG Documentation
---------------------

0. table of contents
--------------------

  1. about
   1.1. supported features
   1.2. features not supported
  2. C and C++ version
  3. security
  4. decoding
  5. encoding
  6. color conversions
    6.1. PNG color types
    6.2. color conversions
    6.3. padding bits
    6.4. A note about 16-bits per channel and endianness
  7. error values
  8. chunks and PNG editing
  9. compiler support
  10. examples
   10.1. decoder C++ example
   10.2. decoder C example
  11. state settings reference
  12. changes
  13. contact information


1. about
--------

PNG is a file format to store raster images losslessly with good compression,
supporting different color types and alpha channel.

LodePNG is a PNG codec according to the Portable Network Graphics (PNG)
Specification (Second Edition) - W3C Recommendation 10 November 2003.

The specifications used are:

*) Portable Network Graphics (PNG) Specification (Second Edition):
     http://www.w3.org/TR/2003/REC-PNG-20031110
*) RFC 1950 ZLIB Compressed Data Format version 3.3:
     http://www.gzip.org/zlib/rfc-zlib.html
*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:
     http://www.gzip.org/zlib/rfc-deflate.html

The most recent version of LodePNG can currently be found at
http://lodev.org/lodepng/

LodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds
extra functionality.

LodePNG exists out of two files:
-lodepng.h: the header file for both C and C++
-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage

If you want to start using LodePNG right away without reading this doc, get the
examples from the LodePNG website to see how to use it in code, or check the
smaller examples in chapter 13 here.

LodePNG is simple but only supports the basic requirements. To achieve
simplicity, the following design choices were made: There are no dependencies
on any external library. There are functions to decode and encode a PNG with
a single function call, and extended versions of these functions taking a
LodePNGState struct allowing to specify or get more information. By default
the colors of the raw image are always RGB or RGBA, no matter what color type
the PNG file uses. To read and write files, there are simple functions to
convert the files to/from buffers in memory.

This all makes LodePNG suitable for loading textures in games, demos and small
programs, ... It's less suitable for full fledged image editors, loading PNGs
over network (it requires all the image data to be available before decoding can
begin), life-critical systems, ...

1.1. supported features
-----------------------

The following features are supported by the decoder:

*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,
   or the same color type as the PNG
*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image
*) Adam7 interlace and deinterlace for any color type
*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk
*) support for alpha channels, including RGBA color model, translucent palettes and color keying
*) zlib decompression (inflate)
*) zlib compression (deflate)
*) CRC32 and ADLER32 checksums
*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.
*) the following chunks are supported (generated/interpreted) by both encoder and decoder:
    IHDR: header information
    PLTE: color palette
    IDAT: pixel data
    IEND: the final chunk
    tRNS: transparency for palettized images
    tEXt: textual information
    zTXt: compressed textual information
    iTXt: international textual information
    bKGD: suggested background color
    pHYs: physical dimensions
    tIME: modification time

1.2. features not supported
---------------------------

The following features are _not_ supported:

*) some features needed to make a conformant PNG-Editor might be still missing.
*) partial loading/stream processing. All data must be available and is processed in one call.
*) The following public chunks are not supported but treated as unknown chunks by LodePNG
    cHRM, gAMA, iCCP, sRGB, sBIT, hIST, sPLT
   Some of these are not supported on purpose: LodePNG wants to provide the RGB values
   stored in the pixels, not values modified by system dependent gamma or color models.


2. C and C++ version
--------------------

The C version uses buffers allocated with alloc that you need to free()
yourself. You need to use init and cleanup functions for each struct whenever
using a struct from the C version to avoid exploits and memory leaks.

The C++ version has extra functions with std::vectors in the interface and the
lodepng::State class which is a LodePNGState with constructor and destructor.

These files work without modification for both C and C++ compilers because all
the additional C++ code is in "#ifdef __cplusplus" blocks that make C-compilers
ignore it, and the C code is made to compile both with strict ISO C90 and C++.

To use the C++ version, you need to rename the source file to lodepng.cpp
(instead of lodepng.c), and compile it with a C++ compiler.

To use the C version, you need to rename the source file to lodepng.c (instead
of lodepng.cpp), and compile it with a C compiler.


3. Security
-----------

Even if carefully designed, it's always possible that LodePNG contains possible
exploits. If you discover one, please let me know, and it will be fixed.

When using LodePNG, care has to be taken with the C version of LodePNG, as well
as the C-style structs when working with C++. The following conventions are used
for all C-style structs:

-if a struct has a corresponding init function, always call the init function when making a new one
-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks
-if a struct has a corresponding copy function, use the copy function instead of "=".
 The destination must also be inited already.


4. Decoding
-----------

Decoding converts a PNG compressed image to a raw pixel buffer.

Most documentation on using the decoder is at its declarations in the header
above. For C, simple decoding can be done with functions such as
lodepng_decode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_decode. For C++, all decoding can be done with the
various lodepng::decode functions, and lodepng::State can be used for advanced
features.

When using the LodePNGState, it uses the following fields for decoding:
*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here
*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get
*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use

LodePNGInfo info_png
--------------------

After decoding, this contains extra information of the PNG image, except the actual
pixels, width and height because these are already gotten directly from the decoder
functions.

It contains for example the original color type of the PNG image, text comments,
suggested background color, etc... More details about the LodePNGInfo struct are
at its declaration documentation.

LodePNGColorMode info_raw
-------------------------

When decoding, here you can specify which color type you want
the resulting raw image to be. If this is different from the colortype of the
PNG, then the decoder will automatically convert the result. This conversion
always works, except if you want it to convert a color PNG to greyscale or to
a palette with missing colors.

By default, 32-bit color is used for the result.

LodePNGDecoderSettings decoder
------------------------------

The settings can be used to ignore the errors created by invalid CRC and Adler32
chunks, and to disable the decoding of tEXt chunks.

There's also a setting color_convert, true by default. If false, no conversion
is done, the resulting data will be as it was in the PNG (after decompression)
and you'll have to puzzle the colors of the pixels together yourself using the
color type information in the LodePNGInfo.


5. Encoding
-----------

Encoding converts a raw pixel buffer to a PNG compressed image.

Most documentation on using the encoder is at its declarations in the header
above. For C, simple encoding can be done with functions such as
lodepng_encode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_encode. For C++, all encoding can be done with the
various lodepng::encode functions, and lodepng::State can be used for advanced
features.

Like the decoder, the encoder can also give errors. However it gives less errors
since the encoder input is trusted, the decoder input (a PNG image that could
be forged by anyone) is not trusted.

When using the LodePNGState, it uses the following fields for encoding:
*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.
*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has
*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use

LodePNGInfo info_png
--------------------

When encoding, you use this the opposite way as when decoding: for encoding,
you fill in the values you want the PNG to have before encoding. By default it's
not needed to specify a color type for the PNG since it's automatically chosen,
but it's possible to choose it yourself given the right settings.

The encoder will not always exactly match the LodePNGInfo struct you give,
it tries as close as possible. Some things are ignored by the encoder. The
encoder uses, for example, the following settings from it when applicable:
colortype and bitdepth, text chunks, time chunk, the color key, the palette, the
background color, the interlace method, unknown chunks, ...

When encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.
If the palette contains any colors for which the alpha channel is not 255 (so
there are translucent colors in the palette), it'll add a tRNS chunk.

LodePNGColorMode info_raw
-------------------------

You specify the color type of the raw image that you give to the input here,
including a possible transparent color key and palette you happen to be using in
your raw image data.

By default, 32-bit color is assumed, meaning your input has to be in RGBA
format with 4 bytes (unsigned chars) per pixel.

LodePNGEncoderSettings encoder
------------------------------

The following settings are supported (some are in sub-structs):
*) auto_convert: when this option is enabled, the encoder will
automatically choose the smallest possible color mode (including color key) that
can encode the colors of all pixels without information loss.
*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,
   2 = dynamic huffman tree (best compression). Should be 2 for proper
   compression.
*) use_lz77: whether or not to use LZ77 for compressed block types. Should be
   true for proper compression.
*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value
   2048 by default, but can be set to 32768 for better, but slow, compression.
*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE
   chunk if force_palette is true. This can used as suggested palette to convert
   to by viewers that don't support more than 256 colors (if those still exist)
*) add_id: add text chunk "Encoder: LodePNG <version>" to the image.
*) text_compression: default 1. If 1, it'll store texts as zTXt instead of tEXt chunks.
  zTXt chunks use zlib compression on the text. This gives a smaller result on
  large texts but a larger result on small texts (such as a single program name).
  It's all tEXt or all zTXt though, there's no separate setting per text yet.


6. color conversions
--------------------

An important thing to note about LodePNG, is that the color type of the PNG, and
the color type of the raw image, are completely independent. By default, when
you decode a PNG, you get the result as a raw image in the color type you want,
no matter whether the PNG was encoded with a palette, greyscale or RGBA color.
And if you encode an image, by default LodePNG will automatically choose the PNG
color type that gives good compression based on the values of colors and amount
of colors in the image. It can be configured to let you control it instead as
well, though.

To be able to do this, LodePNG does conversions from one color mode to another.
It can convert from almost any color type to any other color type, except the
following conversions: RGB to greyscale is not supported, and converting to a
palette when the palette doesn't have a required color is not supported. This is
not supported on purpose: this is information loss which requires a color
reduction algorithm that is beyong the scope of a PNG encoder (yes, RGB to grey
is easy, but there are multiple ways if you want to give some channels more
weight).

By default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB
color, no matter what color type the PNG has. And by default when encoding,
LodePNG automatically picks the best color model for the output PNG, and expects
the input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control
the color format of the images yourself, you can skip this chapter.

6.1. PNG color types
--------------------

A PNG image can have many color types, ranging from 1-bit color to 64-bit color,
as well as palettized color modes. After the zlib decompression and unfiltering
in the PNG image is done, the raw pixel data will have that color type and thus
a certain amount of bits per pixel. If you want the output raw image after
decoding to have another color type, a conversion is done by LodePNG.

The PNG specification gives the following color types:

0: greyscale, bit depths 1, 2, 4, 8, 16
2: RGB, bit depths 8 and 16
3: palette, bit depths 1, 2, 4 and 8
4: greyscale with alpha, bit depths 8 and 16
6: RGBA, bit depths 8 and 16

Bit depth is the amount of bits per pixel per color channel. So the total amount
of bits per pixel is: amount of channels * bitdepth.

6.2. color conversions
----------------------

As explained in the sections about the encoder and decoder, you can specify
color types and bit depths in info_png and info_raw to change the default
behaviour.

If, when decoding, you want the raw image to be something else than the default,
you need to set the color type and bit depth you want in the LodePNGColorMode,
or the parameters colortype and bitdepth of the simple decoding function.

If, when encoding, you use another color type than the default in the raw input
image, you need to specify its color type and bit depth in the LodePNGColorMode
of the raw image, or use the parameters colortype and bitdepth of the simple
encoding function.

If, when encoding, you don't want LodePNG to choose the output PNG color type
but control it yourself, you need to set auto_convert in the encoder settings
to false, and specify the color type you want in the LodePNGInfo of the
encoder (including palette: it can generate a palette if auto_convert is true,
otherwise not).

If the input and output color type differ (whether user chosen or auto chosen),
LodePNG will do a color conversion, which follows the rules below, and may
sometimes result in an error.

To avoid some confusion:
-the decoder converts from PNG to raw image
-the encoder converts from raw image to PNG
-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image
-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG
-when encoding, the color type in LodePNGInfo is ignored if auto_convert
 is enabled, it is automatically generated instead
-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original
 PNG image, but it can be ignored since the raw image has the color type you requested instead
-if the color type of the LodePNGColorMode and PNG image aren't the same, a conversion
 between the color types is done if the color types are supported. If it is not
 supported, an error is returned. If the types are the same, no conversion is done.
-even though some conversions aren't supported, LodePNG supports loading PNGs from any
 colortype and saving PNGs to any colortype, sometimes it just requires preparing
 the raw image correctly before encoding.
-both encoder and decoder use the same color converter.

Non supported color conversions:
-color to greyscale: no error is thrown, but the result will look ugly because
only the red channel is taken
-anything to palette when that palette does not have that color in it: in this
case an error is thrown

Supported color conversions:
-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA
-any grey or grey+alpha, to grey or grey+alpha
-anything to a palette, as long as the palette has the requested colors in it
-removing alpha channel
-higher to smaller bitdepth, and vice versa

If you want no color conversion to be done (e.g. for speed or control):
-In the encoder, you can make it save a PNG with any color type by giving the
raw color mode and LodePNGInfo the same color mode, and setting auto_convert to
false.
-In the decoder, you can make it store the pixel data in the same color type
as the PNG has, by setting the color_convert setting to false. Settings in
info_raw are then ignored.

The function lodepng_convert does the color conversion. It is available in the
interface but normally isn't needed since the encoder and decoder already call
it.

6.3. padding bits
-----------------

In the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines
have a bit amount that isn't a multiple of 8, then padding bits are used so that each
scanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.
The raw input image you give to the encoder, and the raw output image you get from the decoder
will NOT have these padding bits, e.g. in the case of a 1-bit image with a width
of 7 pixels, the first pixel of the second scanline will the the 8th bit of the first byte,
not the first bit of a new byte.

6.4. A note about 16-bits per channel and endianness
----------------------------------------------------

LodePNG uses unsigned char arrays for 16-bit per channel colors too, just like
for any other color format. The 16-bit values are stored in big endian (most
significant byte first) in these arrays. This is the opposite order of the
little endian used by x86 CPU's.

LodePNG always uses big endian because the PNG file format does so internally.
Conversions to other formats than PNG uses internally are not supported by
LodePNG on purpose, there are myriads of formats, including endianness of 16-bit
colors, the order in which you store R, G, B and A, and so on. Supporting and
converting to/from all that is outside the scope of LodePNG.

This may mean that, depending on your use case, you may want to convert the big
endian output of LodePNG to little endian with a for loop. This is certainly not
always needed, many applications and libraries support big endian 16-bit colors
anyway, but it means you cannot simply cast the unsigned char* buffer to an
unsigned short* buffer on x86 CPUs.


7. error values
---------------

All functions in LodePNG that return an error code, return 0 if everything went
OK, or a non-zero code if there was an error.

The meaning of the LodePNG error values can be retrieved with the function
lodepng_error_text: given the numerical error code, it returns a description
of the error in English as a string.

Check the implementation of lodepng_error_text to see the meaning of each code.


8. chunks and PNG editing
-------------------------

If you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG
editor that should follow the rules about handling of unknown chunks, or if your
program is able to read other types of chunks than the ones handled by LodePNG,
then that's possible with the chunk functions of LodePNG.

A PNG chunk has the following layout:

4 bytes length
4 bytes type name
length bytes data
4 bytes CRC

8.1. iterating through chunks
-----------------------------

If you have a buffer containing the PNG image data, then the first chunk (the
IHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the
signature of the PNG and are not part of a chunk. But if you start at byte 8
then you have a chunk, and can check the following things of it.

NOTE: none of these functions check for memory buffer boundaries. To avoid
exploits, always make sure the buffer contains all the data of the chunks.
When using lodepng_chunk_next, make sure the returned value is within the
allocated memory.

unsigned lodepng_chunk_length(const unsigned char* chunk):

Get the length of the chunk's data. The total chunk length is this length + 12.

void lodepng_chunk_type(char type[5], const unsigned char* chunk):
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):

Get the type of the chunk or compare if it's a certain type

unsigned char lodepng_chunk_critical(const unsigned char* chunk):
unsigned char lodepng_chunk_private(const unsigned char* chunk):
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):

Check if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).
Check if the chunk is private (public chunks are part of the standard, private ones not).
Check if the chunk is safe to copy. If it's not, then, when modifying data in a critical
chunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your
program doesn't handle that type of unknown chunk.

unsigned char* lodepng_chunk_data(unsigned char* chunk):
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):

Get a pointer to the start of the data of the chunk.

unsigned lodepng_chunk_check_crc(const unsigned char* chunk):
void lodepng_chunk_generate_crc(unsigned char* chunk):

Check if the crc is correct or generate a correct one.

unsigned char* lodepng_chunk_next(unsigned char* chunk):
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):

Iterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these
functions do no boundary checking of the allocated data whatsoever, so make sure there is enough
data available in the buffer to be able to go to the next chunk.

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk):
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
                              const char* type, const unsigned char* data):

These functions are used to create new chunks that are appended to the data in *out that has
length *outlength. The append function appends an existing chunk to the new data. The create
function creates a new chunk with the given parameters and appends it. Type is the 4-letter
name of the chunk.

8.2. chunks in info_png
-----------------------

The LodePNGInfo struct contains fields with the unknown chunk in it. It has 3
buffers (each with size) to contain 3 types of unknown chunks:
the ones that come before the PLTE chunk, the ones that come between the PLTE
and the IDAT chunks, and the ones that come after the IDAT chunks.
It's necessary to make the distionction between these 3 cases because the PNG
standard forces to keep the ordering of unknown chunks compared to the critical
chunks, but does not force any other ordering rules.

info_png.unknown_chunks_data[0] is the chunks before PLTE
info_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT
info_png.unknown_chunks_data[2] is the chunks after IDAT

The chunks in these 3 buffers can be iterated through and read by using the same
way described in the previous subchapter.

When using the decoder to decode a PNG, you can make it store all unknown chunks
if you set the option settings.remember_unknown_chunks to 1. By default, this
option is off (0).

The encoder will always encode unknown chunks that are stored in the info_png.
If you need it to add a particular chunk that isn't known by LodePNG, you can
use lodepng_chunk_append or lodepng_chunk_create to the chunk data in
info_png.unknown_chunks_data[x].

Chunks that are known by LodePNG should not be added in that way. E.g. to make
LodePNG add a bKGD chunk, set background_defined to true and add the correct
parameters there instead.


9. compiler support
-------------------

No libraries other than the current standard C library are needed to compile
LodePNG. For the C++ version, only the standard C++ library is needed on top.
Add the files lodepng.c(pp) and lodepng.h to your project, include
lodepng.h where needed, and your program can read/write PNG files.

It is compatible with C90 and up, and C++03 and up.

If performance is important, use optimization when compiling! For both the
encoder and decoder, this makes a large difference.

Make sure that LodePNG is compiled with the same compiler of the same version
and with the same settings as the rest of the program, or the interfaces with
std::vectors and std::strings in C++ can be incompatible.

CHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.

*) gcc and g++

LodePNG is developed in gcc so this compiler is natively supported. It gives no
warnings with compiler options "-Wall -Wextra -pedantic -ansi", with gcc and g++
version 4.7.1 on Linux, 32-bit and 64-bit.

*) Clang

Fully supported and warning-free.

*) Mingw

The Mingw compiler (a port of gcc for Windows) should be fully supported by
LodePNG.

*) Visual Studio and Visual C++ Express Edition

LodePNG should be warning-free with warning level W4. Two warnings were disabled
with pragmas though: warning 4244 about implicit conversions, and warning 4996
where it wants to use a non-standard function fopen_s instead of the standard C
fopen.

Visual Studio may want "stdafx.h" files to be included in each source file and
give an error "unexpected end of file while looking for precompiled header".
This is not standard C++ and will not be added to the stock LodePNG. You can
disable it for lodepng.cpp only by right clicking it, Properties, C/C++,
Precompiled Headers, and set it to Not Using Precompiled Headers there.

NOTE: Modern versions of VS should be fully supported, but old versions, e.g.
VS6, are not guaranteed to work.

*) Compilers on Macintosh

LodePNG has been reported to work both with gcc and LLVM for Macintosh, both for
C and C++.

*) Other Compilers

If you encounter problems on any compilers, feel free to let me know and I may
try to fix it if the compiler is modern and standards complient.


10. examples
------------

This decoder example shows the most basic usage of LodePNG. More complex
examples can be found on the LodePNG website.

10.1. decoder C++ example
-------------------------

#include "lodepng.h"
#include <iostream>

int main(int argc, char *argv[])
{
  const char* filename = argc > 1 ? argv[1] : "test.png";

  //load and decode
  std::vector<unsigned char> image;
  unsigned width, height;
  unsigned error = lodepng::decode(image, width, height, filename);

  //if there's an error, display it
  if(error) std::cout << "decoder error " << error << ": " << lodepng_error_text(error) << std::endl;

  //the pixels are now in the vector "image", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...
}

10.2. decoder C example
-----------------------

#include "lodepng.h"

int main(int argc, char *argv[])
{
  unsigned error;
  unsigned char* image;
  size_t width, height;
  const char* filename = argc > 1 ? argv[1] : "test.png";

  error = lodepng_decode32_file(&image, &width, &height, filename);

  if(error) printf("decoder error %u: %s\n", error, lodepng_error_text(error));

  / * use image here * /

  free(image);
  return 0;
}

11. state settings reference
----------------------------

A quick reference of some settings to set on the LodePNGState

For decoding:

state.decoder.zlibsettings.ignore_adler32: ignore ADLER32 checksums
state.decoder.zlibsettings.custom_...: use custom inflate function
state.decoder.ignore_crc: ignore CRC checksums
state.decoder.ignore_critical: ignore unknown critical chunks
state.decoder.ignore_end: ignore missing IEND chunk. May fail if this corruption causes other errors
state.decoder.color_convert: convert internal PNG color to chosen one
state.decoder.read_text_chunks: whether to read in text metadata chunks
state.decoder.remember_unknown_chunks: whether to read in unknown chunks
state.info_raw.colortype: desired color type for decoded image
state.info_raw.bitdepth: desired bit depth for decoded image
state.info_raw....: more color settings, see struct LodePNGColorMode
state.info_png....: no settings for decoder but ouput, see struct LodePNGInfo

For encoding:

state.encoder.zlibsettings.btype: disable compression by setting it to 0
state.encoder.zlibsettings.use_lz77: use LZ77 in compression
state.encoder.zlibsettings.windowsize: tweak LZ77 windowsize
state.encoder.zlibsettings.minmatch: tweak min LZ77 length to match
state.encoder.zlibsettings.nicematch: tweak LZ77 match where to stop searching
state.encoder.zlibsettings.lazymatching: try one more LZ77 matching
state.encoder.zlibsettings.custom_...: use custom deflate function
state.encoder.auto_convert: choose optimal PNG color type, if 0 uses info_png
state.encoder.filter_palette_zero: PNG filter strategy for palette
state.encoder.filter_strategy: PNG filter strategy to encode with
state.encoder.force_palette: add palette even if not encoding to one
state.encoder.add_id: add LodePNG identifier and version as a text chunk
state.encoder.text_compression: use compressed text chunks for metadata
state.info_raw.colortype: color type of raw input image you provide
state.info_raw.bitdepth: bit depth of raw input image you provide
state.info_raw: more color settings, see struct LodePNGColorMode
state.info_png.color.colortype: desired color type if auto_convert is false
state.info_png.color.bitdepth: desired bit depth if auto_convert is false
state.info_png.color....: more color settings, see struct LodePNGColorMode
state.info_png....: more PNG related settings, see struct LodePNGInfo


12. changes
-----------

The version number of LodePNG is the date of the change given in the format
yyyymmdd.

Some changes aren't backwards compatible. Those are indicated with a (!)
symbol.

*) 11 jun 2018: less restrictive check for pixel size integer overflow
*) 14 jan 2018: allow optionally ignoring a few more recoverable errors
*) 17 sep 2017: fix memory leak for some encoder input error cases
*) 27 nov 2016: grey+alpha auto color model detection bugfix
*) 18 apr 2016: Changed qsort to custom stable sort (for platforms w/o qsort).
*) 09 apr 2016: Fixed colorkey usage detection, and better file loading (within
   the limits of pure C90).
*) 08 dec 2015: Made load_file function return error if file can't be opened.
*) 24 okt 2015: Bugfix with decoding to palette output.
*) 18 apr 2015: Boundary PM instead of just package-merge for faster encoding.
*) 23 aug 2014: Reduced needless memory usage of decoder.
*) 28 jun 2014: Removed fix_png setting, always support palette OOB for
    simplicity. Made ColorProfile public.
*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.
*) 22 dec 2013: Power of two windowsize required for optimization.
*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.
*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).
*) 11 mar 2013 (!): Bugfix with custom free. Changed from "my" to "lodepng_"
    prefix for the custom allocators and made it possible with a new #define to
    use custom ones in your project without needing to change lodepng's code.
*) 28 jan 2013: Bugfix with color key.
*) 27 okt 2012: Tweaks in text chunk keyword length error handling.
*) 8 okt 2012 (!): Added new filter strategy (entropy) and new auto color mode.
    (no palette). Better deflate tree encoding. New compression tweak settings.
    Faster color conversions while decoding. Some internal cleanups.
*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.
*) 1 sep 2012 (!): Removed #define's for giving custom (de)compression functions
    and made it work with function pointers instead.
*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc
    and free functions and toggle #defines from compiler flags. Small fixes.
*) 6 may 2012 (!): Made plugging in custom zlib/deflate functions more flexible.
*) 22 apr 2012 (!): Made interface more consistent, renaming a lot. Removed
    redundant C++ codec classes. Reduced amount of structs. Everything changed,
    but it is cleaner now imho and functionality remains the same. Also fixed
    several bugs and shrunk the implementation code. Made new samples.
*) 6 nov 2011 (!): By default, the encoder now automatically chooses the best
    PNG color model and bit depth, based on the amount and type of colors of the
    raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.
*) 9 okt 2011: simpler hash chain implementation for the encoder.
*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.
*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.
    A bug with the PNG filtertype heuristic was fixed, so that it chooses much
    better ones (it's quite significant). A setting to do an experimental, slow,
    brute force search for PNG filter types is added.
*) 17 aug 2011 (!): changed some C zlib related function names.
*) 16 aug 2011: made the code less wide (max 120 characters per line).
*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.
*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.
*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman
    to optimize long sequences of zeros.
*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and
    LodePNG_InfoColor_canHaveAlpha functions for convenience.
*) 7 nov 2010: added LodePNG_error_text function to get error code description.
*) 30 okt 2010: made decoding slightly faster
*) 26 okt 2010: (!) changed some C function and struct names (more consistent).
     Reorganized the documentation and the declaration order in the header.
*) 08 aug 2010: only changed some comments and external samples.
*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.
*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.
*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could
    read by ignoring the problem but windows apps couldn't.
*) 06 jun 2008: added more error checks for out of memory cases.
*) 26 apr 2008: added a few more checks here and there to ensure more safety.
*) 06 mar 2008: crash with encoding of strings fixed
*) 02 feb 2008: support for international text chunks added (iTXt)
*) 23 jan 2008: small cleanups, and #defines to divide code in sections
*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.
*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.
*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added
    Also various fixes, such as in the deflate and the padding bits code.
*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved
    filtering code of encoder.
*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A
    C++ wrapper around this provides an interface almost identical to before.
    Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code
    are together in these files but it works both for C and C++ compilers.
*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks
*) 30 aug 2007: bug fixed which makes this Borland C++ compatible
*) 09 aug 2007: some VS2005 warnings removed again
*) 21 jul 2007: deflate code placed in new namespace separate from zlib code
*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images
*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing
    invalid std::vector element [0] fixed, and level 3 and 4 warnings removed
*) 02 jun 2007: made the encoder add a tag with version by default
*) 27 may 2007: zlib and png code separated (but still in the same file),
    simple encoder/decoder functions added for more simple usage cases
*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),
    moved some examples from here to lodepng_examples.cpp
*) 12 may 2007: palette decoding bug fixed
*) 24 apr 2007: changed the license from BSD to the zlib license
*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.
*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding
    palettized PNG images. Plus little interface change with palette and texts.
*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.
    Fixed a bug where the end code of a block had length 0 in the Huffman tree.
*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented
    and supported by the encoder, resulting in smaller PNGs at the output.
*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.
*) 24 jan 2007: gave encoder an error interface. Added color conversion from any
    greyscale type to 8-bit greyscale with or without alpha.
*) 21 jan 2007: (!) Totally changed the interface. It allows more color types
    to convert to and is more uniform. See the manual for how it works now.
*) 07 jan 2007: Some cleanup & fixes, and a few changes over the last days:
    encode/decode custom tEXt chunks, separate classes for zlib & deflate, and
    at last made the decoder give errors for incorrect Adler32 or Crc.
*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.
*) 29 dec 2006: Added support for encoding images without alpha channel, and
    cleaned out code as well as making certain parts faster.
*) 28 dec 2006: Added "Settings" to the encoder.
*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.
    Removed some code duplication in the decoder. Fixed little bug in an example.
*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.
    Fixed a bug of the decoder with 16-bit per color.
*) 15 okt 2006: Changed documentation structure
*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the
    given image buffer, however for now it's not compressed.
*) 08 sep 2006: (!) Changed to interface with a Decoder class
*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different
    way. Renamed decodePNG to decodePNGGeneric.
*) 29 jul 2006: (!) Changed the interface: image info is now returned as a
    struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.
*) 28 jul 2006: Cleaned the code and added new error checks.
    Corrected terminology "deflate" into "inflate".
*) 23 jun 2006: Added SDL example in the documentation in the header, this
    example allows easy debugging by displaying the PNG and its transparency.
*) 22 jun 2006: (!) Changed way to obtain error value. Added
    loadFile function for convenience. Made decodePNG32 faster.
*) 21 jun 2006: (!) Changed type of info vector to unsigned.
    Changed position of palette in info vector. Fixed an important bug that
    happened on PNGs with an uncompressed block.
*) 16 jun 2006: Internally changed unsigned into unsigned where
    needed, and performed some optimizations.
*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them
    in LodePNG namespace. Changed the order of the parameters. Rewrote the
    documentation in the header. Renamed files to lodepng.cpp and lodepng.h
*) 22 apr 2006: Optimized and improved some code
*) 07 sep 2005: (!) Changed to std::vector interface
*) 12 aug 2005: Initial release (C++, decoder only)


13. contact information
-----------------------

Feel free to contact me with suggestions, problems, comments, ... concerning
LodePNG. If you encounter a PNG image that doesn't work properly with this
decoder, feel free to send it and I'll use it to find and fix the problem.

My email address is (puzzle the account and domain together with an @ symbol):
Domain: gmail dot com.
Account: lode dot vandevenne.


Copyright (c) 2005-2018 Lode Vandevenne
*/
/*
LodePNG version 20180611

Copyright (c) 2005-2018 Lode Vandevenne

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    in a product, an acknowledgment in the product documentation would be
    appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

    3. This notice may not be removed or altered from any source
    distribution.
*/

/*
The manual and changelog are in the header file "lodepng.h"
Rename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.
*/


#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/
#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/
#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/
#endif /*_MSC_VER */

const char* LODEPNG_VERSION_STRING = "20180611";

/*
This source file is built up in the following large parts. The code sections
with the "LODEPNG_COMPILE_" #defines divide this up further in an intermixed way.
-Tools for C and common code for PNG and Zlib
-C Code for Zlib (huffman, deflate, ...)
-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)
-The C++ wrapper around all of the above
*/

/*The malloc, realloc and free functions defined here with "lodepng_" in front
of the name, so that you can easily change them to others related to your
platform if needed. Everything else in the code calls these. Pass
-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out
#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size)
{
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
}

static void* lodepng_realloc(void* ptr, size_t new_size)
{
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return realloc(ptr, new_size);
}

static void lodepng_free(void* ptr)
{
  free(ptr);
}
#else /*LODEPNG_COMPILE_ALLOCATORS*/
void* lodepng_malloc(size_t size);
void* lodepng_realloc(void* ptr, size_t new_size);
void lodepng_free(void* ptr);
#endif /*LODEPNG_COMPILE_ALLOCATORS*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // Tools for C, and common code for PNG and Zlib.                       // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#define LODEPNG_MAX(a, b) (((a) > (b)) ? (a) : (b))

/*
Often in case of an error a value is assigned to a variable and then it breaks
out of a loop (to go to the cleanup phase of a function). This macro does that.
It makes the error handling code shorter and more readable.

Example: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);
*/
#define CERROR_BREAK(errorvar, code)\
{\
  errorvar = code;\
  break;\
}

/*version of CERROR_BREAK that assumes the common case where the error variable is named "error"*/
#define ERROR_BREAK(code) CERROR_BREAK(error, code)

/*Set error var to the error code, and return it.*/
#define CERROR_RETURN_ERROR(errorvar, code)\
{\
  errorvar = code;\
  return code;\
}

/*Try the code, if it returns error, also return the error.*/
#define CERROR_TRY_RETURN(call)\
{\
  unsigned error = call;\
  if(error) return error;\
}

/*Set error var to the error code, and return from the void function.*/
#define CERROR_RETURN(errorvar, code)\
{\
  errorvar = code;\
  return;\
}

/*
About uivector, ucvector and string:
-All of them wrap dynamic arrays or text strings in a similar way.
-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.
-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.
-They're not used in the interface, only internally in this file as static functions.
-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.
*/

#ifdef LODEPNG_COMPILE_ZLIB
/*dynamic vector of unsigned ints*/
typedef struct uivector
{
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p)
{
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  lodepng_free(((uivector*)p)->data);
  ((uivector*)p)->data = NULL;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_reserve(uivector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
    size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
    void* data = lodepng_realloc(p->data, newsize);
    if(data)
    {
      p->allocsize = newsize;
      p->data = (unsigned*)data;
    }
    else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size)
{
  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;
  p->size = size;
  return 1; /*success*/
}

/*resize and give all new elements the value*/
static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)
{
  size_t oldsize = p->size, i;
  if(!uivector_resize(p, size)) return 0;
  for(i = oldsize; i < size; ++i) p->data[i] = value;
  return 1;
}

static void uivector_init(uivector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_ENCODER
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c)
{
  if(!uivector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}
#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

/* /////////////////////////////////////////////////////////////////////////// */

/*dynamic vector of unsigned chars*/
typedef struct ucvector
{
  unsigned char* data;
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_reserve(ucvector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
    size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
    void* data = lodepng_realloc(p->data, newsize);
    if(data)
    {
      p->allocsize = newsize;
      p->data = (unsigned char*)data;
    }
    else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size)
{
  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;
  p->size = size;
  return 1; /*success*/
}

#ifdef LODEPNG_COMPILE_PNG

static void ucvector_cleanup(void* p)
{
  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
  lodepng_free(((ucvector*)p)->data);
  ((ucvector*)p)->data = NULL;
}

static void ucvector_init(ucvector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*you can both convert from vector to buffer&size and vica versa. If you use
init_buffer to take over a buffer and size, it is not needed to use cleanup*/
static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
{
  p->data = buffer;
  p->allocsize = p->size = size;
}
#endif /*LODEPNG_COMPILE_ZLIB*/

#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_push_back(ucvector* p, unsigned char c)
{
  if(!ucvector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/


/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned string_resize(char** out, size_t size)
{
  char* data = (char*)lodepng_realloc(*out, size + 1);
  if(data)
  {
    data[size] = 0; /*null termination char*/
    *out = data;
  }
  return data != 0;
}

/*init a {char*, size_t} pair for use as string*/
static void string_init(char** out)
{
  *out = NULL;
  string_resize(out, 0);
}

/*free the above pair again*/
static void string_cleanup(char** out)
{
  lodepng_free(*out);
  *out = NULL;
}

static void string_set(char** out, const char* in)
{
  size_t insize = strlen(in), i;
  if(string_resize(out, insize))
  {
    for(i = 0; i != insize; ++i)
    {
      (*out)[i] = in[i];
    }
  }
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_read32bitInt(const unsigned char* buffer)
{
  return (unsigned)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
}

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value)
{
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
  buffer[3] = (unsigned char)((value      ) & 0xff);
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

#ifdef LODEPNG_COMPILE_ENCODER
static void lodepng_add32bitInt(ucvector* buffer, unsigned value)
{
  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/
  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / File IO                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename)
{
  FILE* file;
  long size;
  file = fopen(filename, "rb");
  if(!file) return -1;

  if(fseek(file, 0, SEEK_END) != 0)
  {
    fclose(file);
    return -1;
  }

  size = ftell(file);
  /* It may give LONG_MAX as directory size, this is invalid for us. */
  if(size == LONG_MAX) size = -1;

  fclose(file);
  return size;
}

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename)
{
  FILE* file;
  size_t readsize;
  file = fopen(filename, "rb");
  if(!file) return 78;

  readsize = fread(out, 1, size, file);
  fclose(file);

  if (readsize != size) return 78;
  return 0;
}

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)
{
  long size = lodepng_filesize(filename);
  if (size < 0) return 78;
  *outsize = (size_t)size;

  *out = (unsigned char*)lodepng_malloc((size_t)size);
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/

  return lodepng_buffer_file(*out, (size_t)size, filename);
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)
{
  FILE* file;
  file = fopen(filename, "wb" );
  if(!file) return 79;
  fwrite((char*)buffer , 1 , buffersize, file);
  fclose(file);
  return 0;
}

#endif /*LODEPNG_COMPILE_DISK*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of common code and tools. Begin of Zlib related code.            // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_ENCODER
/*TODO: this ignores potential out of memory errors*/
#define addBitToStream(/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\
{\
  /*add a new byte at the end*/\
  if(((*bitpointer) & 7) == 0) ucvector_push_back(bitstream, (unsigned char)0);\
  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\
  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\
  ++(*bitpointer);\
}

static void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));
}

static void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)

static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0, i;
  for(i = 0; i != nbits; ++i)
  {
    result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;
    ++(*bitpointer);
  }
  return result;
}
#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflate - Huffman                                                      / */
/* ////////////////////////////////////////////////////////////////////////// */

#define FIRST_LENGTH_CODE_INDEX 257
#define LAST_LENGTH_CODE_INDEX 285
/*256 literals, the end code, some length codes, and 2 unused codes*/
#define NUM_DEFLATE_CODE_SYMBOLS 288
/*the distance codes have their own symbols, 30 used, 2 unused*/
#define NUM_DISTANCE_SYMBOLS 32
/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/
#define NUM_CODE_LENGTH_CODES 19

/*the base lengths represented by codes 257-285*/
static const unsigned LENGTHBASE[29]
  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
     67, 83, 99, 115, 131, 163, 195, 227, 258};

/*the extra bits used by codes 257-285 (added to base length)*/
static const unsigned LENGTHEXTRA[29]
  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
      4,  4,  4,   4,   5,   5,   5,   5,   0};

/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/
static const unsigned DISTANCEBASE[30]
  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};

/*the extra bits of backwards distances (added to base)*/
static const unsigned DISTANCEEXTRA[30]
  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,
       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};

/*the order in which "code length alphabet code lengths" are stored, out of this
the huffman tree of the dynamic huffman tree lengths is generated*/
static const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]
  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/* ////////////////////////////////////////////////////////////////////////// */

/*
Huffman tree struct, containing multiple representations of the tree
*/
typedef struct HuffmanTree
{
  unsigned* tree2d;
  unsigned* tree1d;
  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/
  unsigned maxbitlen; /*maximum number of bits a single code can get*/
  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/
} HuffmanTree;

/*function used for debug purposes to draw the tree in ascii art with C++*/
/*
static void HuffmanTree_draw(HuffmanTree* tree)
{
  std::cout << "tree. length: " << tree->numcodes << " maxbitlen: " << tree->maxbitlen << std::endl;
  for(size_t i = 0; i != tree->tree1d.size; ++i)
  {
    if(tree->lengths.data[i])
      std::cout << i << " " << tree->tree1d.data[i] << " " << tree->lengths.data[i] << std::endl;
  }
  std::cout << std::endl;
}*/

static void HuffmanTree_init(HuffmanTree* tree)
{
  tree->tree2d = 0;
  tree->tree1d = 0;
  tree->lengths = 0;
}

static void HuffmanTree_cleanup(HuffmanTree* tree)
{
  lodepng_free(tree->tree2d);
  lodepng_free(tree->tree1d);
  lodepng_free(tree->lengths);
}

/*the tree representation used by the decoder. return value is error*/
static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)
{
  unsigned nodefilled = 0; /*up to which node it is filled*/
  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/
  unsigned n, i;

  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));
  if(!tree->tree2d) return 83; /*alloc fail*/

  /*
  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means
  uninited, a value >= numcodes is an address to another bit, a value < numcodes
  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as
  many columns as codes - 1.
  A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
  Here, the internal nodes are stored (what their 0 and 1 option point to).
  There is only memory for such good tree currently, if there are more nodes
  (due to too long length codes), error 55 will happen
  */
  for(n = 0; n < tree->numcodes * 2; ++n)
  {
    tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
  }

  for(n = 0; n < tree->numcodes; ++n) /*the codes*/
  {
    for(i = 0; i != tree->lengths[n]; ++i) /*the bits for this code*/
    {
      unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);
      /*oversubscribed, see comment in lodepng_error_text*/
      if(treepos > 2147483647 || treepos + 2 > tree->numcodes) return 55;
      if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/
      {
        if(i + 1 == tree->lengths[n]) /*last bit*/
        {
          tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/
          treepos = 0;
        }
        else
        {
          /*put address of the next step in here, first that address has to be found of course
          (it's just nodefilled + 1)...*/
          ++nodefilled;
          /*addresses encoded with numcodes added to it*/
          tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;
          treepos = nodefilled;
        }
      }
      else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;
    }
  }

  for(n = 0; n < tree->numcodes * 2; ++n)
  {
    if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/
  }

  return 0;
}

/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)
{
  uivector blcount;
  uivector nextcode;
  unsigned error = 0;
  unsigned bits, n;

  uivector_init(&blcount);
  uivector_init(&nextcode);

  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  if(!tree->tree1d) error = 83; /*alloc fail*/

  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))
    error = 83; /*alloc fail*/

  if(!error)
  {
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount.data[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits)
    {
      nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n)
    {
      if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;
    }
  }

  uivector_cleanup(&blcount);
  uivector_cleanup(&nextcode);

  if(!error) return HuffmanTree_make2DTree(tree);
  else return error;
}

/*
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen)
{
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->maxbitlen = maxbitlen;
  return HuffmanTree_makeFromLengths2(tree);
}

#ifdef LODEPNG_COMPILE_ENCODER

/*BPM: Boundary Package Merge, see "A Fast and Space-Economical Algorithm for Length-Limited Coding",
Jyrki Katajainen, Alistair Moffat, Andrew Turpin, 1995.*/

/*chain node for boundary package merge*/
typedef struct BPMNode
{
  int weight; /*the sum of all weights in this chain*/
  unsigned index; /*index of this leaf node (called "count" in the paper)*/
  struct BPMNode* tail; /*the next nodes in this chain (null if last)*/
  int in_use;
} BPMNode;

/*lists of chains*/
typedef struct BPMLists
{
  /*memory pool*/
  unsigned memsize;
  BPMNode* memory;
  unsigned numfree;
  unsigned nextfree;
  BPMNode** freelist;
  /*two heads of lookahead chains per list*/
  unsigned listsize;
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail)
{
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree)
  {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i)
    {
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i)
    {
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
  }

  result = lists->freelist[lists->nextfree++];
  result->weight = weight;
  result->index = index;
  result->tail = tail;
  return result;
}

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num)
{
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2)
  {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width)
    {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++)
      {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) memcpy(leaves, mem, sizeof(*leaves) * num);
  lodepng_free(mem);
}

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num)
{
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0)
  {
    if(lastindex >= numpresent) return;
    lists->chains0[c] = lists->chains1[c];
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
  }
  else
  {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    lists->chains0[c] = lists->chains1[c];
    if(lastindex < numpresent && sum > leaves[lastindex].weight)
    {
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
      return;
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2))
    {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen)
{
  unsigned error = 0;
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i)
  {
    if(frequencies[i] > 0)
    {
      leaves[numpresent].weight = (int)frequencies[i];
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  for(i = 0; i != numcodes; ++i) lengths[i] = 0;

  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0)
  {
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
  }
  else if(numpresent == 1)
  {
    lengths[leaves[0].index] = 1;
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
  }
  else
  {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);

    lists.listsize = maxbitlen;
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    lists.nextfree = 0;
    lists.numfree = lists.memsize;
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/

    if(!error)
    {
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i)
      {
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail)
      {
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    lodepng_free(lists.freelist);
    lodepng_free(lists.chains0);
    lodepng_free(lists.chains1);
  }

  lodepng_free(leaves);
  return error;
}

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)
{
  unsigned error = 0;
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
  tree->maxbitlen = maxbitlen;
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  /*initialize all lengths to 0*/
  memset(tree->lengths, 0, numcodes * sizeof(unsigned));

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  return error;
}

static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)
{
  return tree->tree1d[index];
}

static unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)
{
  return tree->lengths[index];
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code, or (unsigned)(-1) if error happened
inbitlength is the length of the complete buffer, in bits (so its byte length times 8)
*/
static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,
                                    const HuffmanTree* codetree, size_t inbitlength)
{
  unsigned treepos = 0, ct;
  for(;;)
  {
    if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/
    /*
    decode the symbol from the tree. The "readBitFromStream" code is inlined in
    the expression below because this is the biggest bottleneck while decoding
    */
    ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];
    ++(*bp);
    if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/
    else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/

    if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/
  }
}
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/
static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)
{
  /*TODO: check for out of memory errors*/
  generateFixedLitLenTree(tree_ll);
  generateFixedDistanceTree(tree_d);
}

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      const unsigned char* in, size_t* bp, size_t inlength)
{
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
  unsigned n, HLIT, HDIST, HCLEN, i;
  size_t inbitlength = inlength * 8;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  unsigned* bitlen_d = 0; /*dist code lengths*/
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if((*bp) + 14 > (inlength << 3)) return 49; /*error: the bit pointer is or will go past the memory*/

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBitsFromStream(bp, in, 5) + 257;
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBitsFromStream(bp, in, 5) + 1;
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBitsFromStream(bp, in, 4) + 4;

  if((*bp) + HCLEN * 3 > (inlength << 3)) return 50; /*error: the bit pointer is or will go past the memory*/

  HuffmanTree_init(&tree_cl);

  while(!error)
  {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/

    bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);

    for(i = 0; i != NUM_CODE_LENGTH_CODES; ++i)
    {
      if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);
      else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i != NUM_DEFLATE_CODE_SYMBOLS; ++i) bitlen_ll[i] = 0;
    for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen_d[i] = 0;

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST)
    {
      unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);
      if(code <= 15) /*a length code*/
      {
        if(i < HLIT) bitlen_ll[i] = code;
        else bitlen_d[i - HLIT] = code;
        ++i;
      }
      else if(code == 16) /*repeat previous*/
      {
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/

        if((*bp + 2) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
        replength += readBitsFromStream(bp, in, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      }
      else if(code == 17) /*repeat "0" 3-10 times*/
      {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        if((*bp + 3) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
        replength += readBitsFromStream(bp, in, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      }
      else if(code == 18) /*repeat "0" 11-138 times*/
      {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        if((*bp + 7) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
        replength += readBitsFromStream(bp, in, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      }
      else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
      {
        if(code == (unsigned)(-1))
        {
          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
          (10=no endcode, 11=wrong jump outside of tree)*/
          error = (*bp) > inbitlength ? 10 : 11;
        }
        else error = 16; /*unexisting code, this can never happen*/
        break;
      }
    }
    if(error) break;

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
  lodepng_free(bitlen_ll);
  lodepng_free(bitlen_d);
  HuffmanTree_cleanup(&tree_cl);

  return error;
}

/*inflate a block with dynamic of fixed Huffman tree*/
static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,
                                    size_t* pos, size_t inlength, unsigned btype)
{
  unsigned error = 0;
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/
  size_t inbitlength = inlength * 8;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);
  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);

  while(!error) /*decode all symbols until end reached, breaks at end code*/
  {
    /*code_ll is literal, length or end code*/
    unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);
    if(code_ll <= 255) /*literal symbol*/
    {
      /*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/
      if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[*pos] = (unsigned char)code_ll;
      ++(*pos);
    }
    else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/
    {
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, forward, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
      if((*bp + numextrabits_l) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
      length += readBitsFromStream(bp, in, numextrabits_l);

      /*part 3: get distance code*/
      code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);
      if(code_d > 29)
      {
        if(code_d == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
        {
          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
          (10=no endcode, 11=wrong jump outside of tree)*/
          error = (*bp) > inlength * 8 ? 10 : 11;
        }
        else error = 18; /*error: invalid distance code (30-31 are never used)*/
        break;
      }
      distance = DISTANCEBASE[code_d];

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
      if((*bp + numextrabits_d) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
      distance += readBitsFromStream(bp, in, numextrabits_d);

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = (*pos);
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
      backward = start - distance;

      if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);
      if (distance < length) {
        for(forward = 0; forward < length; ++forward)
        {
          out->data[(*pos)++] = out->data[backward++];
        }
      } else {
        memcpy(out->data + *pos, out->data + backward, length);
        *pos += length;
      }
    }
    else if(code_ll == 256)
    {
      break; /*end code, break the loop*/
    }
    else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
    {
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      error = ((*bp) > inlength * 8) ? 10 : 11;
      break;
    }
  }

  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)
{
  size_t p;
  unsigned LEN, NLEN, n, error = 0;

  /*go to first boundary of byte*/
  while(((*bp) & 0x7) != 0) ++(*bp);
  p = (*bp) / 8; /*byte position*/

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(p + 4 >= inlength) return 52; /*error, bit pointer will jump past memory*/
  LEN = in[p] + 256u * in[p + 1]; p += 2;
  NLEN = in[p] + 256u * in[p + 1]; p += 2;

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/

  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
  for(n = 0; n < LEN; ++n) out->data[(*pos)++] = in[p++];

  (*bp) = p * 8;

  return error;
}

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings)
{
  /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
  size_t bp = 0;
  unsigned BFINAL = 0;
  size_t pos = 0; /*byte position in the out buffer*/
  unsigned error = 0;

  (void)settings;

  while(!BFINAL)
  {
    unsigned BTYPE;
    if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/
    BFINAL = readBitFromStream(&bp, in);
    BTYPE = 1u * readBitFromStream(&bp, in);
    BTYPE += 2u * readBitFromStream(&bp, in);

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/
    else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/

    if(error) return error;
  }

  return error;
}

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_inflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned inflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings)
{
  if(settings->custom_inflate)
  {
    return settings->custom_inflate(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_inflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflator (Compressor)                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*bitlen is the size in bits of the code*/
static void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)
{
  addBitsToStreamReversed(bp, compressed, code, bitlen);
}

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)
{
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    size_t mid = (left + right) >> 1;
    if (array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
  return left;
}

static void addLengthDistance(uivector* values, size_t length, size_t distance)
{
  /*values in encoded vector are those used by deflate:
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);

  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);
  uivector_push_back(values, extra_length);
  uivector_push_back(values, dist_code);
  uivector_push_back(values, extra_distance);
}

/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3
bytes as input because 3 is the minimum match length for deflate*/
static const unsigned HASH_NUM_VALUES = 65536;
static const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/

typedef struct Hash
{
  int* head; /*hash value to head circular pos - can be outdated if went around window*/
  /*circular pos to prev circular pos*/
  unsigned short* chain;
  int* val; /*circular pos to hash value*/

  /*TODO: do this not only for zeros but for any repeated byte. However for PNG
  it's always going to be the zeros that dominate, so not important for PNG*/
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize)
{
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)
  {
    return 83; /*alloc fail*/
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/

  return 0;
}

static void hash_cleanup(Hash* hash)
{
  lodepng_free(hash->head);
  lodepng_free(hash->val);
  lodepng_free(hash->chain);

  lodepng_free(hash->zeros);
  lodepng_free(hash->headz);
  lodepng_free(hash->chainz);
}



static unsigned getHash(const unsigned char* data, size_t size, size_t pos)
{
  unsigned result = 0;
  if(pos + 2 < size)
  {
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= (unsigned)(data[pos + 0] << 0u);
    result ^= (unsigned)(data[pos + 1] << 4u);
    result ^= (unsigned)(data[pos + 2] << 8u);
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    amount = size - pos;
    for(i = 0; i != amount; ++i) result ^= (unsigned)(data[pos + i] << (i * 8u));
  }
  return result & HASH_BIT_MASK;
}

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)
{
  const unsigned char* start = data + pos;
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
  if(end > data + size) end = data + size;
  data = start;
  while(data != end && *data == 0) ++data;
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
}

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)
{
  hash->val[wpos] = (int)hashval;
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
  hash->head[hashval] = (int)wpos;

  hash->zeros[wpos] = numzeros;
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
  hash->headz[numzeros] = (int)wpos;
}

/*
LZ77-encode the data. Return value is error code. The input are raw bytes, the output
is in the form of unsigned integers with codes representing for example literal bytes, or
length/distance pairs.
It uses a hash table technique to let it encode faster. When doing LZ77 encoding, a
sliding window (of windowsize) is used, and all past bytes in that window can be used as
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching)
{
  size_t pos;
  unsigned i, error = 0;
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
  unsigned numzeros = 0;

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
  unsigned lazylength = 0, lazyoffset = 0;
  unsigned hashval;
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos)
  {
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0)
    {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    }
    else
    {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);

    /*the length and offset found for the current position*/
    length = 0;
    offset = 0;

    hashpos = hash->chain[wpos];

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;)
    {
      if(chainlength++ >= maxchainlength) break;
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
      prev_offset = current_offset;
      if(current_offset > 0)
      {
        /*test the next characters*/
        foreptr = &in[pos];
        backptr = &in[pos - current_offset];

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3)
        {
          unsigned skip = hash->zeros[hashpos];
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/
        {
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);

        if(current_length > length)
        {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
        }
      }

      if(hashpos == hash->chain[hashpos]) break;

      if(numzeros >= 3 && length > numzeros)
      {
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      }
      else
      {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
      }
    }

    if(lazymatching)
    {
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)
      {
        lazy = 1;
        lazylength = length;
        lazyoffset = offset;
        continue; /*try the next byte*/
      }
      if(lazy)
      {
        lazy = 0;
        if(pos == 0) ERROR_BREAK(81);
        if(length > lazylength + 1)
        {
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
        }
        else
        {
          length = lazylength;
          offset = lazyoffset;
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
          hash->headz[numzeros] = -1; /*idem*/
          --pos;
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/
    {
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    }
    else if(length < minmatch || (length == 3 && offset > 4096))
    {
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    }
    else
    {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i)
      {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0)
        {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        }
        else
        {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
}

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)
{
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i)
  {
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;

    BFINAL = (i == numdeflateblocks - 1);
    BTYPE = 0;

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));
    ucvector_push_back(out, firstbyte);

    LEN = 65535;
    if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;
    NLEN = 65535 - LEN;

    ucvector_push_back(out, (unsigned char)(LEN & 255));
    ucvector_push_back(out, (unsigned char)(LEN >> 8));
    ucvector_push_back(out, (unsigned char)(NLEN & 255));
    ucvector_push_back(out, (unsigned char)(NLEN >> 8));

    /*Decompressed data*/
    for(j = 0; j < 65535 && datapos < datasize; ++j)
    {
      ucvector_push_back(out, data[datapos++]);
    }
  }

  return 0;
}

/*
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d)
{
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i)
  {
    unsigned val = lz77_encoded->data[i];
    addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));
    if(val > 256) /*for a length code, 3 more things have to be added*/
    {
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
      unsigned length_extra_bits = lz77_encoded->data[++i];

      unsigned distance_code = lz77_encoded->data[++i];

      unsigned distance_index = distance_code;
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
      unsigned distance_extra_bits = lz77_encoded->data[++i];

      addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),
                       HuffmanTree_getLength(tree_d, distance_code));
      addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);
    }
  }
}

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final)
{
  unsigned error = 0;

  /*
  A block is compressed as follows: The PNG data is lz77 encoded, resulting in
  literal bytes and length/distance pairs. This is then huffman compressed with
  two huffman trees. One huffman tree is used for the lit and len values ("ll"),
  another huffman tree is used for the dist values ("d"). These two trees are
  stored using their code lengths, and to compress even more these code lengths
  are also run-length encoded and huffman compressed. This gives a huffman tree
  of code lengths "cl". The code lenghts used to describe this third tree are
  the code length code lengths ("clcl").
  */

  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  uivector frequencies_ll; /*frequency of lit,len codes*/
  uivector frequencies_d; /*frequency of dist codes*/
  uivector frequencies_cl; /*frequency of code length codes*/
  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/
  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/
  /*bitlen_cl is the code length code lengths ("clcl"). The bit lengths of codes to represent tree_cl
  (these are written as is in the file, it would be crazy to compress these using yet another huffman
  tree that needs to be represented by yet another set of code lengths)*/
  uivector bitlen_cl;
  size_t datasize = dataend - datapos;

  /*
  Due to the huffman compression of huffman tree representations ("two levels"), there are some anologies:
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
  size_t numcodes_ll, numcodes_d, i;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);
  HuffmanTree_init(&tree_cl);
  uivector_init(&frequencies_ll);
  uivector_init(&frequencies_d);
  uivector_init(&frequencies_cl);
  uivector_init(&bitlen_lld);
  uivector_init(&bitlen_lld_e);
  uivector_init(&bitlen_cl);

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error)
  {
    if(settings->use_lz77)
    {
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    }
    else
    {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);
    if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i)
    {
      unsigned symbol = lz77_encoded.data[i];
      ++frequencies_ll.data[symbol];
      if(symbol > 256)
      {
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d.data[dist];
        i += 3;
      }
    }
    frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);
    if(error) break;
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);
    if(error) break;

    numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;
    numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;
    /*store the code lengths of both generated trees in bitlen_lld*/
    for(i = 0; i != numcodes_ll; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));
    for(i = 0; i != numcodes_d; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != (unsigned)bitlen_lld.size; ++i)
    {
      unsigned j = 0; /*amount of repititions*/
      while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) ++j;

      if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/
      {
        ++j; /*include the first zero*/
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/
        {
          uivector_push_back(&bitlen_lld_e, 17);
          uivector_push_back(&bitlen_lld_e, j - 3);
        }
        else /*repeat code 18 supports max 138 zeroes*/
        {
          if(j > 138) j = 138;
          uivector_push_back(&bitlen_lld_e, 18);
          uivector_push_back(&bitlen_lld_e, j - 11);
        }
        i += (j - 1);
      }
      else if(j >= 3) /*repeat code for value other than zero*/
      {
        size_t k;
        unsigned num = j / 6, rest = j % 6;
        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
        for(k = 0; k < num; ++k)
        {
          uivector_push_back(&bitlen_lld_e, 16);
          uivector_push_back(&bitlen_lld_e, 6 - 3);
        }
        if(rest >= 3)
        {
          uivector_push_back(&bitlen_lld_e, 16);
          uivector_push_back(&bitlen_lld_e, rest - 3);
        }
        else j -= rest;
        i += j;
      }
      else /*too short to benefit from repeat code*/
      {
        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/

    if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i != bitlen_lld_e.size; ++i)
    {
      ++frequencies_cl.data[bitlen_lld_e.data[i]];
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e.data[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,
                                            frequencies_cl.size, frequencies_cl.size, 7);
    if(error) break;

    if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i != tree_cl.numcodes; ++i)
    {
      /*lenghts of code length tree is in the order as specified by deflate*/
      bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);
    }
    while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)
    {
      /*remove zeros at the end, but minimum size must be 4*/
      if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);
    }
    if(error) break;

    /*
    Write everything into the output

    After the BFINAL and BTYPE, the dynamic block consists out of the following:
    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN
    - (HCLEN+4)*3 bits code lengths of code length alphabet
    - HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length
      alphabet, + possible repetition codes 16, 17, 18)
    - HDIST + 1 code lengths of distance alphabet (encoded using the code length
      alphabet, + possible repetition codes 16, 17, 18)
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    addBitToStream(bp, out, BFINAL);
    addBitToStream(bp, out, 0); /*first bit of BTYPE "dynamic"*/
    addBitToStream(bp, out, 1); /*second bit of BTYPE "dynamic"*/

    /*write the HLIT, HDIST and HCLEN values*/
    HLIT = (unsigned)(numcodes_ll - 257);
    HDIST = (unsigned)(numcodes_d - 1);
    HCLEN = (unsigned)bitlen_cl.size - 4;
    /*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/
    while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) --HCLEN;
    addBitsToStream(bp, out, HLIT, 5);
    addBitsToStream(bp, out, HDIST, 5);
    addBitsToStream(bp, out, HCLEN, 4);

    /*write the code lenghts of the code length alphabet*/
    for(i = 0; i != HCLEN + 4; ++i) addBitsToStream(bp, out, bitlen_cl.data[i], 3);

    /*write the lenghts of the lit/len AND the dist alphabet*/
    for(i = 0; i != bitlen_lld_e.size; ++i)
    {
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),
                       HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));
      /*extra bits of repeat codes*/
      if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);
      else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);
      else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
    /*error: the length of the end code 256 must be larger than 0*/
    if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);

    /*write the end code*/
    addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);
  HuffmanTree_cleanup(&tree_cl);
  uivector_cleanup(&frequencies_ll);
  uivector_cleanup(&frequencies_d);
  uivector_cleanup(&frequencies_cl);
  uivector_cleanup(&bitlen_lld_e);
  uivector_cleanup(&bitlen_lld);
  uivector_cleanup(&bitlen_cl);

  return error;
}

static unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final)
{
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
  unsigned error = 0;
  size_t i;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  generateFixedLitLenTree(&tree_ll);
  generateFixedDistanceTree(&tree_d);

  addBitToStream(bp, out, BFINAL);
  addBitToStream(bp, out, 1); /*first bit of BTYPE*/
  addBitToStream(bp, out, 0); /*second bit of BTYPE*/

  if(settings->use_lz77) /*LZ77 encoded*/
  {
    uivector lz77_encoded;
    uivector_init(&lz77_encoded);
    error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                       settings->minmatch, settings->nicematch, settings->lazymatching);
    if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
    uivector_cleanup(&lz77_encoded);
  }
  else /*no LZ77, but still will be Huffman compressed*/
  {
    for(i = datapos; i < dataend; ++i)
    {
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));
    }
  }
  /*add END code*/
  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings)
{
  unsigned error = 0;
  size_t i, blocksize, numdeflateblocks;
  size_t bp = 0; /*the bit pointer*/
  Hash hash;

  if(settings->btype > 2) return 61;
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
  else if(settings->btype == 1) blocksize = insize;
  else /*if(settings->btype == 2)*/
  {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8 + 8;
    if(blocksize < 65536) blocksize = 65536;
    if(blocksize > 262144) blocksize = 262144;
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);
  if(error) return error;

  for(i = 0; i != numdeflateblocks && !error; ++i)
  {
    unsigned final = (i == numdeflateblocks - 1);
    size_t start = i * blocksize;
    size_t end = start + blocksize;
    if(end > insize) end = insize;

    if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);
    else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);
  }

  hash_cleanup(&hash);

  return error;
}

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_deflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings)
{
  if(settings->custom_deflate)
  {
    return settings->custom_deflate(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_deflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                  */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
  unsigned s1 = adler & 0xffff;
  unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552 ? 5552 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      --amount;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len)
{
  return update_adler32(1L, data, len);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Zlib                                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DECODER

unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings)
{
  unsigned error = 0;
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0)
  {
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
  }

  CM = in[0] & 15;
  CINFO = (in[0] >> 4) & 15;
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7)
  {
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
  }
  if(FDICT != 0)
  {
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
  }

  error = inflate(out, outsize, in + 2, insize - 2, settings);
  if(error) return error;

  if(!settings->ignore_adler32)
  {
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    unsigned checksum = adler32(*out, (unsigned)(*outsize));
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
  }

  return 0; /*no error*/
}

static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                size_t insize, const LodePNGDecompressSettings* settings)
{
  if(settings->custom_zlib)
  {
    return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_zlib_decompress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings)
{
  /*initially, *out must be NULL and outsize 0, if you just give some random *out
  that's pointing to a non allocated buffer, this'll crash*/
  ucvector outv;
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
  size_t deflatesize = 0;

  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
  unsigned FLEVEL = 0;
  unsigned FDICT = 0;
  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
  unsigned FCHECK = 31 - CMFFLG % 31;
  CMFFLG += FCHECK;

  /*ucvector-controlled version of the output buffer, for dynamic array*/
  ucvector_init_buffer(&outv, *out, *outsize);

  ucvector_push_back(&outv, (unsigned char)(CMFFLG >> 8));
  ucvector_push_back(&outv, (unsigned char)(CMFFLG & 255));

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);

  if(!error)
  {
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    for(i = 0; i != deflatesize; ++i) ucvector_push_back(&outv, deflatedata[i]);
    lodepng_free(deflatedata);
    lodepng_add32bitInt(&outv, ADLER32);
  }

  *out = outv.data;
  *outsize = outv.size;

  return error;
}

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings)
{
  if(settings->custom_zlib)
  {
    return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_ENCODER*/

#else /*no LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DECODER
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                size_t insize, const LodePNGDecompressSettings* settings)
{
  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings)
{
  if(!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#endif /*LODEPNG_COMPILE_ZLIB*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings)
{
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
  settings->use_lz77 = 1;
  settings->windowsize = DEFAULT_WINDOWSIZE;
  settings->minmatch = 3;
  settings->nicematch = 128;
  settings->lazymatching = 1;

  settings->custom_zlib = 0;
  settings->custom_deflate = 0;
  settings->custom_context = 0;
}

const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};


#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)
{
  settings->ignore_adler32 = 0;

  settings->custom_zlib = 0;
  settings->custom_inflate = 0;
  settings->custom_context = 0;
}

const LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of Zlib related code. Begin of PNG related code.                 // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG

/* ////////////////////////////////////////////////////////////////////////// */
/* / CRC32                                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */


#ifndef LODEPNG_NO_COMPILE_CRC
/* CRC polynomial: 0xedb88320 */
static unsigned lodepng_crc32_table[256] = {
           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,
   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,
   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,
   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,
   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,
   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,
   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,
   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,
  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,
  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,
  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,
  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,
  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,
  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,
  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,
  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,
  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,
  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,
  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,
  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,
  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,
  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,
  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,
  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,
  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,
  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,
  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,
  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,
  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,
  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length)
{
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i)
  {
    r = lodepng_crc32_table[(r ^ data[i]) & 0xff] ^ (r >> 8);
  }
  return r ^ 0xffffffffu;
}
#else /* !LODEPNG_NO_COMPILE_CRC */
unsigned lodepng_crc32(const unsigned char* data, size_t length);
#endif /* !LODEPNG_NO_COMPILE_CRC */

/* ////////////////////////////////////////////////////////////////////////// */
/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i)
  {
    result <<= 1;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
}

#ifdef LODEPNG_COMPILE_DECODER
static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream must be 0 for this to work*/
  if(bit)
  {
    /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
    bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));
  }
  ++(*bitpointer);
}
#endif /*LODEPNG_COMPILE_DECODER*/

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
  ++(*bitpointer);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk)
{
  return lodepng_read32bitInt(&chunk[0]);
}

void lodepng_chunk_type(char type[5], const unsigned char* chunk)
{
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
  type[4] = 0; /*null termination char*/
}

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)
{
  if(strlen(type) != 4) return 0;
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
}

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk)
{
  return((chunk[4] & 32) != 0);
}

unsigned char lodepng_chunk_private(const unsigned char* chunk)
{
  return((chunk[6] & 32) != 0);
}

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)
{
  return((chunk[7] & 32) != 0);
}

unsigned char* lodepng_chunk_data(unsigned char* chunk)
{
  return &chunk[8];
}

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)
{
  return &chunk[8];
}

unsigned lodepng_chunk_check_crc(const unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
  if(CRC != checksum) return 1;
  else return 0;
}

void lodepng_chunk_generate_crc(unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
  lodepng_set32bitInt(chunk + 8 + length, CRC);
}

unsigned char* lodepng_chunk_next(unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)
{
  unsigned i;
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  unsigned char *chunk_start, *new_buffer;
  size_t new_length = (*outlength) + total_chunk_length;
  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk_start = &(*out)[new_length - total_chunk_length];

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];

  return 0;
}

unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
                              const char* type, const unsigned char* data)
{
  unsigned i;
  unsigned char *chunk, *new_buffer;
  size_t new_length = (*outlength) + length + 12;
  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/
  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk = &(*out)[(*outlength) - length - 12];

  /*1: length*/
  lodepng_set32bitInt(chunk, (unsigned)length);

  /*2: chunk name (4 letters)*/
  chunk[4] = (unsigned char)type[0];
  chunk[5] = (unsigned char)type[1];
  chunk[6] = (unsigned char)type[2];
  chunk[7] = (unsigned char)type[3];

  /*3: the data*/
  for(i = 0; i != length; ++i) chunk[8 + i] = data[i];

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);

  return 0;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Color types and such                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

/*return type is a LodePNG error code*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/
{
  switch(colortype)
  {
    case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
    case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
    case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
    case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
    case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
    default: return 31;
  }
  return 0; /*allowed color type / bits combination*/
}

static unsigned getNumColorChannels(LodePNGColorType colortype)
{
  switch(colortype)
  {
    case 0: return 1; /*grey*/
    case 2: return 3; /*RGB*/
    case 3: return 1; /*palette*/
    case 4: return 2; /*grey + alpha*/
    case 6: return 4; /*RGBA*/
  }
  return 0; /*unexisting color type*/
}

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)
{
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
}

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info)
{
  info->key_defined = 0;
  info->key_r = info->key_g = info->key_b = 0;
  info->colortype = LCT_RGBA;
  info->bitdepth = 8;
  info->palette = 0;
  info->palettesize = 0;
}

void lodepng_color_mode_cleanup(LodePNGColorMode* info)
{
  lodepng_palette_clear(info);
}

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)
{
  size_t i;
  lodepng_color_mode_cleanup(dest);
  *dest = *source;
  if(source->palette)
  {
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    for(i = 0; i != source->palettesize * 4; ++i) dest->palette[i] = source->palette[i];
  }
  return 0;
}

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)
{
  size_t i;
  if(a->colortype != b->colortype) return 0;
  if(a->bitdepth != b->bitdepth) return 0;
  if(a->key_defined != b->key_defined) return 0;
  if(a->key_defined)
  {
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i)
  {
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
}

void lodepng_palette_clear(LodePNGColorMode* info)
{
  if(info->palette) lodepng_free(info->palette);
  info->palette = 0;
  info->palettesize = 0;
}

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  unsigned char* data;
  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with
  the max of 256 colors, it'll have the exact alloc size*/
  if(!info->palette) /*allocate palette if empty*/
  {
    /*room for 256 colors with 4 bytes each*/
    data = (unsigned char*)lodepng_realloc(info->palette, 1024);
    if(!data) return 83; /*alloc fail*/
    else info->palette = data;
  }
  info->palette[4 * info->palettesize + 0] = r;
  info->palette[4 * info->palettesize + 1] = g;
  info->palette[4 * info->palettesize + 2] = b;
  info->palette[4 * info->palettesize + 3] = a;
  ++info->palettesize;
  return 0;
}

unsigned lodepng_get_bpp(const LodePNGColorMode* info)
{
  /*calculate bits per pixel out of colortype and bitdepth*/
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
}

unsigned lodepng_get_channels(const LodePNGColorMode* info)
{
  return getNumColorChannels(info->colortype);
}

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
}

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info)
{
  return (info->colortype & 4) != 0; /*4 or 6*/
}

unsigned lodepng_is_palette_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)
{
  size_t i;
  for(i = 0; i != info->palettesize; ++i)
  {
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info)
{
  return info->key_defined
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
}

size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
  size_t n = (size_t)w * (size_t)h;
  return ((n / 8) * bpp) + ((n & 7) * bpp + 7) / 8;
}

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
}


#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_DECODER

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  size_t bpp = lodepng_get_bpp(color);
  /* + 1 for the filter byte, and possibly plus padding bits per line */
  size_t line = ((size_t)(w / 8) * bpp) + 1 + ((w & 7) * bpp + 7) / 8;
  return (size_t)h * line;
}

/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result)
{
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
  return (a != 0 && *result / a != b);
}

/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result)
{
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
  return *result < a;
}

/*Safely checks whether size_t overflow can be caused due to amount of pixels.
This check is overcautious rather than precise. If this check indicates no overflow,
you can safely compute in a size_t (but not an unsigned):
-(size_t)w * (size_t)h * 8
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor)
{
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */

  /* Bytes per scanline with the expression "(w / 8) * bpp) + ((w & 7) * bpp + 7) / 8" */
  if(lodepng_mulofl((size_t)(w / 8), bpp, &line)) return 1;
  if(lodepng_addofl(line, ((w & 7) * bpp + 7) / 8, &line)) return 1;

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */

  return 0; /* no overflow */
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
}

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
}

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)
{
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i)
  {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j)
    {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
}

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info)
{
  info->text_num = 0;
  info->text_keys = NULL;
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->text_num; ++i)
  {
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
  lodepng_free(info->text_strings);
}

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->text_keys = 0;
  dest->text_strings = 0;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i)
  {
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
}

void lodepng_clear_text(LodePNGInfo* info)
{
  LodePNGText_cleanup(info);
}

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
  if(!new_keys || !new_strings)
  {
    lodepng_free(new_keys);
    lodepng_free(new_strings);
    return 83; /*alloc fail*/
  }

  ++info->text_num;
  info->text_keys = new_keys;
  info->text_strings = new_strings;

  string_init(&info->text_keys[info->text_num - 1]);
  string_set(&info->text_keys[info->text_num - 1], key);

  string_init(&info->text_strings[info->text_num - 1]);
  string_set(&info->text_strings[info->text_num - 1], str);

  return 0;
}

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info)
{
  info->itext_num = 0;
  info->itext_keys = NULL;
  info->itext_langtags = NULL;
  info->itext_transkeys = NULL;
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->itext_num; ++i)
  {
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
  lodepng_free(info->itext_langtags);
  lodepng_free(info->itext_transkeys);
  lodepng_free(info->itext_strings);
}

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->itext_keys = 0;
  dest->itext_langtags = 0;
  dest->itext_transkeys = 0;
  dest->itext_strings = 0;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i)
  {
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
}

void lodepng_clear_itext(LodePNGInfo* info)
{
  LodePNGIText_cleanup(info);
}

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
  {
    lodepng_free(new_keys);
    lodepng_free(new_langtags);
    lodepng_free(new_transkeys);
    lodepng_free(new_strings);
    return 83; /*alloc fail*/
  }

  ++info->itext_num;
  info->itext_keys = new_keys;
  info->itext_langtags = new_langtags;
  info->itext_transkeys = new_transkeys;
  info->itext_strings = new_strings;

  string_init(&info->itext_keys[info->itext_num - 1]);
  string_set(&info->itext_keys[info->itext_num - 1], key);

  string_init(&info->itext_langtags[info->itext_num - 1]);
  string_set(&info->itext_langtags[info->itext_num - 1], langtag);

  string_init(&info->itext_transkeys[info->itext_num - 1]);
  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);

  string_init(&info->itext_strings[info->itext_num - 1]);
  string_set(&info->itext_strings[info->itext_num - 1], str);

  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info)
{
  lodepng_color_mode_init(&info->color);
  info->interlace_method = 0;
  info->compression_method = 0;
  info->filter_method = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
  info->background_r = info->background_g = info->background_b = 0;

  LodePNGText_init(info);
  LodePNGIText_init(info);

  info->time_defined = 0;
  info->phys_defined = 0;

  LodePNGUnknownChunks_init(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

void lodepng_info_cleanup(LodePNGInfo* info)
{
  lodepng_color_mode_cleanup(&info->color);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
  LodePNGIText_cleanup(info);

  LodePNGUnknownChunks_cleanup(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  lodepng_info_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->color);
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));

  LodePNGUnknownChunks_init(dest);
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
}

void lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)
{
  LodePNGInfo temp = *a;
  *a = *b;
  *b = temp;
}

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)
{
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8] = in;
  else out[index * bits / 8] |= in;
}

typedef struct ColorTree ColorTree;

/*
One node of a color tree
This is the data structure used to count the number of unique colors and to get a palette
index for a color. It's like an octree, but because the alpha channel is used too, each
node has 16 instead of 8 children.
*/
struct ColorTree
{
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i) tree->children[i] = 0;
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i)
  {
    if(tree->children[i])
    {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  int bit = 0;
  for(bit = 0; bit < 8; ++bit)
  {
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
}

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  return color_tree_get(tree, r, g, b, a) >= 0;
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")*/
static void color_tree_add(ColorTree* tree,
                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)
{
  int bit;
  for(bit = 0; bit < 8; ++bit)
  {
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i])
    {
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
}

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  if(mode->colortype == LCT_GREY)
  {
    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
    if(mode->bitdepth == 8) out[i] = grey;
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;
    else
    {
      /*take the most significant bits of grey*/
      grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);
      addColorBits(out, i, mode->bitdepth, grey);
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      out[i * 3 + 0] = r;
      out[i * 3 + 1] = g;
      out[i * 3 + 2] = b;
    }
    else
    {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
      out[i * 6 + 2] = out[i * 6 + 3] = g;
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    int index = color_tree_get(tree, r, g, b, a);
    if(index < 0) return 82; /*color not in palette*/
    if(mode->bitdepth == 8) out[i] = index;
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
    if(mode->bitdepth == 8)
    {
      out[i * 2 + 0] = grey;
      out[i * 2 + 1] = a;
    }
    else if(mode->bitdepth == 16)
    {
      out[i * 4 + 0] = out[i * 4 + 1] = grey;
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      out[i * 4 + 0] = r;
      out[i * 4 + 1] = g;
      out[i * 4 + 2] = b;
      out[i * 4 + 3] = a;
    }
    else
    {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
      out[i * 8 + 2] = out[i * 8 + 3] = g;
      out[i * 8 + 4] = out[i * 8 + 5] = b;
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    }
  }

  return 0; /*no error*/
}

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a)
{
  if(mode->colortype == LCT_GREY)
  {
    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
    out[i * 2 + 0] = (grey >> 8) & 255;
    out[i * 2 + 1] = grey & 255;
  }
  else if(mode->colortype == LCT_RGB)
  {
    out[i * 6 + 0] = (r >> 8) & 255;
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
    out[i * 4 + 0] = (grey >> 8) & 255;
    out[i * 4 + 1] = grey & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  }
  else if(mode->colortype == LCT_RGBA)
  {
    out[i * 8 + 0] = (r >> 8) & 255;
    out[i * 8 + 1] = r & 255;
    out[i * 8 + 2] = (g >> 8) & 255;
    out[i * 8 + 3] = g & 255;
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
    if(mode->bitdepth == 8)
    {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    }
    else if(mode->bitdepth == 16)
    {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    }
    else
    {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = i * mode->bitdepth;
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    }
    else
    {
      *r = in[i * 6 + 0];
      *g = in[i * 6 + 2];
      *b = in[i * 6 + 4];
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    else
    {
      size_t j = i * mode->bitdepth;
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    }

    if(index >= mode->palettesize)
    {
      /*This is an error according to the PNG spec, but common PNG decoders make it black instead.
      Done here too, slightly faster due to no error handling needed.*/
      *r = *g = *b = 0;
      *a = 255;
    }
    else
    {
      *r = mode->palette[index * 4 + 0];
      *g = mode->palette[index * 4 + 1];
      *b = mode->palette[index * 4 + 2];
      *a = mode->palette[index * 4 + 3];
    }
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    if(mode->bitdepth == 8)
    {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    }
    else
    {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    }
    else
    {
      *r = in[i * 8 + 0];
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}

/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color
mode test cases, optimized to convert the colors much faster, when converting
to RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with
enough memory, if has_alpha is true the output is RGBA. mode has the color mode
of the input buffer.*/
static void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,
                                unsigned has_alpha, const unsigned char* in,
                                const LodePNGColorMode* mode)
{
  unsigned num_channels = has_alpha ? 4 : 3;
  size_t i;
  if(mode->colortype == LCT_GREY)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i];
        if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;
      }
    }
    else if(mode->bitdepth == 16)
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    }
    else
    {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = in[i * 3 + 0];
        buffer[1] = in[i * 3 + 1];
        buffer[2] = in[i * 3 + 2];
        if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r
           && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;
      }
    }
    else
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        if(has_alpha) buffer[3] = mode->key_defined
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    unsigned index;
    size_t j = 0;
    for(i = 0; i != numpixels; ++i, buffer += num_channels)
    {
      if(mode->bitdepth == 8) index = in[i];
      else index = readBitsFromReversedStream(&j, in, mode->bitdepth);

      if(index >= mode->palettesize)
      {
        /*This is an error according to the PNG spec, but most PNG decoders make it black instead.
        Done here too, slightly faster due to no error handling needed.*/
        buffer[0] = buffer[1] = buffer[2] = 0;
        if(has_alpha) buffer[3] = 255;
      }
      else
      {
        buffer[0] = mode->palette[index * 4 + 0];
        buffer[1] = mode->palette[index * 4 + 1];
        buffer[2] = mode->palette[index * 4 + 2];
        if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];
      }
    }
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        if(has_alpha) buffer[3] = in[i * 2 + 1];
      }
    }
    else
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        if(has_alpha) buffer[3] = in[i * 4 + 2];
      }
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = in[i * 4 + 0];
        buffer[1] = in[i * 4 + 1];
        buffer[2] = in[i * 4 + 2];
        if(has_alpha) buffer[3] = in[i * 4 + 3];
      }
    }
    else
    {
      for(i = 0; i != numpixels; ++i, buffer += num_channels)
      {
        buffer[0] = in[i * 8 + 0];
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
        if(has_alpha) buffer[3] = in[i * 8 + 6];
      }
    }
  }
}

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  }
  else if(mode->colortype == LCT_RGB)
  {
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  }
  else if(mode->colortype == LCT_RGBA)
  {
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h)
{
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
  unsigned error = 0;

  if(lodepng_color_mode_equal(mode_out, mode_in))
  {
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    for(i = 0; i != numbytes; ++i) out[i] = in[i];
    return 0;
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
    size_t palettesize = mode_out->palettesize;
    const unsigned char* palette = mode_out->palette;
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0)
    {
      palettesize = mode_in->palettesize;
      palette = mode_in->palette;
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if (mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth)
      {
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
        for(i = 0; i != numbytes; ++i) out[i] = in[i];
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i)
    {
      const unsigned char* p = &palette[i * 4];
      color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    }
  }

  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)
  {
    for(i = 0; i != numpixels; ++i)
    {
      unsigned short r = 0, g = 0, b = 0, a = 0;
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      rgba16ToPixel(out, i, mode_out, r, g, b, a);
    }
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)
  {
    getPixelColorsRGBA8(out, numpixels, 1, in, mode_in);
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)
  {
    getPixelColorsRGBA8(out, numpixels, 0, in, mode_in);
  }
  else
  {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i)
    {
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
      error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
      if (error) break;
    }
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
    color_tree_cleanup(&tree);
  }

  return error;
}

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_profile_init(LodePNGColorProfile* profile)
{
  profile->colored = 0;
  profile->key = 0;
  profile->key_r = profile->key_g = profile->key_b = 0;
  profile->alpha = 0;
  profile->numcolors = 0;
  profile->bits = 1;
}

/*function used for debug purposes with C++*/
/*void printColorProfile(LodePNGColorProfile* p)
{
  std::cout << "colored: " << (int)p->colored << ", ";
  std::cout << "key: " << (int)p->key << ", ";
  std::cout << "key_r: " << (int)p->key_r << ", ";
  std::cout << "key_g: " << (int)p->key_g << ", ";
  std::cout << "key_b: " << (int)p->key_b << ", ";
  std::cout << "alpha: " << (int)p->alpha << ", ";
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value)
{
  if(value == 0 || value == 255) return 1;
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  return 8;
}

/*profile must already have been inited with mode.
It's ok to set some parameters of profile to done already.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
                                   const unsigned char* in, unsigned w, unsigned h,
                                   const LodePNGColorMode* mode)
{
  unsigned error = 0;
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;

  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;
  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;
  unsigned numcolors_done = 0;
  unsigned bpp = lodepng_get_bpp(mode);
  unsigned bits_done = bpp == 1 ? 1 : 0;
  unsigned maxnumcolors = 257;
  unsigned sixteen = 0;
  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));

  color_tree_init(&tree);

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode->bitdepth == 16)
  {
    unsigned short r, g, b, a;
    for(i = 0; i != numpixels; ++i)
    {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/
      {
        sixteen = 1;
        break;
      }
    }
  }

  if(sixteen)
  {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    profile->bits = 16;
    bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/

    for(i = 0; i != numpixels; ++i)
    {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);

      if(!colored_done && (r != g || r != b))
      {
        profile->colored = 1;
        colored_done = 1;
      }

      if(!alpha_done)
      {
        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
        if(a != 65535 && (a != 0 || (profile->key && !matchkey)))
        {
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
        }
        else if(a == 0 && !profile->alpha && !profile->key)
        {
          profile->key = 1;
          profile->key_r = r;
          profile->key_g = g;
          profile->key_b = b;
        }
        else if(a == 65535 && profile->key && matchkey)
        {
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(profile->key && !profile->alpha)
    {
      for(i = 0; i != numpixels; ++i)
      {
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);
        if(a != 0 && r == profile->key_r && g == profile->key_g && b == profile->key_b)
        {
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
        }
      }
    }
  }
  else /* < 16-bit */
  {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i)
    {
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);

      if(!bits_done && profile->bits < 8)
      {
        /*only r is checked, < 8 bits is only relevant for greyscale*/
        unsigned bits = getValueRequiredBits(r);
        if(bits > profile->bits) profile->bits = bits;
      }
      bits_done = (profile->bits >= bpp);

      if(!colored_done && (r != g || r != b))
      {
        profile->colored = 1;
        colored_done = 1;
        if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
      }

      if(!alpha_done)
      {
        unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
        if(a != 255 && (a != 0 || (profile->key && !matchkey)))
        {
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
        }
        else if(a == 0 && !profile->alpha && !profile->key)
        {
          profile->key = 1;
          profile->key_r = r;
          profile->key_g = g;
          profile->key_b = b;
        }
        else if(a == 255 && profile->key && matchkey)
        {
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
        }
      }

      if(!numcolors_done)
      {
        if(!color_tree_has(&tree, r, g, b, a))
        {
          color_tree_add(&tree, r, g, b, a, profile->numcolors);
          if(profile->numcolors < 256)
          {
            unsigned char* p = profile->palette;
            unsigned n = profile->numcolors;
            p[n * 4 + 0] = r;
            p[n * 4 + 1] = g;
            p[n * 4 + 2] = b;
            p[n * 4 + 3] = a;
          }
          ++profile->numcolors;
          numcolors_done = profile->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(profile->key && !profile->alpha)
    {
      for(i = 0; i != numpixels; ++i)
      {
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);
        if(a != 0 && r == profile->key_r && g == profile->key_g && b == profile->key_b)
        {
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          profile->alpha = 1;
          profile->key = 0;
          alpha_done = 1;
          if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
        }
      }
    }

    /*make the profile's key always 16-bit for consistency - repeat each byte twice*/
    profile->key_r += (profile->key_r << 8);
    profile->key_g += (profile->key_g << 8);
    profile->key_b += (profile->key_b << 8);
  }

  color_tree_cleanup(&tree);
  return error;
}

/*Automatically chooses color type that gives smallest amount of bits in the
output image, e.g. grey if there are only greyscale pixels, palette if there
are less than 256 colors, ...
Updates values of mode with a potentially smaller color model. mode_out should
contain the user chosen color model, but will be overwritten with the new chosen one.*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
                                   const unsigned char* image, unsigned w, unsigned h,
                                   const LodePNGColorMode* mode_in)
{
  LodePNGColorProfile prof;
  unsigned error = 0;
  unsigned palettebits, palette_ok;
  size_t i, n;
  size_t numpixels = (size_t)w * (size_t)h;

  lodepng_color_profile_init(&prof);
  error = lodepng_get_color_profile(&prof, image, w, h, mode_in);
  if(error) return error;
  mode_out->key_defined = 0;

  if(prof.key && numpixels <= 16)
  {
    prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    prof.key = 0;
    if(prof.bits < 8) prof.bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  }
  n = prof.numcolors;
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
  palette_ok = n <= 256 && prof.bits <= 8;
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
  if(!prof.colored && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/

  if(palette_ok)
  {
    unsigned char* p = prof.palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != prof.numcolors; ++i)
    {
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    }

    mode_out->colortype = LCT_PALETTE;
    mode_out->bitdepth = palettebits;

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
        && mode_in->bitdepth == mode_out->bitdepth)
    {
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
      lodepng_color_mode_copy(mode_out, mode_in);
    }
  }
  else /*8-bit or 16-bit per channel*/
  {
    mode_out->bitdepth = prof.bits;
    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)
                                     : (prof.colored ? LCT_RGB : LCT_GREY);

    if(prof.key)
    {
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/
      mode_out->key_r = prof.key_r & mask;
      mode_out->key_g = prof.key_g & mask;
      mode_out->key_b = prof.key_b & mask;
      mode_out->key_defined = 1;
    }
  }

  return error;
}

#endif /* #ifdef LODEPNG_COMPILE_ENCODER */

/*
Paeth predicter, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c)
{
  short pa = abs(b - c);
  short pb = abs(a - c);
  short pc = abs(a + b - c - c);

  if(pc < pa && pc < pb) return (unsigned char)c;
  else if(pb < pa) return (unsigned char)b;
  else return (unsigned char)a;
}

/*shared values used by multiple Adam7 related functions*/

static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/
static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/

/*
Outputs various dimensions and positions in the image related to the Adam7 reduced images.
passw: output containing the width of the 7 passes
passh: output containing the height of the 7 passes
filter_passstart: output containing the index of the start and end of each
 reduced image with filter bytes
padded_passstart output containing the index of the start and end of each
 reduced image when without filter bytes but with padded scanlines
passstart: output containing the index of the start and end of each reduced
 image without padding between scanlines, but still padding between the images
w, h: width and height of non-interlaced image
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
{
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i)
  {
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i)
  {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
                            + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;
  }
}

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize)
{
  LodePNGInfo* info = &state->info_png;
  if(insize == 0 || in == 0)
  {
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
  }
  if(insize < 33)
  {
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  lodepng_info_cleanup(info);
  lodepng_info_init(info);

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)
  {
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
  }
  if(lodepng_chunk_length(in + 8) != 13)
  {
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR"))
  {
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
  }

  /*read the values given in the header*/
  *w = lodepng_read32bitInt(&in[16]);
  *h = lodepng_read32bitInt(&in[20]);
  info->color.bitdepth = in[24];
  info->color.colortype = (LodePNGColorType)in[25];
  info->compression_method = in[26];
  info->filter_method = in[27];
  info->interlace_method = in[28];

  if(*w == 0 || *h == 0)
  {
    CERROR_RETURN_ERROR(state->error, 93);
  }

  if(!state->decoder.ignore_crc)
  {
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    unsigned checksum = lodepng_crc32(&in[12], 17);
    if(CRC != checksum)
    {
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    }
  }

  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);

  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
  return state->error;
}

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length)
{
  /*
  For PNG filter method 0
  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,
  the filter works byte per byte (bytewidth = 1)
  precon is the previous unfiltered scanline, recon the result, scanline the current one
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType)
  {
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
      break;
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
      break;
    case 2:
      if(precon)
      {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      }
      else
      {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    case 3:
      if(precon)
      {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1);
      }
      else
      {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1);
      }
      break;
    case 4:
      if(precon)
      {
        for(i = 0; i != bytewidth; ++i)
        {
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }
        for(i = bytewidth; i < length; ++i)
        {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      }
      else
      {
        for(i = 0; i != bytewidth; ++i)
        {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i)
        {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    default: return 36; /*error: unexisting filter type given*/
  }
  return 0;
}

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  /*
  For PNG filter method 0
  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)
  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  size_t linebytes = (w * bpp + 7) / 8;

  for(y = 0; y < h; ++y)
  {
    size_t outindex = linebytes * y;
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    unsigned char filterType = in[inindex];

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
}

/*
in: Adam7 interlaced image, with no padding bits between scanlines, but between
 reduced images so that each reduced image starts at a byte.
out: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h
bpp: bits per pixel
out has the following size in bits: w * h * bpp.
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
    for(i = 0; i != 7; ++i)
    {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x)
      {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b)
        {
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
    for(i = 0; i != 7; ++i)
    {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x)
      {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b)
        {
          unsigned char bit = readBitFromReversedStream(&ibp, in);
          /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/
          setBitOfReversedStream0(&obp, out, bit);
        }
      }
    }
  }
}

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h)
{
  /*
  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need
  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers
  for the Adam7 code, the color convert code and the output to the user.
  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y)
  {
    size_t x;
    for(x = 0; x < olinebits; ++x)
    {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png)
{
  /*
  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  if(bpp == 0) return 31; /*error: invalid colortype*/

  if(info_png->interlace_method == 0)
  {
    if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
    {
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
  }
  else /*interlace_method is 1 (Adam7)*/
  {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i)
    {
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8)
      {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
  }

  return 0;
}

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned pos = 0, i;
  if(color->palette) lodepng_free(color->palette);
  color->palettesize = chunkLength / 3;
  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);
  if(!color->palette && color->palettesize)
  {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }
  if(color->palettesize > 256) return 38; /*error: palette too big*/

  for(i = 0; i != color->palettesize; ++i)
  {
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
}

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned i;
  if(color->colortype == LCT_PALETTE)
  {
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 38;

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
  }
  else if(color->colortype == LCT_GREY)
  {
    /*error: this chunk must be 2 bytes for greyscale image*/
    if(chunkLength != 2) return 30;

    color->key_defined = 1;
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
  }
  else if(color->colortype == LCT_RGB)
  {
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;

    color->key_defined = 1;
    color->key_r = 256u * data[0] + data[1];
    color->key_g = 256u * data[2] + data[3];
    color->key_b = 256u * data[4] + data[5];
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/

  return 0; /* OK */
}


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(info->color.colortype == LCT_PALETTE)
  {
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;

    info->background_defined = 1;
    info->background_r = info->background_g = info->background_b = data[0];
  }
  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
    /*error: this chunk must be 2 bytes for greyscale image*/
    if(chunkLength != 2) return 44;

    info->background_defined = 1;
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
    /*error: this chunk must be 6 bytes for greyscale image*/
    if(chunkLength != 6) return 45;

    info->background_defined = 1;
    info->background_r = 256u * data[0] + data[1];
    info->background_g = 256u * data[2] + data[3];
    info->background_b = 256u * data[4] + data[5];
  }

  return 0; /* OK */
}

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  char *key = 0, *str = 0;
  unsigned i;

  while(!error) /*not really a while loop, only used to break on error*/
  {
    unsigned length, string2_begin;

    length = 0;
    while(length < chunkLength && data[length] != 0) ++length;
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i != length; ++i) key[i] = (char)data[i];

    string2_begin = length + 1; /*skip keyword null terminator*/

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    str = (char*)lodepng_malloc(length + 1);
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/

    str[length] = 0;
    for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];

    error = lodepng_add_text(info, key, str);

    break;
  }

  lodepng_free(key);
  lodepng_free(str);

  return error;
}

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
                               const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, string2_begin;
  char *key = 0;
  ucvector decoded;

  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i != length; ++i) key[i] = (char)data[i];

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

    string2_begin = length + 2;
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/

    length = (unsigned)chunkLength - string2_begin;
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&decoded.data, &decoded.size,
                            (unsigned char*)(&data[string2_begin]),
                            length, zlibsettings);
    if(error) break;
    ucvector_push_back(&decoded, 0);

    error = lodepng_add_text(info, key, (char*)decoded.data);

    break;
  }

  lodepng_free(key);
  ucvector_cleanup(&decoded);

  return error;
}

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
                               const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
  ucvector decoded;
  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i != length; ++i) key[i] = (char)data[i];

    /*read the compression method*/
    compressed = data[length + 1];
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    length = 0;
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

    langtag = (char*)lodepng_malloc(length + 1);
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/

    langtag[length] = 0;
    for(i = 0; i != length; ++i) langtag[i] = (char)data[begin + i];

    /*read the transkey*/
    begin += length + 1;
    length = 0;
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

    transkey = (char*)lodepng_malloc(length + 1);
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/

    transkey[length] = 0;
    for(i = 0; i != length; ++i) transkey[i] = (char)data[begin + i];

    /*read the actual text*/
    begin += length + 1;

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;

    if(compressed)
    {
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&decoded.data, &decoded.size,
                              (unsigned char*)(&data[begin]),
                              length, zlibsettings);
      if(error) break;
      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
      ucvector_push_back(&decoded, 0);
    }
    else
    {
      if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);

      decoded.data[length] = 0;
      for(i = 0; i != length; ++i) decoded.data[i] = data[begin + i];
    }

    error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);

    break;
  }

  lodepng_free(key);
  lodepng_free(langtag);
  lodepng_free(transkey);
  ucvector_cleanup(&decoded);

  return error;
}

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/

  info->time_defined = 1;
  info->time.year = 256u * data[0] + data[1];
  info->time.month = data[2];
  info->time.day = data[3];
  info->time.hour = data[4];
  info->time.minute = data[5];
  info->time.second = data[6];

  return 0; /* OK */
}

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/

  info->phys_defined = 1;
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
  info->phys_unit = data[8];

  return 0; /* OK */
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize)
{
  unsigned char IEND = 0;
  const unsigned char* chunk;
  size_t i;
  ucvector idat; /*the data from idat chunks*/
  ucvector scanlines;
  size_t predict;
  size_t outsize = 0;

  /*for unknown chunk order*/
  unsigned unknown = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

  /*provide some proper output values if error will happen*/
  *out = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw))
  {
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
  }

  ucvector_init(&idat);
  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error)
  {
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in)
    {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
      CERROR_BREAK(state->error, 30);
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647)
    {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
      CERROR_BREAK(state->error, 63);
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)
    {
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    }

    data = lodepng_chunk_data_const(chunk);

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT"))
    {
      size_t oldsize = idat.size;
      size_t newsize;
      if(lodepng_addofl(oldsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
      if(!ucvector_resize(&idat, newsize)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
      for(i = 0; i != chunkLength; ++i) idat.data[oldsize + i] = data[i];
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }
    /*IEND chunk*/
    else if(lodepng_chunk_type_equals(chunk, "IEND"))
    {
      IEND = 1;
    }
    /*palette chunk (PLTE)*/
    else if(lodepng_chunk_type_equals(chunk, "PLTE"))
    {
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }
    /*palette transparency chunk (tRNS)*/
    else if(lodepng_chunk_type_equals(chunk, "tRNS"))
    {
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*background color chunk (bKGD)*/
    else if(lodepng_chunk_type_equals(chunk, "bKGD"))
    {
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
    /*text chunk (tEXt)*/
    else if(lodepng_chunk_type_equals(chunk, "tEXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
        if(state->error) break;
      }
    }
    /*compressed text chunk (zTXt)*/
    else if(lodepng_chunk_type_equals(chunk, "zTXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
        if(state->error) break;
      }
    }
    /*international text chunk (iTXt)*/
    else if(lodepng_chunk_type_equals(chunk, "iTXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
        if(state->error) break;
      }
    }
    else if(lodepng_chunk_type_equals(chunk, "tIME"))
    {
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
    else if(lodepng_chunk_type_equals(chunk, "pHYs"))
    {
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    else /*it's not an implemented chunk type, so ignore it: skip over the data*/
    {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk))
      {
        CERROR_BREAK(state->error, 69);
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks)
      {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/
    {
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk);
  }

  ucvector_init(&scanlines);
  /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
  If the decompressed size does not match the prediction, the image must be corrupt.*/
  if(state->info_png.interlace_method == 0)
  {
    predict = lodepng_get_raw_size_idat(*w, *h, &state->info_png.color);
  }
  else
  {
    /*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/
    const LodePNGColorMode* color = &state->info_png.color;
    predict = 0;
    predict += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, color);
    if(*w > 4) predict += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, color);
    predict += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, color);
    if(*w > 2) predict += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, color);
    predict += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, color);
    if(*w > 1) predict += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, color);
    predict += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, color);
  }
  if(!state->error && !ucvector_reserve(&scanlines, predict)) state->error = 83; /*alloc fail*/
  if(!state->error)
  {
    state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,
                                   idat.size, &state->decoder.zlibsettings);
    if(!state->error && scanlines.size != predict) state->error = 91; /*decompressed size doesn't match prediction*/
  }
  ucvector_cleanup(&idat);

  if(!state->error)
  {
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!*out) state->error = 83; /*alloc fail*/
  }
  if(!state->error)
  {
    for(i = 0; i < outsize; i++) (*out)[i] = 0;
    state->error = postProcessScanlines(*out, scanlines.data, *w, *h, &state->info_png);
  }
  ucvector_cleanup(&scanlines);
}

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize)
{
  *out = 0;
  decodeGeneric(out, w, h, state, in, insize);
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))
  {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert)
    {
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
      if(state->error) return state->error;
    }
  }
  else
  {
    /*color conversion needed; sort of copy of the data*/
    unsigned char* data = *out;
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
       && !(state->info_raw.bitdepth == 8))
    {
      return 56; /*unsupported color mode conversion*/
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out))
    {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
}

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  error = lodepng_decode(out, w, h, &state, in, insize);
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
}

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer = 0;
  size_t buffersize;
  unsigned error;
  error = lodepng_load_file(&buffer, &buffersize, filename);
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
}

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)
{
  settings->color_convert = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
  settings->remember_unknown_chunks = 0;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
  settings->ignore_critical = 0;
  settings->ignore_end = 0;
  lodepng_decompress_settings_init(&settings->zlibsettings);
}

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state)
{
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
  lodepng_info_init(&state->info_png);
  state->error = 1;
}

void lodepng_state_cleanup(LodePNGState* state)
{
  lodepng_color_mode_cleanup(&state->info_raw);
  lodepng_info_cleanup(&state->info_png);
}

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)
{
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}

#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*chunkName must be string of 4 characters*/
static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)
{
  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
  out->allocsize = out->size; /*fix the allocsize again*/
  return 0;
}

static void writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  ucvector_push_back(out, 137);
  ucvector_push_back(out, 80);
  ucvector_push_back(out, 78);
  ucvector_push_back(out, 71);
  ucvector_push_back(out, 13);
  ucvector_push_back(out, 10);
  ucvector_push_back(out, 26);
  ucvector_push_back(out, 10);
}

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)
{
  unsigned error = 0;
  ucvector header;
  ucvector_init(&header);

  lodepng_add32bitInt(&header, w); /*width*/
  lodepng_add32bitInt(&header, h); /*height*/
  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/
  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/
  ucvector_push_back(&header, 0); /*compression method*/
  ucvector_push_back(&header, 0); /*filter method*/
  ucvector_push_back(&header, interlace_method); /*interlace method*/

  error = addChunk(out, "IHDR", header.data, header.size);
  ucvector_cleanup(&header);

  return error;
}

static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector PLTE;
  ucvector_init(&PLTE);
  for(i = 0; i != info->palettesize * 4; ++i)
  {
    /*add all channels except alpha channel*/
    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  }
  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
  ucvector_cleanup(&PLTE);

  return error;
}

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector tRNS;
  ucvector_init(&tRNS);
  if(info->colortype == LCT_PALETTE)
  {
    size_t amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i)
    {
      if(info->palette[4 * (i - 1) + 3] == 255) --amount;
      else break;
    }
    /*add only alpha channel*/
    for(i = 0; i != amount; ++i) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);
  }
  else if(info->colortype == LCT_GREY)
  {
    if(info->key_defined)
    {
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));
    }
  }
  else if(info->colortype == LCT_RGB)
  {
    if(info->key_defined)
    {
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r >> 8));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r & 255));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g >> 8));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g & 255));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b >> 8));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b & 255));
    }
  }

  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
  ucvector_cleanup(&tRNS);

  return error;
}

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings)
{
  ucvector zlibdata;
  unsigned error = 0;

  /*compress with the Zlib compressor*/
  ucvector_init(&zlibdata);
  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  ucvector_cleanup(&zlibdata);

  return error;
}

static unsigned addChunk_IEND(ucvector* out)
{
  unsigned error = 0;
  error = addChunk(out, "IEND", 0, 0);
  return error;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)
{
  unsigned error = 0;
  size_t i;
  ucvector text;
  ucvector_init(&text);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&text, 0); /*0 termination char*/
  for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)textstring[i]);
  error = addChunk(out, "tEXt", text.data, text.size);
  ucvector_cleanup(&text);

  return error;
}

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data, compressed;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);
  ucvector_init(&compressed);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*0 termination char*/
  ucvector_push_back(&data, 0); /*compression method: 0*/

  error = zlib_compress(&compressed.data, &compressed.size,
                        (unsigned char*)textstring, textsize, zlibsettings);
  if(!error)
  {
    for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
    error = addChunk(out, "zTXt", data.data, data.size);
  }

  ucvector_cleanup(&compressed);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);

  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*null termination char*/
  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/
  ucvector_push_back(&data, 0); /*compression method*/
  for(i = 0; langtag[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)langtag[i]);
  ucvector_push_back(&data, 0); /*null termination char*/
  for(i = 0; transkey[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)transkey[i]);
  ucvector_push_back(&data, 0); /*null termination char*/

  if(compressed)
  {
    ucvector compressed_data;
    ucvector_init(&compressed_data);
    error = zlib_compress(&compressed_data.data, &compressed_data.size,
                          (unsigned char*)textstring, textsize, zlibsettings);
    if(!error)
    {
      for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);
    }
    ucvector_cleanup(&compressed_data);
  }
  else /*not compressed*/
  {
    for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)textstring[i]);
  }

  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector bKGD;
  ucvector_init(&bKGD);
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r >> 8));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255));
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r >> 8));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_g >> 8));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_g & 255));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_b >> 8));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_b & 255));
  }
  else if(info->color.colortype == LCT_PALETTE)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r & 255)); /*palette index*/
  }

  error = addChunk(out, "bKGD", bKGD.data, bKGD.size);
  ucvector_cleanup(&bKGD);

  return error;
}

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)
{
  unsigned error = 0;
  unsigned char* data = (unsigned char*)lodepng_malloc(7);
  if(!data) return 83; /*alloc fail*/
  data[0] = (unsigned char)(time->year >> 8);
  data[1] = (unsigned char)(time->year & 255);
  data[2] = (unsigned char)time->month;
  data[3] = (unsigned char)time->day;
  data[4] = (unsigned char)time->hour;
  data[5] = (unsigned char)time->minute;
  data[6] = (unsigned char)time->second;
  error = addChunk(out, "tIME", data, 7);
  lodepng_free(data);
  return error;
}

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector data;
  ucvector_init(&data);

  lodepng_add32bitInt(&data, info->phys_x);
  lodepng_add32bitInt(&data, info->phys_y);
  ucvector_push_back(&data, info->phys_unit);

  error = addChunk(out, "pHYs", data.data, data.size);
  ucvector_cleanup(&data);

  return error;
}

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType)
{
  size_t i;
  switch(filterType)
  {
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
      break;
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
      break;
    case 2: /*Up*/
      if(prevline)
      {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      }
      else
      {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
    case 3: /*Average*/
      if(prevline)
      {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      }
      else
      {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
    case 4: /*Paeth*/
      if(prevline)
      {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i)
        {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      }
      else
      {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
    default: return; /*unexisting filter type given*/
  }
}

/* log2 approximation. A slight bit faster than std::log. */
static float flog2(float f)
{
  float result = 0;
  while(f > 32) { result += 4; f /= 16; }
  while(f > 2) { ++result; f /= 2; }
  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);
}

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)
{
  /*
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(info);
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = (w * bpp + 7) / 8;
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  const unsigned char* prevline = 0;
  unsigned x, y;
  unsigned error = 0;
  LodePNGFilterStrategy strategy = settings->filter_strategy;

  /*
  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:
   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.
      use fixed filtering, with the filter None).
   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is
     not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply
     all five filters and select the filter that produces the smallest sum of absolute values per row.
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.

  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
     (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy == LFS_ZERO)
  {
    for(y = 0; y != h; ++y)
    {
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
      size_t inindex = linebytes * y;
      out[outindex] = 0; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);
      prevline = &in[inindex];
    }
  }
  else if(strategy == LFS_MINSUM)
  {
    /*adaptive filtering*/
    size_t sum[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type)
    {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) return 83; /*alloc fail*/
    }

    if(!error)
    {
      for(y = 0; y != h; ++y)
      {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type)
        {
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);

          /*calculate the sum of the result*/
          sum[type] = 0;
          if(type == 0)
          {
            for(x = 0; x != linebytes; ++x) sum[type] += (unsigned char)(attempt[type][x]);
          }
          else
          {
            for(x = 0; x != linebytes; ++x)
            {
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
              sum[type] += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum[type] < smallest)
          {
            bestType = type;
            smallest = sum[type];
          }
        }

        prevline = &in[y * linebytes];

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  }
  else if(strategy == LFS_ENTROPY)
  {
    float sum[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    float smallest = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type)
    {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) return 83; /*alloc fail*/
    }

    for(y = 0; y != h; ++y)
    {
      /*try the 5 filter types*/
      for(type = 0; type != 5; ++type)
      {
        filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
        for(x = 0; x != 256; ++x) count[x] = 0;
        for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
        ++count[type]; /*the filter type itself is part of the scanline*/
        sum[type] = 0;
        for(x = 0; x != 256; ++x)
        {
          float p = count[x] / (float)(linebytes + 1);
          sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;
        }
        /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
        if(type == 0 || sum[type] < smallest)
        {
          bestType = type;
          smallest = sum[type];
        }
      }

      prevline = &in[y * linebytes];

      /*now fill the out values*/
      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
      for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  }
  else if(strategy == LFS_PREDEFINED)
  {
    for(y = 0; y != h; ++y)
    {
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
      size_t inindex = linebytes * y;
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  }
  else if(strategy == LFS_BRUTE_FORCE)
  {
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned type = 0, bestType = 0;
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings = settings->zlibsettings;
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type)
    {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) return 83; /*alloc fail*/
    }
    for(y = 0; y != h; ++y) /*try the 5 filter types*/
    {
      for(type = 0; type != 5; ++type)
      {
        unsigned testsize = (unsigned)linebytes;
        /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

        filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
        size[type] = 0;
        dummy = 0;
        zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
        lodepng_free(dummy);
        /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
        if(type == 0 || size[type] < smallest)
        {
          bestType = type;
          smallest = size[type];
        }
      }
      prevline = &in[y * linebytes];
      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
      for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  }
  else return 88; /* unknown filter strategy */

  return error;
}

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h)
{
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y)
  {
    size_t x;
    for(x = 0; x < ilinebits; ++x)
    {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}

/*
in: non-interlaced image with size w*h
out: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with
 no padding bits between scanlines, but between reduced images so that each
 reduced image starts at a byte.
bpp: bits per pixel
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
    for(i = 0; i != 7; ++i)
    {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x)
      {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b)
        {
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
    for(i = 0; i != 7; ++i)
    {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x)
      {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b)
        {
          unsigned char bit = readBitFromReversedStream(&ibp, in);
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)
{
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  unsigned error = 0;

  if(info_png->interlace_method == 0)
  {
    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error)
    {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
      {
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));
        if(!padded) error = 83; /*alloc fail*/
        if(!error)
        {
          addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      }
      else
      {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
      }
    }
  }
  else /*interlace_method is 1 (Adam7)*/
  {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out)) error = 83; /*alloc fail*/

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/

    if(!error)
    {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i)
      {
        if(bpp < 8)
        {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
                         ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
        }
        else
        {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
      }
    }

    lodepng_free(adam7);
  }

  return error;
}

/*
palette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...
returns 0 if the palette is opaque,
returns 1 if the palette has a single color with alpha 0 ==> color key
returns 2 if the palette is semi-translucent.
*/
static unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)
{
  size_t i;
  unsigned key = 0;
  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/
  for(i = 0; i != palettesize; ++i)
  {
    if(!key && palette[4 * i + 3] == 0)
    {
      r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];
      key = 1;
      i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/
    }
    else if(palette[4 * i + 3] != 255) return 2;
    /*when key, no opaque RGB may have key's RGB*/
    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  }
  return key;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)
{
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize)
  {
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk);
  }
  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state)
{
  LodePNGInfo info;
  ucvector outv;
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
  size_t datasize = 0;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;
  state->error = 0;

  /*check input values validity*/
  if((state->info_png.color.colortype == LCT_PALETTE || state->encoder.force_palette)
      && (state->info_png.color.palettesize == 0 || state->info_png.color.palettesize > 256))
  {
    CERROR_RETURN_ERROR(state->error, 68); /*invalid palette size, it is only allowed to be 1-256*/
  }
  if(state->encoder.zlibsettings.btype > 2)
  {
    CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/
  }
  if(state->info_png.interlace_method > 1)
  {
    CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/
  }
  state->error = checkColorValidity(state->info_png.color.colortype, state->info_png.color.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/

  /* color convert and compute scanline filter types */
  lodepng_info_init(&info);
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert)
  {
    state->error = lodepng_auto_choose_color(&info.color, image, w, h, &state->info_raw);
  }
  if (!state->error)
  {
    if(!lodepng_color_mode_equal(&state->info_raw, &info.color))
    {
      unsigned char* converted;
      size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7) / 8;

      converted = (unsigned char*)lodepng_malloc(size);
      if(!converted && size) state->error = 83; /*alloc fail*/
      if(!state->error)
      {
        state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
      }
      if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
      lodepng_free(converted);
    }
    else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
  }

  /* output all PNG chunks */
  ucvector_init(&outv);
  while(!state->error) /*while only executed once, to break on error*/
  {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    writeSignature(&outv);
    /*IHDR*/
    addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE)
    {
      addChunk_PLTE(&outv, &info.color);
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))
    {
      addChunk_PLTE(&outv, &info.color);
    }
    /*tRNS*/
    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)
    {
      addChunk_tRNS(&outv, &info.color);
    }
    if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)
    {
      addChunk_tRNS(&outv, &info.color);
    }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) addChunk_bKGD(&outv, &info);
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) addChunk_pHYs(&outv, &info);

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) addChunk_tIME(&outv, &info.time);
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i)
    {
      if(strlen(info.text_keys[i]) > 79)
      {
        state->error = 66; /*text chunk too large*/
        break;
      }
      if(strlen(info.text_keys[i]) < 1)
      {
        state->error = 67; /*text chunk too small*/
        break;
      }
      if(state->encoder.text_compression)
      {
        addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
      }
      else
      {
        addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id)
    {
      unsigned alread_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i)
      {
        if(!strcmp(info.text_keys[i], "LodePNG"))
        {
          alread_added_id_text = 1;
          break;
        }
      }
      if(alread_added_id_text == 0)
      {
        addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i)
    {
      if(strlen(info.itext_keys[i]) > 79)
      {
        state->error = 66; /*text chunk too large*/
        break;
      }
      if(strlen(info.itext_keys[i]) < 1)
      {
        state->error = 67; /*text chunk too small*/
        break;
      }
      addChunk_iTXt(&outv, state->encoder.text_compression,
                    info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
                    &state->encoder.zlibsettings);
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    addChunk_IEND(&outv);

    break; /*this isn't really a while loop; no error happened so break out now!*/
  }

  lodepng_info_cleanup(&info);
  lodepng_free(data);
  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
  *outsize = outv.size;

  return state->error;
}

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  state.info_png.color.colortype = colortype;
  state.info_png.color.bitdepth = bitdepth;
  lodepng_encode(out, outsize, image, w, h, &state);
  error = state.error;
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)
{
  lodepng_compress_settings_init(&settings->zlibsettings);
  settings->filter_palette_zero = 1;
  settings->filter_strategy = LFS_MINSUM;
  settings->auto_convert = 1;
  settings->force_palette = 0;
  settings->predefined_filters = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
  settings->text_compression = 1;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code)
{
  switch(code)
  {
    case 0: return "no error, everything went ok";
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
    case 13: return "problem while processing dynamic deflate block";
    case 14: return "problem while processing dynamic deflate block";
    case 15: return "problem while processing dynamic deflate block";
    case 16: return "unexisting code while processing dynamic deflate block";
    case 17: return "end of out buffer memory reached while inflating";
    case 18: return "invalid distance code while inflating";
    case 19: return "end of out buffer memory reached while inflating";
    case 20: return "invalid deflate block BTYPE encountered while decoding";
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
     /*end of out buffer memory reached while inflating:
     This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
     all the pixels of the image, given the color depth and image dimensions. Something that doesn't
     happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
    case 23: return "end of in buffer memory reached while inflating";
    case 24: return "invalid FCHECK in zlib header";
    case 25: return "invalid compression method in zlib header";
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
    case 27: return "PNG file is smaller than a PNG header";
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
    case 29: return "first chunk is not the header chunk";
    case 30: return "chunk length too large, chunk broken off at end of file";
    case 31: return "illegal PNG color type or bpp";
    case 32: return "illegal PNG compression method";
    case 33: return "illegal PNG filter method";
    case 34: return "illegal PNG interlace method";
    case 35: return "chunk length of a chunk is too large or the chunk too small";
    case 36: return "illegal PNG filter type encountered";
    case 37: return "illegal bit depth for this color type given";
    case 38: return "the palette is too big"; /*more than 256 colors*/
    case 39: return "more palette alpha values given in tRNS chunk than there are colors in the palette";
    case 40: return "tRNS chunk has wrong size for greyscale image";
    case 41: return "tRNS chunk has wrong size for RGB image";
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
    case 43: return "bKGD chunk has wrong size for palette image";
    case 44: return "bKGD chunk has wrong size for greyscale image";
    case 45: return "bKGD chunk has wrong size for RGB image";
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
    case 49: return "jumped past memory while generating dynamic huffman tree";
    case 50: return "jumped past memory while generating dynamic huffman tree";
    case 51: return "jumped past memory while inflating huffman block";
    case 52: return "jumped past memory while inflating";
    case 53: return "size of zlib data too small";
    case 54: return "repeat symbol in tree while there was no value symbol yet";
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
    case 59: return "requested color conversion not supported";
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
    /*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/
    case 62: return "conversion from color to greyscale not supported";
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk"; /*(2^31-1)*/
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
    case 71: return "unexisting interlace mode given to encoder (must be 0 or 1)";
    case 72: return "while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)";
    case 73: return "invalid tIME chunk size";
    case 74: return "invalid pHYs chunk size";
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
    case 76: return "iTXt chunk too short to contain required bytes";
    case 77: return "integer overflow in buffer size";
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
    case 79: return "failed to open file for writing";
    case 80: return "tried creating a tree of 0 symbols";
    case 81: return "lazy matching at pos 0 is impossible";
    case 82: return "color conversion to palette requested while a color isn't in palette";
    case 83: return "memory allocation failed";
    case 84: return "given image too small to contain all pixels to be encoded";
    case 86: return "impossible offset in lz77 encoding (internal bug)";
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
    case 89: return "text chunk keyword too short or long: must have size 1-79";
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
    case 91: return "invalid decompressed idat size";
    case 92: return "integer overflow due to too many pixels";
    case 93: return "zero width or height is invalid";
    case 94: return "header chunk must have a size of 13 bytes";
    case 95: return "integer overflow with combined idat chunk size";
  }
  return "unknown error code";
}
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // C++ Wrapper                                                          // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{

#ifdef LODEPNG_COMPILE_DISK
unsigned load_file(std::vector<unsigned char>& buffer, const std::string& filename)
{
  long size = lodepng_filesize(filename.c_str());
  if(size < 0) return 78;
  buffer.resize((size_t)size);
  return size == 0 ? 0 : lodepng_buffer_file(&buffer[0], (size_t)size, filename.c_str());
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned save_file(const std::vector<unsigned char>& buffer, const std::string& filename)
{
  return lodepng_save_file(buffer.empty() ? 0 : &buffer[0], buffer.size(), filename.c_str());
}
#endif /* LODEPNG_COMPILE_DISK */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
                    const LodePNGDecompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_decompress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
    lodepng_free(buffer);
  }
  return error;
}

unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
                    const LodePNGDecompressSettings& settings)
{
  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif /* LODEPNG_COMPILE_DECODER */

#ifdef LODEPNG_COMPILE_ENCODER
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
                  const LodePNGCompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
    lodepng_free(buffer);
  }
  return error;
}

unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
                  const LodePNGCompressSettings& settings)
{
  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif /* LODEPNG_COMPILE_ENCODER */
#endif /* LODEPNG_COMPILE_ZLIB */


#ifdef LODEPNG_COMPILE_PNG

State::State()
{
  lodepng_state_init(this);
}

State::State(const State& other)
{
  lodepng_state_init(this);
  lodepng_state_copy(this, &other);
}

State::~State()
{
  lodepng_state_cleanup(this);
}

State& State::operator=(const State& other)
{
  lodepng_state_copy(this, &other);
  return *this;
}

#ifdef LODEPNG_COMPILE_DECODER

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,
                size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);
  if(buffer && !error)
  {
    State state;
    state.info_raw.colortype = colortype;
    state.info_raw.bitdepth = bitdepth;
    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
    lodepng_free(buffer);
  }
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth)
{
  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                State& state,
                const unsigned char* in, size_t insize)
{
  unsigned char* buffer = NULL;
  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);
  if(buffer && !error)
  {
    size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
  }
  lodepng_free(buffer);
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
                State& state,
                const std::vector<unsigned char>& in)
{
  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());
}

#ifdef LODEPNG_COMPILE_DISK
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,
                LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  unsigned error = load_file(buffer, filename);
  if(error) return error;
  return decode(out, w, h, buffer, colortype, bitdepth);
}
#endif /* LODEPNG_COMPILE_DECODER */
#endif /* LODEPNG_COMPILE_DISK */

#ifdef LODEPNG_COMPILE_ENCODER
unsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,
                LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);
  if(buffer)
  {
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
    lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}

unsigned encode(std::vector<unsigned char>& out,
                const unsigned char* in, unsigned w, unsigned h,
                State& state)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);
  if(buffer)
  {
    out.insert(out.end(), &buffer[0], &buffer[buffersize]);
    lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                State& state)
{
  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, state);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned encode(const std::string& filename,
                const unsigned char* in, unsigned w, unsigned h,
                LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);
  if(!error) error = save_file(buffer, filename);
  return error;
}

unsigned encode(const std::string& filename,
                const std::vector<unsigned char>& in, unsigned w, unsigned h,
                LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}
#endif /* LODEPNG_COMPILE_DISK */
#endif /* LODEPNG_COMPILE_ENCODER */
#endif /* LODEPNG_COMPILE_PNG */
} /* namespace lodepng */
#endif /*LODEPNG_COMPILE_CPP*/
/* inclusão David Sena */
#define STB_TRUETYPE_IMPLEMENTATION

#define STBTT_RGB_MODE /* alteracao para escrever 3 cores */
#define STBTT_RASTERIZER_VERSION 2




#define STBTT_ifloor(x)   ((int) xm_floor(x))
#define STBTT_iceil(x)    (xm_ceil(x))
#define STBTT_sqrt(x)      xm_sqrt(x)
#define STBTT_pow(x,y)     xm_pow(x,y)
#define STBTT_fmod(x,y)    xm_fmod(x,y)
#define STBTT_cos(x)       xm_cos(x)
#define STBTT_acos(x)      xm_acos(x)
#define STBTT_fabs(x)      xm_fabs(x)


/* stb_truetype.h - v1.19 - public domain */
/* authored from 2009-2016 by Sean Barrett / RAD Game Tools */
/* This library processes TrueType files: */
/* parse files */
/* extract glyph metrics */
/* extract glyph shapes */
/* render glyphs to one-channel bitmaps with antialiasing (box filter) */
/* render glyphs to one-channel SDF bitmaps (signed-distance field/function) */
/* Todo: */
/* non-MS cmaps */
/* crashproof on bad data */
/* hinting? (no longer patented) */
/* cleartype-style AA? */
/* optimize: use simple memory allocator for intermediates */
/* optimize: build edge-list directly from curves */
/* optimize: rasterize directly from curves? */
/* ADDITIONAL CONTRIBUTORS */
/* Mikko Mononen: compound shape support, more cmap formats */
/* Tor Andersson: kerning, subpixel rendering */
/* Dougall Johnson: OpenType / Type 2 font handling */
/* Daniel Ribeiro Maciel: basic GPOS-based kerning */
/* Misc other: */
/* Ryan Gordon */
/* Simon Glass */
/* github:IntellectualKitty */
/* Imanol Celaya */
/* Daniel Ribeiro Maciel */
/* Bug/warning reports/fixes: */
/* "Zer" on mollyrocket       Fabian "ryg" Giesen */
/* Cass Everitt               Martins Mozeiko */
/* stoiko (Haemimont Games)   Cap Petschulat */
/* Brian Hook                 Omar Cornut */
/* Walter van Niftrik         github:aloucks */
/* David Gow                  Peter LaValle */
/* David Given                Sergey Popov */
/* Ivan-Assen Ivanov          Giumo X. Clanjor */
/* Anthony Pesch              Higor Euripedes */
/* Johan Duparc               Thomas Fields */
/* Hou Qiming                 Derek Vinyard */
/* Rob Loach                  Cort Stratton */
/* Kenney Phillis Jr.         github:oyvindjam */
/* Brian Costabile            github:vassvik */
/* VERSION HISTORY */
/* 1.19 (2018-02-11) GPOS kerning, STBTT_fmod */
/* 1.18 (2018-01-29) add missing function */
/* 1.17 (2017-07-23) make more arguments const; doc fix */
/* 1.16 (2017-07-12) SDF support */
/* 1.15 (2017-03-03) make more arguments const */
/* 1.14 (2017-01-16) num-fonts-in-TTC function */
/* 1.13 (2017-01-02) support OpenType fonts, certain Apple fonts */
/* 1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual */
/* 1.11 (2016-04-02) fix unused-variable warning */
/* 1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef */
/* 1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly */
/* 1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges */
/* 1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints; */
/* variant PackFontRanges to pack and render in separate phases; */
/* fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?); */
/* fixed an assert() bug in the new rasterizer */
/* replace assert() with STBTT_assert() in new rasterizer */
/*  */
/* Full history can be found at the end of this file. */
/*  */
/* LICENSE */
/*  */
/* See end of file for license information. */
/*  */
/* USAGE */
/*  */
/* Include this file in whatever places neeed to refer to it. In ONE C/C++ */
/* file, write: */
/* #define STB_TRUETYPE_IMPLEMENTATION */
/* before the #include of this file. This expands out the actual */
/* implementation into that C/C++ file. */
/*  */
/* To make the implementation private to the file that generates the implementation, */
/* #define STBTT_STATIC */
/*  */
/* Simple 3D API (don't ship this, but it's fine for tools and quick start) */
/* stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture */
/* stbtt_GetBakedQuad()                 -- compute quad to draw for a given char */
/*  */
/* Improved 3D API (more shippable): */
/* #include "stb_rect_pack.h"           -- optional, but you really want it */
/* stbtt_PackBegin() */
/* stbtt_PackSetOversampling()          -- for improved quality on small fonts */
/* stbtt_PackFontRanges()               -- pack and renders */
/* stbtt_PackEnd() */
/* stbtt_GetPackedQuad() */
/*  */
/* "Load" a font file from a memory buffer (you have to keep the buffer loaded) */
/* stbtt_InitFont() */
/* stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections */
/* stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections */
/*  */
/* Render a unicode codepoint to a bitmap */
/* stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap */
/* stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide */
/* stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be */
/*  */
/* Character advance/positioning */
/* stbtt_GetCodepointHMetrics() */
/* stbtt_GetFontVMetrics() */
/* stbtt_GetFontVMetricsOS2() */
/* stbtt_GetCodepointKernAdvance() */
/*  */
/* Starting with version 1.06, the rasterizer was replaced with a new, */
/* faster and generally-more-precise rasterizer. The new rasterizer more */
/* accurately measures pixel coverage for anti-aliasing, except in the case */
/* where multiple shapes overlap, in which case it overestimates the AA pixel */
/* coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If */
/* this turns out to be a problem, you can re-enable the old rasterizer with */
/* #define STBTT_RASTERIZER_VERSION 1 */
/* which will incur about a 15% speed hit. */
/*  */
/* ADDITIONAL DOCUMENTATION */
/*  */
/* Immediately after this block comment are a series of sample programs. */
/*  */
/* After the sample programs is the "header file" section. This section */
/* includes documentation for each API function. */
/*  */
/* Some important concepts to understand to use this library: */
/*  */
/* Codepoint */
/* Characters are defined by unicode codepoints, e.g. 65 is */
/* uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is */
/* the hiragana for "ma". */
/*  */
/* Glyph */
/* A visual character shape (every codepoint is rendered as */
/* some glyph) */
/*  */
/* Glyph index */
/* A font-specific integer ID representing a glyph */
/*  */
/* Baseline */
/* Glyph shapes are defined relative to a baseline, which is the */
/* bottom of uppercase characters. Characters extend both above */
/* and below the baseline. */
/*  */
/* Current Point */
/* As you draw text to the screen, you keep track of a "current point" */
/* which is the origin of each character. The current point's vertical */
/* position is the baseline. Even "baked fonts" use this model. */
/*  */
/* Vertical Font Metrics */
/* The vertical qualities of the font, used to vertically position */
/* and space the characters. See docs for stbtt_GetFontVMetrics. */
/*  */
/* Font Size in Pixels or Points */
/* The preferred interface for specifying font sizes in stb_truetype */
/* is to specify how tall the font's vertical extent should be in pixels. */
/* If that sounds good enough, skip the next paragraph. */
/*  */
/* Most font APIs instead use "points", which are a common typographic */
/* measurement for describing font size, defined as 72 points per inch. */
/* stb_truetype provides a point API for compatibility. However, true */
/* "per inch" conventions don't make much sense on computer displays */
/* since different monitors have different number of pixels per */
/* inch. For example, Windows traditionally uses a convention that */
/* there are 96 pixels per inch, thus making 'inch' measurements have */
/* nothing to do with inches, and thus effectively defining a point to */
/* be 1.333 pixels. Additionally, the TrueType font data provides */
/* an explicit scale factor to scale a given font's glyphs to points, */
/* but the author has observed that this scale factor is often wrong */
/* for non-commercial fonts, thus making fonts scaled in points */
/* according to the TrueType spec incoherently sized in practice. */
/*  */
/* DETAILED USAGE: */
/*  */
/* Scale: */
/* Select how high you want the font to be, in points or pixels. */
/* Call ScaleForPixelHeight or ScaleForMappingEmToPixels to compute */
/* a scale factor SF that will be used by all other functions. */
/*  */
/* Baseline: */
/* You need to select a y-coordinate that is the baseline of where */
/* your text will appear. Call GetFontBoundingBox to get the baseline-relative */
/* bounding box for all characters. SF*-y0 will be the distance in pixels */
/* that the worst-case character could extend above the baseline, so if */
/* you want the top edge of characters to appear at the top of the */
/* screen where y=0, then you would set the baseline to SF*-y0. */
/*  */
/* Current point: */
/* Set the current point where the first character will appear. The */
/* first character could extend left of the current point; this is font */
/* dependent. You can either choose a current point that is the leftmost */
/* point and hope, or add some padding, or check the bounding box or */
/* left-side-bearing of the first character to be displayed and set */
/* the current point based on that. */
/*  */
/* Displaying a character: */
/* Compute the bounding box of the character. It will contain signed values */
/* relative to <current_point, baseline>. I.e. if it returns x0,y0,x1,y1, */
/* then the character should be displayed in the rectangle from */
/* <current_point+SF*x0, baseline+SF*y0> to <current_point+SF*x1,baseline+SF*y1). */
/*  */
/* Advancing for the next character: */
/* Call GlyphHMetrics, and compute 'current_point += SF * advance'. */
/*  */
/*  */
/* ADVANCED USAGE */
/*  */
/* Quality: */
/*  */
/* - Use the functions with Subpixel at the end to allow your characters */
/* to have subpixel positioning. Since the font is anti-aliased, not */
/* hinted, this is very import for quality. (This is not possible with */
/* baked fonts.) */
/*  */
/* - Kerning is now supported, and if you're supporting subpixel rendering */
/* then kerning is worth using to give your text a polished look. */
/*  */
/* Performance: */
/*  */
/* - Convert Unicode codepoints to glyph indexes and operate on the glyphs; */
/* if you don't do this, stb_truetype is forced to do the conversion on */
/* every call. */
/*  */
/* - There are a lot of memory allocations. We should modify it to take */
/* a temp buffer and allocate from the temp buffer (without freeing), */
/* should help performance a lot. */
/*  */
/* NOTES */
/*  */
/* The system uses the raw data found in the .ttf file without changing it */
/* and without building auxiliary data structures. This is a bit inefficient */
/* on little-endian systems (the data is big-endian), but assuming you're */
/* caching the bitmaps or glyph shapes this shouldn't be a big deal. */
/*  */
/* It appears to be very hard to programmatically determine what font a */
/* given file is in a general way. I provide an API for this, but I don't */
/* recommend it. */
/*  */
/*  */
/* SOURCE STATISTICS (based on v0.6c, 2050 LOC) */
/*  */
/* Documentation & header file        520 LOC  \___ 660 LOC documentation */
/* Sample code                        140 LOC  / */
/* Truetype parsing                   620 LOC  ---- 620 LOC TrueType */
/* Software rasterization             240 LOC  \                           . */
/* Curve tesselation                  120 LOC   \__ 550 LOC Bitmap creation */
/* Bitmap management                  100 LOC   / */
/* Baked bitmap interface              70 LOC  / */
/* Font name matching & access        150 LOC  ---- 150 */
/* C runtime library abstraction       60 LOC  ----  60 */
/*  */
/*  */
/* PERFORMANCE MEASUREMENTS FOR 1.06: */
/*  */
/* 32-bit     64-bit */
/* Previous release:  8.83 s     7.68 s */
/* Pool allocations:  7.72 s     6.34 s */
/* Inline sort     :  6.54 s     5.65 s */
/* New rasterizer  :  5.63 s     5.00 s */

/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* // */
/* //  SAMPLE PROGRAMS */
/* // */
/*  */
/* Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless */
/*  */
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  /* force following include to generate implementation */
#include "stb_truetype.h"

unsigned char ttf_buffer[1<<20];
unsigned char temp_bitmap[512*512];

stbtt_bakedchar cdata[96]; /* ASCII 32..126 is 95 glyphs */
GLuint ftex;

void my_stbtt_initfont(void)
{
   fread(ttf_buffer, 1, 1<<20, fopen("c:/windows/fonts/times.ttf", "rb"));
   stbtt_BakeFontBitmap(ttf_buffer,0, 32.0, temp_bitmap,512,512, 32,96, cdata); /* no guarantee this fits! */
   /* can free ttf_buffer at this point */
   glGenTextures(1, &ftex);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512,512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
   /* can free temp_bitmap at this point */
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char *text)
{
   /* assume orthographic projection with units = screen pixels, origin at top left */
   glEnable(GL_TEXTURE_2D);
   glBindTexture(GL_TEXTURE_2D, ftex);
   glBegin(GL_QUADS);
   while (*text) {
      if (*text >= 32 && *text < 128) {
         stbtt_aligned_quad q;
         stbtt_GetBakedQuad(cdata, 512,512, *text-32, &x,&y,&q,1);/* 1=opengl & d3d10+,0=d3d9 */
         glTexCoord2f(q.s0,q.t1); glVertex2f(q.x0,q.y0);
         glTexCoord2f(q.s1,q.t1); glVertex2f(q.x1,q.y0);
         glTexCoord2f(q.s1,q.t0); glVertex2f(q.x1,q.y1);
         glTexCoord2f(q.s0,q.t0); glVertex2f(q.x0,q.y1);
      }
      ++text;
   }
   glEnd();
}
#endif
/*  */
/*  */
/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* Complete program (this compiles): get a single bitmap, print as ASCII art */
/*  */
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  /* force following include to generate implementation */
#include "stb_truetype.h"

char ttf_buffer[1<<25];

int main(int argc, char **argv)
{
   stbtt_fontinfo font;
   unsigned char *bitmap;
   int w,h,i,j,c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

   fread(ttf_buffer, 1, 1<<25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

   stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer,0));
   bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0,0);

   for (j=0; j < h; ++j) {
      for (i=0; i < w; ++i)
         putchar(" .:ioVM@"[bitmap[j*w+i]>>5]);
      putchar('\n');
   }
   return 0;
}
#endif
/*  */
/* Output: */
/*  */
/* .ii. */
/* @@@@@@. */
/* V@Mio@@o */
/* :i.  V@V */
/* :oM@@M */
/* :@@@MM@M */
/* @@o  o@M */
/* :@@.  M@M */
/* @@@o@@@@ */
/* :M@@V:@@. */
/*  */
/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* Complete program: print "Hello World!" banner, with bugs */
/*  */
#if 0
char buffer[24<<20];
unsigned char screen[20][79];

int main(int arg, char **argv)
{
   stbtt_fontinfo font;
   int i,j,ascent,baseline,ch=0;
   float scale, xpos=2; /* leave a little padding in case the character extends left */
   char *text = "Heljo World!"; /* intentionally misspelled to show 'lj' brokenness */

   fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
   stbtt_InitFont(&font, buffer, 0);

   scale = stbtt_ScaleForPixelHeight(&font, 15);
   stbtt_GetFontVMetrics(&font, &ascent,0,0);
   baseline = (int) (ascent*scale);

   while (text[ch]) {
      int advance,lsb,x0,y0,x1,y1;
      float x_shift = xpos - (float) floor(xpos);
      stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
      stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale,scale,x_shift,0, &x0,&y0,&x1,&y1);
      stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int) xpos + x0], x1-x0,y1-y0, 79, scale,scale,x_shift,0, text[ch]);
      /* note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong */
      /* because this API is really for baking character bitmaps into textures. if you want to render */
      /* a sequence of characters, you really need to render each bitmap to a temp buffer, then */
      /* "alpha blend" that into the working buffer */
      xpos += (advance * scale);
      if (text[ch+1])
         xpos += scale*stbtt_GetCodepointKernAdvance(&font, text[ch],text[ch+1]);
      ++ch;
   }

   for (j=0; j < 20; ++j) {
      for (i=0; i < 78; ++i)
         putchar(" .:ioVM@"[screen[j][i]>>5]);
      putchar('\n');
   }

   return 0;
}
#endif


/* //////////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////////// */
/* // */
/* //   INTEGRATION WITH YOUR CODEBASE */
/* // */
/* //   The following sections allow you to supply alternate definitions */
/* //   of C library functions used by stb_truetype, e.g. if you don't */
/* //   link with the C runtime library. */

#ifdef STB_TRUETYPE_IMPLEMENTATION
   /* #define your own (u)stbtt_int8/16/32 before including to override this */
   #ifndef stbtt_uint8
   typedef unsigned char   stbtt_uint8;
   typedef signed   char   stbtt_int8;
   typedef unsigned short  stbtt_uint16;
   typedef signed   short  stbtt_int16;
   typedef unsigned int    stbtt_uint32;
   typedef signed   int    stbtt_int32;
   #endif

   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];
   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];

   /* e.g. #define your own STBTT_ifloor/STBTT_iceil() to avoid math.h */
   #ifndef STBTT_ifloor
   #include <math.h>
   #define STBTT_ifloor(x)   ((int) floor(x))
   #define STBTT_iceil(x)    ((int) ceil(x))
   #endif

   #ifndef STBTT_sqrt
   #include <math.h>
   #define STBTT_sqrt(x)      sqrt(x)
   #define STBTT_pow(x,y)     pow(x,y)
   #endif

   #ifndef STBTT_fmod
   #include <math.h>
   #define STBTT_fmod(x,y)    fmod(x,y)
   #endif

   #ifndef STBTT_cos
   #include <math.h>
   #define STBTT_cos(x)       cos(x)
   #define STBTT_acos(x)      acos(x)
   #endif

   #ifndef STBTT_fabs
   #include <math.h>
   #define STBTT_fabs(x)      fabs(x)
   #endif

   /* #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h */
   #ifndef STBTT_malloc
   #include <stdlib.h>
   #define STBTT_malloc(x,u)  ((void)(u),malloc(x))
   #define STBTT_free(x,u)    ((void)(u),free(x))
   #endif

   #ifndef STBTT_assert
   #include <assert.h>
   #define STBTT_assert(x)    assert(x)
   #endif

   #ifndef STBTT_strlen
   #include <string.h>
   #define STBTT_strlen(x)    strlen(x)
   #endif

   #ifndef STBTT_memcpy
   #include <string.h>
   #define STBTT_memcpy       memcpy
   #define STBTT_memset       memset
   #endif
#endif

/* ///////////////////////////////////////////////////////////////////////////// */
/* ///////////////////////////////////////////////////////////////////////////// */
/* // */
/* //   INTERFACE */
/* // */
/* // */

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* private structure */
typedef struct
{
   unsigned char *data;
   int cursor;
   int size;
} stbtt__buf;

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* TEXTURE BAKING API */
/*  */
/* If you use this API, you only have to call two functions ever. */
/*  */

typedef struct
{
   unsigned short x0,y0,x1,y1; /* coordinates of bbox in bitmap */
   float xoff,yoff,xadvance;
} stbtt_bakedchar;

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  /* font location (use offset=0 for plain .ttf) */
                                float pixel_height,                     /* height of font in pixels */
                                unsigned char *pixels, int pw, int ph,  /* bitmap to be filled in */
                                int first_char, int num_chars,          /* characters to bake */
                                stbtt_bakedchar *chardata);             /* you allocate this, it's num_chars long */
/* if return is positive, the first unused row of the bitmap */
/* if return is negative, returns the negative of the number of characters that fit */
/* if return is 0, no characters fit and no rows were used */
/* This uses a very crappy packing. */

typedef struct
{
   float x0,y0,s0,t0; /* top-left */
   float x1,y1,s1,t1; /* bottom-right */
} stbtt_aligned_quad;

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph,  /* same data as above */
                               int char_index,             /* character to display */
                               float *xpos, float *ypos,   /* pointers to current position in screen pixel space */
                               stbtt_aligned_quad *q,      /* output: quad to draw */
                               int opengl_fillrule);       /* true if opengl fill rule; false if DX9 or earlier */
/* Call GetBakedQuad with char_index = 'character - first_char', and it */
/* creates the quad you need to draw and advances the current position. */
/*  */
/* The coordinate system used assumes y increases downwards. */
/*  */
/* Characters will extend both above and below the current position; */
/* see discussion of "BASELINE" above. */
/*  */
/* It's inefficient; you might want to c&p it and optimize it. */



/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* NEW TEXTURE BAKING API */
/*  */
/* This provides options for packing multiple fonts into one atlas, not */
/* perfectly but better than nothing. */

typedef struct
{
   unsigned short x0,y0,x1,y1; /* coordinates of bbox in bitmap */
   float xoff,yoff,xadvance;
   float xoff2,yoff2;
} stbtt_packedchar;

typedef struct stbtt_pack_context stbtt_pack_context;
typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
typedef struct stbrp_rect stbrp_rect;
#endif

STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);
/* Initializes a packing context stored in the passed-in stbtt_pack_context. */
/* Future calls using this context will pack characters into the bitmap passed */
/* in here: a 1-channel bitmap that is width * height. stride_in_bytes is */
/* the distance from one row to the next (or 0 to mean they are packed tightly */
/* together). "padding" is the amount of padding to leave between each */
/* character (normally you want '1' for bitmaps you'll use as textures with */
/* bilinear filtering). */
/*  */
/* Returns 0 on failure, 1 on success. */

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);
/* Cleans up the packing context and frees all memory. */

#define STBTT_POINT_SIZE(x)   (-(x))

STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
                                int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range);
/* Creates character bitmaps from the font_index'th font found in fontdata (use */
/* font_index=0 if you don't know what that is). It creates num_chars_in_range */
/* bitmaps for characters with unicode values starting at first_unicode_char_in_range */
/* and increasing. Data for how to render them is stored in chardata_for_range; */
/* pass these to stbtt_GetPackedQuad to get back renderable quads. */
/*  */
/* font_size is the full height of the character from ascender to descender, */
/* as computed by stbtt_ScaleForPixelHeight. To use a point size as computed */
/* by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE() */
/* and pass that result as 'font_size': */
/* ...,                  20 , ... // font max minus min y is 20 pixels tall */
/* ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall */

typedef struct
{
   float font_size;
   int first_unicode_codepoint_in_range;  /* if non-zero, then the chars are continuous, and this is the first codepoint */
   int *array_of_unicode_codepoints;       /* if non-zero, then this is an array of unicode codepoints */
   int num_chars;
   stbtt_packedchar *chardata_for_range; /* output */
   unsigned char h_oversample, v_oversample; /* don't set these, they're used internally */
} stbtt_pack_range;

STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);
/* Creates character bitmaps from multiple ranges of characters stored in */
/* ranges. This will usually create a better-packed bitmap than multiple */
/* calls to stbtt_PackFontRange. Note that you can call this multiple */
/* times within a single PackBegin/PackEnd. */

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);
/* Oversampling a font increases the quality by allowing higher-quality subpixel */
/* positioning, and is especially valuable at smaller text sizes. */
/*  */
/* This function sets the amount of oversampling for all following calls to */
/* stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given */
/* pack context. The default (no oversampling) is achieved by h_oversample=1 */
/* and v_oversample=1. The total number of pixels required is */
/* h_oversample*v_oversample larger than the default; for example, 2x2 */
/* oversampling requires 4x the storage of 1x1. For best results, render */
/* oversampled textures with bilinear filtering. Look at the readme in */
/* stb/tests/oversample for information about oversampled fonts */
/*  */
/* To use with PackFontRangesGather etc., you must set it before calls */
/* call to PackFontRangesGatherRects. */

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph,  /* same data as above */
                               int char_index,             /* character to display */
                               float *xpos, float *ypos,   /* pointers to current position in screen pixel space */
                               stbtt_aligned_quad *q,      /* output: quad to draw */
                               int align_to_integer);

STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);
STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);
/* Calling these functions in sequence is roughly equivalent to calling */
/* stbtt_PackFontRanges(). If you more control over the packing of multiple */
/* fonts, or if you want to pack custom data into a font texture, take a look */
/* at the source to of stbtt_PackFontRanges() and create a custom version */
/* using these functions, e.g. call GatherRects multiple times, */
/* building up a single array of rects, then call PackRects once, */
/* then call RenderIntoRects repeatedly. This may result in a */
/* better packing than calling PackFontRanges multiple times */
/* (or it may not). */

/* this is an opaque structure that you shouldn't mess with which holds */
/* all the context needed from PackBegin to PackEnd. */
struct stbtt_pack_context {
   void *user_allocator_context;
   void *pack_info;
   int   width;
   int   height;
   int   stride_in_bytes;
   int   padding;
   unsigned int   h_oversample, v_oversample;
   unsigned char *pixels;
   void  *nodes;
};

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* FONT LOADING */
/*  */
/*  */

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);
/* This function will determine the number of fonts in a font file.  TrueType */
/* collection (.ttc) files may contain multiple fonts, while TrueType font */
/* (.ttf) files only contain one font. The number of fonts can be used for */
/* indexing with the previous function where the index is between zero and one */
/* less than the total fonts. If an error occurs, -1 is returned. */

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);
/* Each .ttf/.ttc file may have more than one font. Each font has a sequential */
/* index number starting from 0. Call this function to get the font offset for */
/* a given index; it returns -1 if the index is out of range. A regular .ttf */
/* file will only define one font and it always be at offset 0, so it will */
/* return '0' for index 0, and -1 for all other indices. */

/* The following structure is defined publically so you can declare one on */
/* the stack or as a global or etc, but you should treat it as opaque. */
struct stbtt_fontinfo
{
   void           * userdata;
   unsigned char  * data;              /* pointer to .ttf file */
   int              fontstart;         /* offset of start of font */

   int numGlyphs;                     /* number of glyphs, needed for range checking */

   int loca,head,glyf,hhea,hmtx,kern,gpos; /* table locations as offset from start of .ttf */
   int index_map;                     /* a cmap mapping for our chosen character encoding */
   int indexToLocFormat;              /* format needed to map from glyph index to glyph */

   stbtt__buf cff;                    /* cff font data */
   stbtt__buf charstrings;            /* the charstring index */
   stbtt__buf gsubrs;                 /* global charstring subroutines index */
   stbtt__buf subrs;                  /* private charstring subroutines index */
   stbtt__buf fontdicts;              /* array of font dicts */
   stbtt__buf fdselect;               /* map from glyph to fontdict */
};

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);
/* Given an offset into the file that defines a font, this function builds */
/* the necessary cached info for the rest of the system. You must allocate */
/* the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't */
/* need to do anything special to free it, because the contents are pure */
/* value data with no additional data structures. Returns 0 on failure. */


/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* CHARACTER TO GLYPH-INDEX CONVERSIOn */

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);
/* If you're going to perform multiple operations on the same character */
/* and you want a speed-up, call this function with the character you're */
/* going to process, then use glyph-based functions instead of the */
/* codepoint-based functions. */


/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* CHARACTER PROPERTIES */
/*  */

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);
/* computes a scale factor to produce a font whose "height" is 'pixels' tall. */
/* Height is measured as the distance from the highest ascender to the lowest */
/* descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics */
/* and computing: */
/* scale = pixels / (ascent - descent) */
/* so if you prefer to measure height by the ascent only, use a similar calculation. */

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);
/* computes a scale factor to produce a font whose EM size is mapped to */
/* 'pixels' tall. This is probably what traditional APIs compute, but */
/* I'm not positive. */

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);
/* ascent is the coordinate above the baseline the font extends; descent */
/* is the coordinate below the baseline the font extends (i.e. it is typically negative) */
/* lineGap is the spacing between one row's descent and the next row's ascent... */
/* so you should advance the vertical position by "*ascent - *descent + *lineGap" */
/* these are expressed in unscaled coordinates, so you must multiply by */
/* the scale factor for a given size */

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap);
/* analogous to GetFontVMetrics, but returns the "typographic" values from the OS/2 */
/* table (specific to MS/Windows TTF files). */
/*  */
/* Returns 1 on success (table present), 0 on failure. */

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);
/* the bounding box around all possible characters */

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);
/* leftSideBearing is the offset from the current horizontal position to the left edge of the character */
/* advanceWidth is the offset from the current horizontal position to the next horizontal position */
/* these are expressed in unscaled coordinates */

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);
/* an additional amount to add to the 'advance' value between ch1 and ch2 */

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);
/* Gets the bounding box of the visible part of the glyph, in unscaled coordinates */

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);
STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);
STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);
/* as above, but takes one or more glyph indices for greater efficiency */


/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* GLYPH SHAPES (you probably don't need these, but they have to go before */
/* the bitmaps for C declaration-order reasons) */
/*  */

#ifndef STBTT_vmove /* you can predefine these to use different values (but why?) */
   enum {
      STBTT_vmove=1,
      STBTT_vline,
      STBTT_vcurve,
      STBTT_vcubic
   };
#endif

#ifndef stbtt_vertex /* you can predefine this to use different values */
                   /* (we share this with other code at RAD) */
   #define stbtt_vertex_type short /* can't use stbtt_int16 because that's not visible in the header file */
   typedef struct
   {
      stbtt_vertex_type x,y,cx,cy,cx1,cy1;
      unsigned char type,padding;
   } stbtt_vertex;
#endif

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);
/* returns non-zero if nothing is drawn for this glyph */

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);
STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);
/* returns # of vertices and fills *vertices with the pointer to them */
/* these are expressed in "unscaled" coordinates */
/*  */
/* The shape is a series of countours. Each one starts with */
/* a STBTT_moveto, then consists of a series of mixed */
/* STBTT_lineto and STBTT_curveto segments. A lineto */
/* draws a line from previous endpoint to its x,y; a curveto */
/* draws a quadratic bezier from previous endpoint to */
/* its x,y, using cx,cy as the bezier control point. */

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);
/* frees the data allocated above */

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* BITMAP RENDERING */
/*  */

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);
/* frees the bitmap allocated below */

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
/* allocates a large-enough single-channel 8bpp bitmap and renders the */
/* specified character/glyph at the specified scale into it, with */
/* antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque). */
/* *width & *height are filled out with the width & height of the bitmap, */
/* which is stored left-to-right, top-to-bottom. */
/*  */
/* xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap */

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);
/* the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel */
/* shift for the character */

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
/* the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap */
/* in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap */
/* is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to get the */
/* width and height and positioning info for it first. */

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
/* same as stbtt_MakeCodepointBitmap, but you can specify a subpixel */
/* shift for the character */

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint);
/* same as stbtt_MakeCodepointBitmapSubpixel, but prefiltering */
/* is performed (see stbtt_PackSetOversampling) */

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
/* get the bbox of the bitmap centered around the glyph origin; so the */
/* bitmap width is ix1-ix0, height is iy1-iy0, and location to place */
/* the bitmap top left is (leftSideBearing*scale,iy0). */
/* (Note that the bitmap uses y-increases-down, but the shape uses */
/* y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.) */

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);
/* same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel */
/* shift for the character */

/* the following functions are equivalent to the above functions, but operate */
/* on glyph indices instead of Unicode codepoints (for efficiency) */
STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int glyph);
STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);
STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);


/* @TODO: don't expose this structure */
typedef struct
{
   int w,h,stride;
   unsigned char *pixels;
} stbtt__bitmap;

/* rasterize a shape with quadratic beziers into a bitmap */
STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        /* 1-channel bitmap to draw into */
                               float flatness_in_pixels,     /* allowable error of curve in pixels */
                               stbtt_vertex *vertices,       /* array of vertices defining shape */
                               int num_verts,                /* number of vertices in above array */
                               float scale_x, float scale_y, /* scale applied to input vertices */
                               float shift_x, float shift_y, /* translation applied to input vertices */
                               int x_off, int y_off,         /* another translation applied to input */
                               int invert,                   /* if non-zero, vertically flip shape */
                               void *userdata);              /* context for to STBTT_MALLOC */

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* Signed Distance Function (or Field) rendering */

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata);
/* frees the SDF bitmap allocated below */

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff);
/* These functions compute a discretized SDF field for a single character, suitable for storing */
/* in a single-channel texture, sampling with bilinear filtering, and testing against */
/* larger than some threshhold to produce scalable fonts. */
/* info              --  the font */
/* scale             --  controls the size of the resulting SDF bitmap, same as it would be creating a regular bitmap */
/* glyph/codepoint   --  the character to generate the SDF for */
/* padding           --  extra "pixels" around the character which are filled with the distance to the character (not 0), */
/* which allows effects like bit outlines */
/* onedge_value      --  value 0-255 to test the SDF against to reconstruct the character (i.e. the isocontour of the character) */
/* pixel_dist_scale  --  what value the SDF should increase by when moving one SDF "pixel" away from the edge (on the 0..255 scale) */
/* if positive, > onedge_value is inside; if negative, < onedge_value is inside */
/* width,height      --  output height & width of the SDF bitmap (including padding) */
/* xoff,yoff         --  output origin of the character */
/* return value      --  a 2D array of bytes 0..255, width*height in size */
/*  */
/* pixel_dist_scale & onedge_value are a scale & bias that allows you to make */
/* optimal use of the limited 0..255 for your application, trading off precision */
/* and special effects. SDF values outside the range 0..255 are clamped to 0..255. */
/*  */
/* Example: */
/* scale = stbtt_ScaleForPixelHeight(22) */
/* padding = 5 */
/* onedge_value = 180 */
/* pixel_dist_scale = 180/5.0 = 36.0 */
/*  */
/* This will create an SDF bitmap in which the character is about 22 pixels */
/* high but the whole bitmap is about 22+5+5=32 pixels high. To produce a filled */
/* shape, sample the SDF at each pixel and fill the pixel if the SDF value */
/* is greater than or equal to 180/255. (You'll actually want to antialias, */
/* which is beyond the scope of this example.) Additionally, you can compute */
/* offset outlines (e.g. to stroke the character border inside & outside, */
/* or only outside). For example, to fill outside the character up to 3 SDF */
/* pixels, you would compare against (180-36.0*3)/255 = 72/255. The above */
/* choice of variables maps a range from 5 pixels outside the shape to */
/* 2 pixels inside the shape to 0..255; this is intended primarily for apply */
/* outside effects only (the interior range is needed to allow proper */
/* antialiasing of the font at *smaller* sizes) */
/*  */
/* The function computes the SDF analytically at each SDF pixel, not by e.g. */
/* building a higher-res bitmap and approximating it. In theory the quality */
/* should be as high as possible for an SDF of this size & representation, but */
/* unclear if this is true in practice (perhaps building a higher-res bitmap */
/* and computing from that can allow drop-out prevention). */
/*  */
/* The algorithm has not been optimized at all, so expect it to be slow */
/* if computing lots of characters or very large sizes. */



/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* Finding the right font... */
/*  */
/* You should really just solve this offline, keep your own tables */
/* of what font is what, and don't try to get it out of the .ttf file. */
/* That's because getting it out of the .ttf file is really hard, because */
/* the names in the file can appear in many possible encodings, in many */
/* possible languages, and e.g. if you need a case-insensitive comparison, */
/* the details of that depend on the encoding & language in a complex way */
/* (actually underspecified in truetype, but also gigantic). */
/*  */
/* But you can use the provided functions in two possible ways: */
/* stbtt_FindMatchingFont() will use *case-sensitive* comparisons on */
/* unicode-encoded names to try to find the font you want; */
/* you can run this before calling stbtt_InitFont() */
/*  */
/* stbtt_GetFontNameString() lets you get any of the various strings */
/* from the file yourself and do your own comparisons on them. */
/* You have to have called stbtt_InitFont() first. */


STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);
/* returns the offset (not index) of the font that matches, or -1 if none */
/* if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold". */
/* if you use any other flag, use a font name like "Arial"; this checks */
/* the 'macStyle' header field; i don't know if fonts set this consistently */
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   /* <= not same as 0, this makes us check the bitfield is 0 */

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);
/* returns 1/0 whether the first string interpreted as utf8 is identical to */
/* the second string interpreted as big-endian utf16... useful for strings from next func */

STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);
/* returns the string (which may be big-endian double byte, e.g. for unicode) */
/* and puts the length in bytes in *length. */
/*  */
/* some of the values for the IDs are below; for more see the truetype spec: */
/* http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html */
/* http://www.microsoft.com/typography/otspec/name.htm */

enum { /* platformID */
   STBTT_PLATFORM_ID_UNICODE   =0,
   STBTT_PLATFORM_ID_MAC       =1,
   STBTT_PLATFORM_ID_ISO       =2,
   STBTT_PLATFORM_ID_MICROSOFT =3
};

enum { /* encodingID for STBTT_PLATFORM_ID_UNICODE */
   STBTT_UNICODE_EID_UNICODE_1_0    =0,
   STBTT_UNICODE_EID_UNICODE_1_1    =1,
   STBTT_UNICODE_EID_ISO_10646      =2,
   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,
   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4
};

enum { /* encodingID for STBTT_PLATFORM_ID_MICROSOFT */
   STBTT_MS_EID_SYMBOL        =0,
   STBTT_MS_EID_UNICODE_BMP   =1,
   STBTT_MS_EID_SHIFTJIS      =2,
   STBTT_MS_EID_UNICODE_FULL  =10
};

enum { /* encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes */
   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,
   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,
   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,
   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7
};

enum { /* languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID... */
       /* problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs */
   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,
   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,
   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,
   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,
   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,
   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D
};

enum { /* languageID for STBTT_PLATFORM_ID_MAC */
   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,
   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,
   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,
   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,
   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,
   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,
   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19
};

#ifdef __cplusplus
}
#endif

#endif /* __STB_INCLUDE_STB_TRUETYPE_H__ */

/* ///////////////////////////////////////////////////////////////////////////// */
/* ///////////////////////////////////////////////////////////////////////////// */
/* // */
/* //   IMPLEMENTATION */
/* // */
/* // */

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

/* //////////////////////////////////////////////////////////////////////// */
/*  */
/* stbtt__buf helpers to parse data from file */
/*  */

static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)
{
   if (b->cursor >= b->size)
      return 0;
   return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf *b, int o)
{
   STBTT_assert(!(o > b->size || o < 0));
   b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf *b, int o)
{
   stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)
{
   stbtt_uint32 v = 0;
   int i;
   STBTT_assert(n >= 1 && n <= 4);
   for (i = 0; i < n; i++)
      v = (v << 8) | stbtt__buf_get8(b);
   return v;
}

static stbtt__buf stbtt__new_buf(const void *p, size_t size)
{
   stbtt__buf r;
   STBTT_assert(size < 0x40000000);
   r.data = (stbtt_uint8*) p;
   r.size = (int) size;
   r.cursor = 0;
   return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)
{
   stbtt__buf r = stbtt__new_buf(NULL, 0);
   if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
   r.data = b->data + o;
   r.size = s;
   return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)
{
   int count, start, offsize;
   start = b->cursor;
   count = stbtt__buf_get16(b);
   if (count) {
      offsize = stbtt__buf_get8(b);
      STBTT_assert(offsize >= 1 && offsize <= 4);
      stbtt__buf_skip(b, offsize * count);
      stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
   }
   return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)
{
   int b0 = stbtt__buf_get8(b);
   if (b0 >= 32 && b0 <= 246)       return b0 - 139;
   else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;
   else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;
   else if (b0 == 28)               return stbtt__buf_get16(b);
   else if (b0 == 29)               return stbtt__buf_get32(b);
   STBTT_assert(0);
   return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf *b) {
   int v, b0 = stbtt__buf_peek8(b);
   STBTT_assert(b0 >= 28);
   if (b0 == 30) {
      stbtt__buf_skip(b, 1);
      while (b->cursor < b->size) {
         v = stbtt__buf_get8(b);
         if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
            break;
      }
   } else {
      stbtt__cff_int(b);
   }
}

static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)
{
   stbtt__buf_seek(b, 0);
   while (b->cursor < b->size) {
      int start = b->cursor, end, op;
      while (stbtt__buf_peek8(b) >= 28)
         stbtt__cff_skip_operand(b);
      end = b->cursor;
      op = stbtt__buf_get8(b);
      if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
      if (op == key) return stbtt__buf_range(b, start, end-start);
   }
   return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
{
   int i;
   stbtt__buf operands = stbtt__dict_get(b, key);
   for (i = 0; i < outcount && operands.cursor < operands.size; i++)
      out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf *b)
{
   stbtt__buf_seek(b, 0);
   return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
   int count, offsize, start, end;
   stbtt__buf_seek(&b, 0);
   count = stbtt__buf_get16(&b);
   offsize = stbtt__buf_get8(&b);
   STBTT_assert(i >= 0 && i < count);
   STBTT_assert(offsize >= 1 && offsize <= 4);
   stbtt__buf_skip(&b, i*offsize);
   start = stbtt__buf_get(&b, offsize);
   end = stbtt__buf_get(&b, offsize);
   return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);
}

/* //////////////////////////////////////////////////////////////////////// */
/*  */
/* accessors to parse data from file */
/*  */

/* on platforms that don't allow misaligned reads, if we want to allow */
/* truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE */

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8 *font)
{
   /* check the version number */
   if (stbtt_tag4(font, '1',0,0,0))  return 1; /* TrueType 1 */
   if (stbtt_tag(font, "typ1"))   return 1; /* TrueType with type 1 font -- we don't support this! */
   if (stbtt_tag(font, "OTTO"))   return 1; /* OpenType with CFF */
   if (stbtt_tag4(font, 0,1,0,0)) return 1; /* OpenType 1.0 */
   if (stbtt_tag(font, "true"))   return 1; /* Apple specification for TrueType fonts */
   return 0;
}

/* @OPTIMIZE: binary search */
static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
{
   stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);
   stbtt_uint32 tabledir = fontstart + 12;
   stbtt_int32 i;
   for (i=0; i < num_tables; ++i) {
      stbtt_uint32 loc = tabledir + 16*i;
      if (stbtt_tag(data+loc+0, tag))
         return ttULONG(data+loc+8);
   }
   return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)
{
   /* if it's just a font, there's only one valid index */
   if (stbtt__isfont(font_collection))
      return index == 0 ? 0 : -1;

   /* check if it's a TTC */
   if (stbtt_tag(font_collection, "ttcf")) {
      /* version 1? */
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         stbtt_int32 n = ttLONG(font_collection+8);
         if (index >= n)
            return -1;
         return ttULONG(font_collection+12+index*4);
      }
   }
   return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)
{
   /* if it's just a font, there's only one valid font */
   if (stbtt__isfont(font_collection))
      return 1;

   /* check if it's a TTC */
   if (stbtt_tag(font_collection, "ttcf")) {
      /* version 1? */
      if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {
         return ttLONG(font_collection+8);
      }
   }
   return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
   stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
   stbtt__buf pdict;
   stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
   if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
   pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
   stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
   if (!subrsoff) return stbtt__new_buf(NULL, 0);
   stbtt__buf_seek(&cff, private_loc[1]+subrsoff);
   return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)
{
   stbtt_uint32 cmap, t;
   stbtt_int32 i,numTables;

   info->data = data;
   info->fontstart = fontstart;
   info->cff = stbtt__new_buf(NULL, 0);

   cmap = stbtt__find_table(data, fontstart, "cmap");       /* required */
   info->loca = stbtt__find_table(data, fontstart, "loca"); /* required */
   info->head = stbtt__find_table(data, fontstart, "head"); /* required */
   info->glyf = stbtt__find_table(data, fontstart, "glyf"); /* required */
   info->hhea = stbtt__find_table(data, fontstart, "hhea"); /* required */
   info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); /* required */
   info->kern = stbtt__find_table(data, fontstart, "kern"); /* not required */
   info->gpos = stbtt__find_table(data, fontstart, "GPOS"); /* not required */

   if (!cmap || !info->head || !info->hhea || !info->hmtx)
      return 0;
   if (info->glyf) {
      /* required for truetype */
      if (!info->loca) return 0;
   } else {
      /* initialization for CFF / Type2 fonts (OTF) */
      stbtt__buf b, topdict, topdictidx;
      stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
      stbtt_uint32 cff;

      cff = stbtt__find_table(data, fontstart, "CFF ");
      if (!cff) return 0;

      info->fontdicts = stbtt__new_buf(NULL, 0);
      info->fdselect = stbtt__new_buf(NULL, 0);

      /* @TODO this should use size from table (not 512MB) */
      info->cff = stbtt__new_buf(data+cff, 512*1024*1024);
      b = info->cff;

      /* read the header */
      stbtt__buf_skip(&b, 2);
      stbtt__buf_seek(&b, stbtt__buf_get8(&b)); /* hdrsize */

      /* @TODO the name INDEX could list multiple fonts, */
      /* but we just use the first one. */
      stbtt__cff_get_index(&b);  /* name INDEX */
      topdictidx = stbtt__cff_get_index(&b);
      topdict = stbtt__cff_index_get(topdictidx, 0);
      stbtt__cff_get_index(&b);  /* string INDEX */
      info->gsubrs = stbtt__cff_get_index(&b);

      stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
      stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
      stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
      stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
      info->subrs = stbtt__get_subrs(b, topdict);

      /* we only support Type 2 charstrings */
      if (cstype != 2) return 0;
      if (charstrings == 0) return 0;

      if (fdarrayoff) {
         /* looks like a CID font */
         if (!fdselectoff) return 0;
         stbtt__buf_seek(&b, fdarrayoff);
         info->fontdicts = stbtt__cff_get_index(&b);
         info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);
      }

      stbtt__buf_seek(&b, charstrings);
      info->charstrings = stbtt__cff_get_index(&b);
   }

   t = stbtt__find_table(data, fontstart, "maxp");
   if (t)
      info->numGlyphs = ttUSHORT(data+t+4);
   else
      info->numGlyphs = 0xffff;

   /* find a cmap encoding table we understand *now* to avoid searching */
   /* later. (todo: could make this installable) */
   /* the same regardless of glyph. */
   numTables = ttUSHORT(data + cmap + 2);
   info->index_map = 0;
   for (i=0; i < numTables; ++i) {
      stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
      /* find an encoding we understand: */
      switch(ttUSHORT(data+encoding_record)) {
         case STBTT_PLATFORM_ID_MICROSOFT:
            switch (ttUSHORT(data+encoding_record+2)) {
               case STBTT_MS_EID_UNICODE_BMP:
               case STBTT_MS_EID_UNICODE_FULL:
                  /* MS/Unicode */
                  info->index_map = cmap + ttULONG(data+encoding_record+4);
                  break;
            }
            break;
        case STBTT_PLATFORM_ID_UNICODE:
            /* Mac/iOS has these */
            /* all the encodingIDs are unicode, so we don't bother to check it */
            info->index_map = cmap + ttULONG(data+encoding_record+4);
            break;
      }
   }
   if (info->index_map == 0)
      return 0;

   info->indexToLocFormat = ttUSHORT(data+info->head + 50);
   return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)
{
   stbtt_uint8 *data = info->data;
   stbtt_uint32 index_map = info->index_map;

   stbtt_uint16 format = ttUSHORT(data + index_map + 0);
   if (format == 0) { /* apple byte encoding */
      stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
      if (unicode_codepoint < bytes-6)
         return ttBYTE(data + index_map + 6 + unicode_codepoint);
      return 0;
   } else if (format == 6) {
      stbtt_uint32 first = ttUSHORT(data + index_map + 6);
      stbtt_uint32 count = ttUSHORT(data + index_map + 8);
      if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)
         return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);
      return 0;
   } else if (format == 2) {
      STBTT_assert(0); /* @TODO: high-byte mapping for japanese/chinese/korean */
      return 0;
   } else if (format == 4) { /* standard mapping for windows fonts: binary search collection of ranges */
      stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;
      stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;
      stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);
      stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

      /* do a binary search of the segments */
      stbtt_uint32 endCount = index_map + 14;
      stbtt_uint32 search = endCount;

      if (unicode_codepoint > 0xffff)
         return 0;

      /* they lie from endCount .. endCount + segCount */
      /* but searchRange is the nearest power of two, so... */
      if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))
         search += rangeShift*2;

      /* now decrement to bias correctly to find smallest */
      search -= 2;
      while (entrySelector) {
         stbtt_uint16 end;
         searchRange >>= 1;
         end = ttUSHORT(data + search + searchRange*2);
         if (unicode_codepoint > end)
            search += searchRange*2;
         --entrySelector;
      }
      search += 2;

      {
         stbtt_uint16 offset, start;
         stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

         STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
         start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);
         if (unicode_codepoint < start)
            return 0;

         offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);
         if (offset == 0)
            return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

         return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);
      }
   } else if (format == 12 || format == 13) {
      stbtt_uint32 ngroups = ttULONG(data+index_map+12);
      stbtt_int32 low,high;
      low = 0; high = (stbtt_int32)ngroups;
      /* Binary search the right group. */
      while (low < high) {
         stbtt_int32 mid = low + ((high-low) >> 1); /* rounds down, so low <= mid < high */
         stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);
         stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);
         if ((stbtt_uint32) unicode_codepoint < start_char)
            high = mid;
         else if ((stbtt_uint32) unicode_codepoint > end_char)
            low = mid+1;
         else {
            stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);
            if (format == 12)
               return start_glyph + unicode_codepoint-start_char;
            else /* format == 13 */
               return start_glyph;
         }
      }
      return 0; /* not found */
   }
   /* @TODO */
   STBTT_assert(0);
   return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
{
   return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
   v->type = type;
   v->x = (stbtt_int16) x;
   v->y = (stbtt_int16) y;
   v->cx = (stbtt_int16) cx;
   v->cy = (stbtt_int16) cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)
{
   int g1,g2;

   STBTT_assert(!info->cff.size);

   if (glyph_index >= info->numGlyphs) return -1; /* glyph index out of range */
   if (info->indexToLocFormat >= 2)    return -1; /* unknown index->glyph map format */

   if (info->indexToLocFormat == 0) {
      g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
      g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
   } else {
      g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);
      g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);
   }

   return g1==g2 ? -1 : g1; /* if length is 0, return -1 */
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   if (info->cff.size) {
      stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
   } else {
      int g = stbtt__GetGlyfOffset(info, glyph_index);
      if (g < 0) return 0;

      if (x0) *x0 = ttSHORT(info->data + g + 2);
      if (y0) *y0 = ttSHORT(info->data + g + 4);
      if (x1) *x1 = ttSHORT(info->data + g + 6);
      if (y1) *y1 = ttSHORT(info->data + g + 8);
   }
   return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
{
   return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info,codepoint), x0,y0,x1,y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt_int16 numberOfContours;
   int g;
   if (info->cff.size)
      return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
   g = stbtt__GetGlyfOffset(info, glyph_index);
   if (g < 0) return 1;
   numberOfContours = ttSHORT(info->data + g);
   return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,
    stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
   if (start_off) {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);
      stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);
   } else {
      if (was_off)
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);
      else
         stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);
   }
   return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   stbtt_int16 numberOfContours;
   stbtt_uint8 *endPtsOfContours;
   stbtt_uint8 *data = info->data;
   stbtt_vertex *vertices=0;
   int num_vertices=0;
   int g = stbtt__GetGlyfOffset(info, glyph_index);

   *pvertices = NULL;

   if (g < 0) return 0;

   numberOfContours = ttSHORT(data + g);

   if (numberOfContours > 0) {
      stbtt_uint8 flags=0,flagcount;
      stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;
      stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
      stbtt_uint8 *points;
      endPtsOfContours = (data + g + 10);
      ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
      points = data + g + 10 + numberOfContours * 2 + 2 + ins;

      n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

      m = n + 2*numberOfContours;  /* a loose bound on how many vertices we might need */
      vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
      if (vertices == 0)
         return 0;

      next_move = 0;
      flagcount=0;

      /* in first pass, we load uninterpreted data into the allocated array */
      /* above, shifted to the end of the array so we won't overwrite it when */
      /* we create our final data starting from the front */

      off = m - n; /* starting offset for uninterpreted data, regardless of how m ends up being calculated */

      /* first load flags */

      for (i=0; i < n; ++i) {
         if (flagcount == 0) {
            flags = *points++;
            if (flags & 8)
               flagcount = *points++;
         } else
            --flagcount;
         vertices[off+i].type = flags;
      }

      /* now load x coordinates */
      x=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 2) {
            stbtt_int16 dx = *points++;
            x += (flags & 16) ? dx : -dx; /* ??? */
         } else {
            if (!(flags & 16)) {
               x = x + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].x = (stbtt_int16) x;
      }

      /* now load y coordinates */
      y=0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         if (flags & 4) {
            stbtt_int16 dy = *points++;
            y += (flags & 32) ? dy : -dy; /* ??? */
         } else {
            if (!(flags & 32)) {
               y = y + (stbtt_int16) (points[0]*256 + points[1]);
               points += 2;
            }
         }
         vertices[off+i].y = (stbtt_int16) y;
      }

      /* now convert them to our format */
      num_vertices=0;
      sx = sy = cx = cy = scx = scy = 0;
      for (i=0; i < n; ++i) {
         flags = vertices[off+i].type;
         x     = (stbtt_int16) vertices[off+i].x;
         y     = (stbtt_int16) vertices[off+i].y;

         if (next_move == i) {
            if (i != 0)
               num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

            /* now start the new one */
            start_off = !(flags & 1);
            if (start_off) {
               /* if we start off with an off-curve point, then when we need to find a point on the curve */
               /* where we can start, and we need to save some state for when we wraparound. */
               scx = x;
               scy = y;
               if (!(vertices[off+i+1].type & 1)) {
                  /* next point is also a curve point, so interpolate an on-point curve */
                  sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
                  sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;
               } else {
                  /* otherwise just use the next point as our start point */
                  sx = (stbtt_int32) vertices[off+i+1].x;
                  sy = (stbtt_int32) vertices[off+i+1].y;
                  ++i; /* we're using point i+1 as the starting point, so skip it */
               }
            } else {
               sx = x;
               sy = y;
            }
            stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);
            was_off = 0;
            next_move = 1 + ttUSHORT(endPtsOfContours+j*2);
            ++j;
         } else {
            if (!(flags & 1)) { /* if it's a curve */
               if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);
               cx = x;
               cy = y;
               was_off = 1;
            } else {
               if (was_off)
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);
               else
                  stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);
               was_off = 0;
            }
         }
      }
      num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);
   } else if (numberOfContours == -1) {
      /* Compound shapes. */
      int more = 1;
      stbtt_uint8 *comp = data + g + 10;
      num_vertices = 0;
      vertices = 0;
      while (more) {
         stbtt_uint16 flags, gidx;
         int comp_num_verts = 0, i;
         stbtt_vertex *comp_verts = 0, *tmp = 0;
         float mtx[6] = {1,0,0,1,0,0}, m, n;

         flags = ttSHORT(comp); comp+=2;
         gidx = ttSHORT(comp); comp+=2;

         if (flags & 2) { /* XY values */
            if (flags & 1) { /* shorts */
               mtx[4] = ttSHORT(comp); comp+=2;
               mtx[5] = ttSHORT(comp); comp+=2;
            } else {
               mtx[4] = ttCHAR(comp); comp+=1;
               mtx[5] = ttCHAR(comp); comp+=1;
            }
         }
         else {
            /* @TODO handle matching point */
            STBTT_assert(0);
         }
         if (flags & (1<<3)) { /* WE_HAVE_A_SCALE */
            mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
         } else if (flags & (1<<6)) { /* WE_HAVE_AN_X_AND_YSCALE */
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = mtx[2] = 0;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         } else if (flags & (1<<7)) { /* WE_HAVE_A_TWO_BY_TWO */
            mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;
            mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;
         }

         /* Find transformation scales. */
         m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);
         n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);

         /* Get indexed glyph. */
         comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
         if (comp_num_verts > 0) {
            /* Transform vertices. */
            for (i = 0; i < comp_num_verts; ++i) {
               stbtt_vertex* v = &comp_verts[i];
               stbtt_vertex_type x,y;
               x=v->x; y=v->y;
               v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
               x=v->cx; y=v->cy;
               v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));
               v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));
            }
            /* Append vertices. */
            tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);
            if (!tmp) {
               if (vertices) STBTT_free(vertices, info->userdata);
               if (comp_verts) STBTT_free(comp_verts, info->userdata);
               return 0;
            }
            if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));
            STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));
            if (vertices) STBTT_free(vertices, info->userdata);
            vertices = tmp;
            STBTT_free(comp_verts, info->userdata);
            num_vertices += comp_num_verts;
         }
         /* More components ? */
         more = flags & (1<<5);
      }
   } else if (numberOfContours < 0) {
      /* @TODO other compound variations? */
      STBTT_assert(0);
   } else {
      /* numberOfCounters == 0, do nothing */
   }

   *pvertices = vertices;
   return num_vertices;
}

typedef struct
{
   int bounds;
   int started;
   float first_x, first_y;
   float x, y;
   stbtt_int32 min_x, max_x, min_y, max_y;

   stbtt_vertex *pvertices;
   int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
{
   if (x > c->max_x || !c->started) c->max_x = x;
   if (y > c->max_y || !c->started) c->max_y = y;
   if (x < c->min_x || !c->started) c->min_x = x;
   if (y < c->min_y || !c->started) c->min_y = y;
   c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
   if (c->bounds) {
      stbtt__track_vertex(c, x, y);
      if (type == STBTT_vcubic) {
         stbtt__track_vertex(c, cx, cy);
         stbtt__track_vertex(c, cx1, cy1);
      }
   } else {
      stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
      c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;
      c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;
   }
   c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx *ctx)
{
   if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
      stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)
{
   stbtt__csctx_close_shape(ctx);
   ctx->first_x = ctx->x = ctx->x + dx;
   ctx->first_y = ctx->y = ctx->y + dy;
   stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)
{
   ctx->x += dx;
   ctx->y += dy;
   stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
   float cx1 = ctx->x + dx1;
   float cy1 = ctx->y + dy1;
   float cx2 = cx1 + dx2;
   float cy2 = cy1 + dy2;
   ctx->x = cx2 + dx3;
   ctx->y = cy2 + dy3;
   stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
   int count = stbtt__cff_index_count(&idx);
   int bias = 107;
   if (count >= 33900)
      bias = 32768;
   else if (count >= 1240)
      bias = 1131;
   n += bias;
   if (n < 0 || n >= count)
      return stbtt__new_buf(NULL, 0);
   return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)
{
   stbtt__buf fdselect = info->fdselect;
   int nranges, start, end, v, fmt, fdselector = -1, i;

   stbtt__buf_seek(&fdselect, 0);
   fmt = stbtt__buf_get8(&fdselect);
   if (fmt == 0) {
      /* untested */
      stbtt__buf_skip(&fdselect, glyph_index);
      fdselector = stbtt__buf_get8(&fdselect);
   } else if (fmt == 3) {
      nranges = stbtt__buf_get16(&fdselect);
      start = stbtt__buf_get16(&fdselect);
      for (i = 0; i < nranges; i++) {
         v = stbtt__buf_get8(&fdselect);
         end = stbtt__buf_get16(&fdselect);
         if (glyph_index >= start && glyph_index < end) {
            fdselector = v;
            break;
         }
         start = end;
      }
   }
   if (fdselector == -1) stbtt__new_buf(NULL, 0);
   return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
{
   int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
   int has_subrs = 0, clear_stack;
   float s[48];
   stbtt__buf subr_stack[10], subrs = info->subrs, b;
   float f;

#define STBTT__CSERR(s) (0)

   /* this currently ignores the initial width value, which isn't needed if we have hmtx */
   b = stbtt__cff_index_get(info->charstrings, glyph_index);
   while (b.cursor < b.size) {
      i = 0;
      clear_stack = 1;
      b0 = stbtt__buf_get8(&b);
      switch (b0) {
      /* @TODO implement hinting */
      case 0x13: /* hintmask */
      case 0x14: /* cntrmask */
         if (in_header)
            maskbits += (sp / 2); /* implicit "vstem" */
         in_header = 0;
         stbtt__buf_skip(&b, (maskbits + 7) / 8);
         break;

      case 0x01: /* hstem */
      case 0x03: /* vstem */
      case 0x12: /* hstemhm */
      case 0x17: /* vstemhm */
         maskbits += (sp / 2);
         break;

      case 0x15: /* rmoveto */
         in_header = 0;
         if (sp < 2) return STBTT__CSERR("rmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);
         break;
      case 0x04: /* vmoveto */
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("vmoveto stack");
         stbtt__csctx_rmove_to(c, 0, s[sp-1]);
         break;
      case 0x16: /* hmoveto */
         in_header = 0;
         if (sp < 1) return STBTT__CSERR("hmoveto stack");
         stbtt__csctx_rmove_to(c, s[sp-1], 0);
         break;

      case 0x05: /* rlineto */
         if (sp < 2) return STBTT__CSERR("rlineto stack");
         for (; i + 1 < sp; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      /* hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical */
      /* starting from a different place. */

      case 0x07: /* vlineto */
         if (sp < 1) return STBTT__CSERR("vlineto stack");
         goto vlineto;
      case 0x06: /* hlineto */
         if (sp < 1) return STBTT__CSERR("hlineto stack");
         for (;;) {
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, s[i], 0);
            i++;
      vlineto:
            if (i >= sp) break;
            stbtt__csctx_rline_to(c, 0, s[i]);
            i++;
         }
         break;

      case 0x1F: /* hvcurveto */
         if (sp < 4) return STBTT__CSERR("hvcurveto stack");
         goto hvcurveto;
      case 0x1E: /* vhcurveto */
         if (sp < 4) return STBTT__CSERR("vhcurveto stack");
         for (;;) {
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);
            i += 4;
      hvcurveto:
            if (i + 3 >= sp) break;
            stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);
            i += 4;
         }
         break;

      case 0x08: /* rrcurveto */
         if (sp < 6) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x18: /* rcurveline */
         if (sp < 8) return STBTT__CSERR("rcurveline stack");
         for (; i + 5 < sp - 2; i += 6)
            stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
         stbtt__csctx_rline_to(c, s[i], s[i+1]);
         break;

      case 0x19: /* rlinecurve */
         if (sp < 8) return STBTT__CSERR("rlinecurve stack");
         for (; i + 1 < sp - 6; i += 2)
            stbtt__csctx_rline_to(c, s[i], s[i+1]);
         if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
         stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);
         break;

      case 0x1A: /* vvcurveto */
      case 0x1B: /* hhcurveto */
         if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
         f = 0.0;
         if (sp & 1) { f = s[i]; i++; }
         for (; i + 3 < sp; i += 4) {
            if (b0 == 0x1B)
               stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);
            else
               stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);
            f = 0.0;
         }
         break;

      case 0x0A: /* callsubr */
         if (!has_subrs) {
            if (info->fdselect.size)
               subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
            has_subrs = 1;
         }
         /* fallthrough */
      case 0x1D: /* callgsubr */
         if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
         v = (int) s[--sp];
         if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
         subr_stack[subr_stack_height++] = b;
         b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
         if (b.size == 0) return STBTT__CSERR("subr not found");
         b.cursor = 0;
         clear_stack = 0;
         break;

      case 0x0B: /* return */
         if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
         b = subr_stack[--subr_stack_height];
         clear_stack = 0;
         break;

      case 0x0E: /* endchar */
         stbtt__csctx_close_shape(c);
         return 1;

      case 0x0C: { /* two-byte escape */
         float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
         float dx, dy;
         int b1 = stbtt__buf_get8(&b);
         switch (b1) {
         /* @TODO These "flex" implementations ignore the flex-depth and resolution, */
         /* and always draw beziers. */
         case 0x22: /* hflex */
            if (sp < 7) return STBTT__CSERR("hflex stack");
            dx1 = s[0];
            dx2 = s[1];
            dy2 = s[2];
            dx3 = s[3];
            dx4 = s[4];
            dx5 = s[5];
            dx6 = s[6];
            stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
            break;

         case 0x23: /* flex */
            if (sp < 13) return STBTT__CSERR("flex stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = s[10];
            dy6 = s[11];
            /* fd is s[12] */
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         case 0x24: /* hflex1 */
            if (sp < 9) return STBTT__CSERR("hflex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dx4 = s[5];
            dx5 = s[6];
            dy5 = s[7];
            dx6 = s[8];
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
            stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));
            break;

         case 0x25: /* flex1 */
            if (sp < 11) return STBTT__CSERR("flex1 stack");
            dx1 = s[0];
            dy1 = s[1];
            dx2 = s[2];
            dy2 = s[3];
            dx3 = s[4];
            dy3 = s[5];
            dx4 = s[6];
            dy4 = s[7];
            dx5 = s[8];
            dy5 = s[9];
            dx6 = dy6 = s[10];
            dx = dx1+dx2+dx3+dx4+dx5;
            dy = dy1+dy2+dy3+dy4+dy5;
            if (STBTT_fabs(dx) > STBTT_fabs(dy))
               dy6 = -dy;
            else
               dx6 = -dx;
            stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
            stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            break;

         default:
            return STBTT__CSERR("unimplemented");
         }
      } break;

      default:
         if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
            return STBTT__CSERR("reserved operator");

         /* push immediate */
         if (b0 == 255) {
            f = (float)(stbtt_int32)stbtt__buf_get32(&b) / 0x10000;
         } else {
            stbtt__buf_skip(&b, -1);
            f = (float)(stbtt_int16)stbtt__cff_int(&b);
         }
         if (sp >= 48) return STBTT__CSERR("push stack overflow");
         s[sp++] = f;
         clear_stack = 0;
         break;
      }
      if (clear_stack) sp = 0;
   }
   return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   /* runs the charstring twice, once to count and once to output (to avoid realloc) */
   stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
   stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
   if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
      *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);
      output_ctx.pvertices = *pvertices;
      if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
         STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
         return output_ctx.num_vertices;
      }
   }
   *pvertices = NULL;
   return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
{
   stbtt__csctx c = STBTT__CSCTX_INIT(1);
   int r = stbtt__run_charstring(info, glyph_index, &c);
   if (x0)  *x0 = r ? c.min_x : 0;
   if (y0)  *y0 = r ? c.min_y : 0;
   if (x1)  *x1 = r ? c.max_x : 0;
   if (y1)  *y1 = r ? c.max_y : 0;
   return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
{
   if (!info->cff.size)
      return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
   else
      return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
{
   stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);
   if (glyph_index < numOfLongHorMetrics) {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);
   } else {
      if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));
      if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));
   }
}

static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
   stbtt_uint8 *data = info->data + info->kern;
   stbtt_uint32 needle, straw;
   int l, r, m;

   /* we only look at the first table. it must be 'horizontal' and format 0. */
   if (!info->kern)
      return 0;
   if (ttUSHORT(data+2) < 1) /* number of tables, need at least 1 */
      return 0;
   if (ttUSHORT(data+8) != 1) /* horizontal flag must be set in format */
      return 0;

   l = 0;
   r = ttUSHORT(data+10) - 1;
   needle = glyph1 << 16 | glyph2;
   while (l <= r) {
      m = (l + r) >> 1;
      straw = ttULONG(data+18+(m*6)); /* note: unaligned read */
      if (needle < straw)
         r = m - 1;
      else if (needle > straw)
         l = m + 1;
      else
         return ttSHORT(data+22+(m*6));
   }
   return 0;
}

static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)
{
    stbtt_uint16 coverageFormat = ttUSHORT(coverageTable);
    switch(coverageFormat) {
        case 1: {
            stbtt_uint16 glyphCount = ttUSHORT(coverageTable + 2);

            /* Binary search. */
            stbtt_int32 l=0, r=glyphCount-1, m;
            int straw, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *glyphArray = coverageTable + 4;
                stbtt_uint16 glyphID;
                m = (l + r) >> 1;
                glyphID = ttUSHORT(glyphArray + 2 * m);
                straw = glyphID;
                if (needle < straw)
                    r = m - 1;
                else if (needle > straw)
                    l = m + 1;
                else {
                     return m;
                }
            }
        } break;

        case 2: {
            stbtt_uint16 rangeCount = ttUSHORT(coverageTable + 2);
            stbtt_uint8 *rangeArray = coverageTable + 4;

            /* Binary search. */
            stbtt_int32 l=0, r=rangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *rangeRecord;
                m = (l + r) >> 1;
                rangeRecord = rangeArray + 6 * m;
                strawStart = ttUSHORT(rangeRecord);
                strawEnd = ttUSHORT(rangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else {
                    stbtt_uint16 startCoverageIndex = ttUSHORT(rangeRecord + 4);
                    return startCoverageIndex + glyph - strawStart;
                }
            }
        } break;

        default: {
            /* There are no other cases. */
            STBTT_assert(0);
        } break;
    }

    return -1;
}

static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)
{
    stbtt_uint16 classDefFormat = ttUSHORT(classDefTable);
    switch(classDefFormat)
    {
        case 1: {
            stbtt_uint16 startGlyphID = ttUSHORT(classDefTable + 2);
            stbtt_uint16 glyphCount = ttUSHORT(classDefTable + 4);
            stbtt_uint8 *classDef1ValueArray = classDefTable + 6;

            if (glyph >= startGlyphID && glyph < startGlyphID + glyphCount)
                return (stbtt_int32)ttUSHORT(classDef1ValueArray + 2 * (glyph - startGlyphID));

            classDefTable = classDef1ValueArray + 2 * glyphCount;
        } break;

        case 2: {
            stbtt_uint16 classRangeCount = ttUSHORT(classDefTable + 2);
            stbtt_uint8 *classRangeRecords = classDefTable + 4;

            /* Binary search. */
            stbtt_int32 l=0, r=classRangeCount-1, m;
            int strawStart, strawEnd, needle=glyph;
            while (l <= r) {
                stbtt_uint8 *classRangeRecord;
                m = (l + r) >> 1;
                classRangeRecord = classRangeRecords + 6 * m;
                strawStart = ttUSHORT(classRangeRecord);
                strawEnd = ttUSHORT(classRangeRecord + 2);
                if (needle < strawStart)
                    r = m - 1;
                else if (needle > strawEnd)
                    l = m + 1;
                else
                    return (stbtt_int32)ttUSHORT(classRangeRecord + 4);
            }

            classDefTable = classRangeRecords + 6 * classRangeCount;
        } break;

        default: {
            /* There are no other cases. */
            STBTT_assert(0);
        } break;
    }

    return -1;
}

/* Define to STBTT_assert(x) if you want to break on unimplemented formats. */
#define STBTT_GPOS_TODO_assert(x)

static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)
{
    stbtt_uint16 lookupListOffset;
    stbtt_uint8 *lookupList;
    stbtt_uint16 lookupCount;
    stbtt_uint8 *data;
    stbtt_int32 i;

    if (!info->gpos) return 0;

    data = info->data + info->gpos;

    if (ttUSHORT(data+0) != 1) return 0; /* Major version 1 */
    if (ttUSHORT(data+2) != 0) return 0; /* Minor version 0 */

    lookupListOffset = ttUSHORT(data+8);
    lookupList = data + lookupListOffset;
    lookupCount = ttUSHORT(lookupList);

    for (i=0; i<lookupCount; ++i) {
        stbtt_uint16 lookupOffset = ttUSHORT(lookupList + 2 + 2 * i);
        stbtt_uint8 *lookupTable = lookupList + lookupOffset;

        stbtt_uint16 lookupType = ttUSHORT(lookupTable);
        stbtt_uint16 subTableCount = ttUSHORT(lookupTable + 4);
        stbtt_uint8 *subTableOffsets = lookupTable + 6;
        switch(lookupType) {
            case 2: { /* Pair Adjustment Positioning Subtable */
                stbtt_int32 sti;
                for (sti=0; sti<subTableCount; sti++) {
                    stbtt_uint16 subtableOffset = ttUSHORT(subTableOffsets + 2 * sti);
                    stbtt_uint8 *table = lookupTable + subtableOffset;
                    stbtt_uint16 posFormat = ttUSHORT(table);
                    stbtt_uint16 coverageOffset = ttUSHORT(table + 2);
                    stbtt_int32 coverageIndex = stbtt__GetCoverageIndex(table + coverageOffset, glyph1);
                    if (coverageIndex == -1) continue;

                    switch (posFormat) {
                        case 1: {
                            stbtt_int32 l, r, m;
                            int straw, needle;
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);
                            stbtt_int32 valueRecordPairSizeInBytes = 2;
                            stbtt_uint16 pairSetCount = ttUSHORT(table + 8);
                            stbtt_uint16 pairPosOffset = ttUSHORT(table + 10 + 2 * coverageIndex);
                            stbtt_uint8 *pairValueTable = table + pairPosOffset;
                            stbtt_uint16 pairValueCount = ttUSHORT(pairValueTable);
                            stbtt_uint8 *pairValueArray = pairValueTable + 2;
                            /* TODO: Support more formats. */
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            STBTT_assert(coverageIndex < pairSetCount);

                            needle=glyph2;
                            r=pairValueCount-1;
                            l=0;

                            /* Binary search. */
                            while (l <= r) {
                                stbtt_uint16 secondGlyph;
                                stbtt_uint8 *pairValue;
                                m = (l + r) >> 1;
                                pairValue = pairValueArray + (2 + valueRecordPairSizeInBytes) * m;
                                secondGlyph = ttUSHORT(pairValue);
                                straw = secondGlyph;
                                if (needle < straw)
                                    r = m - 1;
                                else if (needle > straw)
                                    l = m + 1;
                                else {
                                    stbtt_int16 xAdvance = ttSHORT(pairValue + 2);
                                    return xAdvance;
                                }
                            }
                        } break;

                        case 2: {
                            stbtt_uint16 valueFormat1 = ttUSHORT(table + 4);
                            stbtt_uint16 valueFormat2 = ttUSHORT(table + 6);

                            stbtt_uint16 classDef1Offset = ttUSHORT(table + 8);
                            stbtt_uint16 classDef2Offset = ttUSHORT(table + 10);
                            int glyph1class = stbtt__GetGlyphClass(table + classDef1Offset, glyph1);
                            int glyph2class = stbtt__GetGlyphClass(table + classDef2Offset, glyph2);

                            stbtt_uint16 class1Count = ttUSHORT(table + 12);
                            stbtt_uint16 class2Count = ttUSHORT(table + 14);
                            STBTT_assert(glyph1class < class1Count);
                            STBTT_assert(glyph2class < class2Count);

                            /* TODO: Support more formats. */
                            STBTT_GPOS_TODO_assert(valueFormat1 == 4);
                            if (valueFormat1 != 4) return 0;
                            STBTT_GPOS_TODO_assert(valueFormat2 == 0);
                            if (valueFormat2 != 0) return 0;

                            if (glyph1class >= 0 && glyph1class < class1Count && glyph2class >= 0 && glyph2class < class2Count) {
                                stbtt_uint8 *class1Records = table + 16;
                                stbtt_uint8 *class2Records = class1Records + 2 * (glyph1class * class2Count);
                                stbtt_int16 xAdvance = ttSHORT(class2Records + 2 * glyph2class);
                                return xAdvance;
                            }
                        } break;

                        default: {
                            /* There are no other cases. */
                            STBTT_assert(0);
                            break;
                        };
                    }
                }
                break;
            };

            default:
                /* TODO: Implement other stuff. */
                break;
        }
    }

    return 0;
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)
{
   int xAdvance = 0;

   if (info->gpos)
      xAdvance += stbtt__GetGlyphGPOSInfoAdvance(info, g1, g2);

   if (info->kern)
      xAdvance += stbtt__GetGlyphKernInfoAdvance(info, g1, g2);

   return xAdvance;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)
{
   if (!info->kern && !info->gpos) /* if no kerning table, don't waste time looking up both codepoint->glyphs */
      return 0;
   return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info,ch1), stbtt_FindGlyphIndex(info,ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
{
   stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info,codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
{
   if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);
   if (descent) *descent = ttSHORT(info->data+info->hhea + 6);
   if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);
}

STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)
{
   int tab = stbtt__find_table(info->data, info->fontstart, "OS/2");
   if (!tab)
      return 0;
   if (typoAscent ) *typoAscent  = ttSHORT(info->data+tab + 68);
   if (typoDescent) *typoDescent = ttSHORT(info->data+tab + 70);
   if (typoLineGap) *typoLineGap = ttSHORT(info->data+tab + 72);
   return 1;
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
{
   *x0 = ttSHORT(info->data + info->head + 36);
   *y0 = ttSHORT(info->data + info->head + 38);
   *x1 = ttSHORT(info->data + info->head + 40);
   *y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)
{
   int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
   return (float) height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)
{
   int unitsPerEm = ttUSHORT(info->data + info->head + 18);
   return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)
{
   STBTT_free(v, info->userdata);
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* antialiasing software rasterizer */
/*  */

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   int x0=0,y0=0,x1,y1; /* =0 suppresses compiler warning */
   if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {
      /* e.g. space character */
      if (ix0) *ix0 = 0;
      if (iy0) *iy0 = 0;
      if (ix1) *ix1 = 0;
      if (iy1) *iy1 = 0;
   } else {
      /* move to integral bboxes (treating pixels as little squares, what pixels get touched)? */
      if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);
      if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
      if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);
      if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);
   }
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font,codepoint), scale_x, scale_y,shift_x,shift_y, ix0,iy0,ix1,iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
{
   stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y,0.0f,0.0f, ix0,iy0,ix1,iy1);
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* Rasterizer */

typedef struct stbtt__hheap_chunk
{
   struct stbtt__hheap_chunk *next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
   struct stbtt__hheap_chunk *head;
   void   *first_free;
   int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)
{
   if (hh->first_free) {
      void *p = hh->first_free;
      hh->first_free = * (void **) p;
      return p;
   } else {
      if (hh->num_remaining_in_head_chunk == 0) {
         int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
         stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
         if (c == NULL)
            return NULL;
         c->next = hh->head;
         hh->head = c;
         hh->num_remaining_in_head_chunk = count;
      }
      --hh->num_remaining_in_head_chunk;
      return (char *) (hh->head) + sizeof(stbtt__hheap_chunk) + size * hh->num_remaining_in_head_chunk;
   }
}

static void stbtt__hheap_free(stbtt__hheap *hh, void *p)
{
   *(void **) p = hh->first_free;
   hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)
{
   stbtt__hheap_chunk *c = hh->head;
   while (c) {
      stbtt__hheap_chunk *n = c->next;
      STBTT_free(c, userdata);
      c = n;
   }
}

typedef struct stbtt__edge {
   float x0,y0, x1,y1;
   int invert;
} stbtt__edge;


typedef struct stbtt__active_edge
{
   struct stbtt__active_edge *next;
   #if STBTT_RASTERIZER_VERSION==1
   int x,dx;
   float ey;
   int direction;
   #elif STBTT_RASTERIZER_VERSION==2
   float fx,fdx,fdy;
   float direction;
   float sy;
   float ey;
   #else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
   #endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   if (!z) return z;

   /* round dx down to avoid overshooting */
   if (dxdy < 0)
      z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
   else
      z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

   z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); /* use z->dx so when we offset later it's by the same amount */
   z->x -= off_x * STBTT_FIX;

   z->ey = e->y1;
   z->next = 0;
   z->direction = e->invert ? 1 : -1;
   return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
{
   stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);
   float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
   STBTT_assert(z != NULL);
   /* STBTT_assert(e->y0 <= start_point); */
   if (!z) return z;
   z->fdx = dxdy;
   z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;
   z->fx = e->x0 + dxdy * (start_point - e->y0);
   z->fx -= off_x;
   z->direction = e->invert ? 1.0f : -1.0f;
   z->sy = e->y0;
   z->ey = e->y1;
   z->next = 0;
   return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
/* note: this routine clips fills that extend off the edges... ideally this */
/* wouldn't happen, but it could happen if the truetype glyph bounding boxes */
/* are wrong, or if the user supplies a too-small bitmap */
static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
{
   /* non-zero winding fill */
   int x0=0, w=0;

   while (e) {
      if (w == 0) {
         /* if we're currently at zero, we need to record the edge start point */
         x0 = e->x; w += e->direction;
      } else {
         int x1 = e->x; w += e->direction;
         /* if we went to zero, we need to draw */
         if (w == 0) {
            int i = x0 >> STBTT_FIXSHIFT;
            int j = x1 >> STBTT_FIXSHIFT;

            if (i < len && j >= 0) {
               if (i == j) {
                  /* x0,x1 are the same pixel, so compute combined coverage */
                  scanline[i] = scanline[i] + (stbtt_uint8) ((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
               } else {
                  if (i >= 0) /* add antialiasing for x0 */
                     scanline[i] = scanline[i] + (stbtt_uint8) (((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     i = -1; /* clip */

                  if (j < len) /* add antialiasing for x1 */
                     scanline[j] = scanline[j] + (stbtt_uint8) (((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
                  else
                     j = len; /* clip */

                  for (++i; i < j; ++i) /* fill pixels between x0 and x1 */
                     scanline[i] = scanline[i] + (stbtt_uint8) max_weight;
               }
            }
         }
      }

      e = e->next;
   }
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0;
   int max_weight = (255 / vsubsample);  /* weight per vertical scanline */
   int s; /* vertical subsample index */
   unsigned char scanline_data[512], *scanline;

   if (result->w > 512)
      scanline = (unsigned char *) STBTT_malloc(result->w, userdata);
   else
      scanline = scanline_data;

   y = off_y * vsubsample;
   e[n].y0 = (off_y + result->h) * (float) vsubsample + 1;

   while (j < result->h) {
      STBTT_memset(scanline, 0, result->w);
      for (s=0; s < vsubsample; ++s) {
         /* find center of pixel for this scanline */
         float scan_y = y + 0.5f;
         stbtt__active_edge **step = &active;

         /* update all active edges; */
         /* remove all active edges that terminate before the center of this scanline */
         while (*step) {
            stbtt__active_edge * z = *step;
            if (z->ey <= scan_y) {
               *step = z->next; /* delete from list */
               STBTT_assert(z->direction);
               z->direction = 0;
               stbtt__hheap_free(&hh, z);
            } else {
               z->x += z->dx; /* advance to position for current scanline */
               step = &((*step)->next); /* advance through list */
            }
         }

         /* resort the list if needed */
         for(;;) {
            int changed=0;
            step = &active;
            while (*step && (*step)->next) {
               if ((*step)->x > (*step)->next->x) {
                  stbtt__active_edge *t = *step;
                  stbtt__active_edge *q = t->next;

                  t->next = q->next;
                  q->next = t;
                  *step = q;
                  changed = 1;
               }
               step = &(*step)->next;
            }
            if (!changed) break;
         }

         /* insert all edges that start before the center of this scanline -- omit ones that also end on this scanline */
         while (e->y0 <= scan_y) {
            if (e->y1 > scan_y) {
               stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
               if (z != NULL) {
                  /* find insertion point */
                  if (active == NULL)
                     active = z;
                  else if (z->x < active->x) {
                     /* insert at front */
                     z->next = active;
                     active = z;
                  } else {
                     /* find thing to insert AFTER */
                     stbtt__active_edge *p = active;
                     while (p->next && p->next->x < z->x)
                        p = p->next;
                     /* at this point, p->next->x is NOT < z->x */
                     z->next = p->next;
                     p->next = z;
                  }
               }
            }
            ++e;
         }

         /* now process all active edges in XOR fashion */
         if (active)
            stbtt__fill_active_edges(scanline, result->w, active, max_weight);

         ++y;
      }
      STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

/* the edge passed in here does not cross the vertical line at x or the vertical line at x+1 */
/* (i.e. it has already been clipped to those) */
static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
{
   if (y0 == y1) return;
   STBTT_assert(y0 < y1);
   STBTT_assert(e->sy <= e->ey);
   if (y0 > e->ey) return;
   if (y1 < e->sy) return;
   if (y0 < e->sy) {
      x0 += (x1-x0) * (e->sy - y0) / (y1-y0);
      y0 = e->sy;
   }
   if (y1 > e->ey) {
      x1 += (x1-x0) * (e->ey - y1) / (y1-y0);
      y1 = e->ey;
   }

   if (x0 == x)
      STBTT_assert(x1 <= x+1);
   else if (x0 == x+1)
      STBTT_assert(x1 >= x);
   else if (x0 <= x)
      STBTT_assert(x1 <= x);
   else if (x0 >= x+1)
      STBTT_assert(x1 >= x+1);
   else
      STBTT_assert(x1 >= x && x1 <= x+1);

   if (x0 <= x && x1 <= x)
      scanline[x] += e->direction * (y1-y0);
   else if (x0 >= x+1 && x1 >= x+1)
      ;
   else {
      STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
      scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); /* coverage = 1 - average x position */
   }
}

static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
{
   float y_bottom = y_top+1;

   while (e) {
      /* brute force every pixel */

      /* compute intersection points with top & bottom */
      STBTT_assert(e->ey >= y_top);

      if (e->fdx == 0) {
         float x0 = e->fx;
         if (x0 < len) {
            if (x0 >= 0) {
               stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);
               stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);
            } else {
               stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);
            }
         }
      } else {
         float x0 = e->fx;
         float dx = e->fdx;
         float xb = x0 + dx;
         float x_top, x_bottom;
         float sy0,sy1;
         float dy = e->fdy;
         STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

         /* compute endpoints of line segment clipped to this scanline (if the */
         /* line segment starts on this scanline. x0 is the intersection of the */
         /* line with y_top, but that may be off the line segment. */
         if (e->sy > y_top) {
            x_top = x0 + dx * (e->sy - y_top);
            sy0 = e->sy;
         } else {
            x_top = x0;
            sy0 = y_top;
         }
         if (e->ey < y_bottom) {
            x_bottom = x0 + dx * (e->ey - y_top);
            sy1 = e->ey;
         } else {
            x_bottom = xb;
            sy1 = y_bottom;
         }

         if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
            /* from here on, we don't have to range check x values */

            if ((int) x_top == (int) x_bottom) {
               float height;
               /* simple case, only spans one pixel */
               int x = (int) x_top;
               height = sy1 - sy0;
               STBTT_assert(x >= 0 && x < len);
               scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;
               scanline_fill[x] += e->direction * height; /* everything right of this pixel is filled */
            } else {
               int x,x1,x2;
               float y_crossing, step, sign, area;
               /* covers 2+ pixels */
               if (x_top > x_bottom) {
                  /* flip scanline vertically; signed area is the same */
                  float t;
                  sy0 = y_bottom - (sy0 - y_top);
                  sy1 = y_bottom - (sy1 - y_top);
                  t = sy0, sy0 = sy1, sy1 = t;
                  t = x_bottom, x_bottom = x_top, x_top = t;
                  dx = -dx;
                  dy = -dy;
                  t = x0, x0 = xb, xb = t;
               }

               x1 = (int) x_top;
               x2 = (int) x_bottom;
               /* compute intersection with y axis at x1+1 */
               y_crossing = (x1+1 - x0) * dy + y_top;

               sign = e->direction;
               /* area of the rectangle covered from y0..y_crossing */
               area = sign * (y_crossing-sy0);
               /* area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing) */
               scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

               step = sign * dy;
               for (x = x1+1; x < x2; ++x) {
                  scanline[x] += area + step/2;
                  area += step;
               }
               y_crossing += dy * (x2 - (x1+1));

               STBTT_assert(STBTT_fabs(area) <= 1.01f);

               scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

               scanline_fill[x2] += sign * (sy1-sy0);
            }
         } else {
            /* if edge goes outside of box we're drawing, we require */
            /* clipping logic. since this does not match the intended use */
            /* of this library, we use a different, very slow brute */
            /* force implementation */
            int x;
            for (x=0; x < len; ++x) {
               /* cases: */
               /*  */
               /* there can be up to two intersections with the pixel. any intersection */
               /* with left or right edges can be handled by splitting into two (or three) */
               /* regions. intersections with top & bottom do not necessitate case-wise logic. */
               /*  */
               /* the old way of doing this found the intersections with the left & right edges, */
               /* then used some simple logic to produce up to three segments in sorted order */
               /* from top-to-bottom. however, this had a problem: if an x edge was epsilon */
               /* across the x border, then the corresponding y position might not be distinct */
               /* from the other y segment, and it might ignored as an empty segment. to avoid */
               /* that, we need to explicitly produce segments based on x positions. */

               /* rename variables to clearly-defined pairs */
               float y0 = y_top;
               float x1 = (float) (x);
               float x2 = (float) (x+1);
               float x3 = xb;
               float y3 = y_bottom;

               /* x = e->x + e->dx * (y-y_top) */
               /* (y-y_top) = (x - e->x) / e->dx */
               /* y = (x - e->x) / e->dx + y_top */
               float y1 = (x - x0) / dx + y_top;
               float y2 = (x+1 - x0) / dx + y_top;

               if (x0 < x1 && x3 > x2) {         /* three segments descending down-right */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x1 && x0 > x2) {  /* three segments descending down-left */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x1 && x3 > x1) {  /* two segments across x, down-right */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x3 < x1 && x0 > x1) {  /* two segments across x, down-left */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
                  stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
               } else if (x0 < x2 && x3 > x2) {  /* two segments across x+1, down-right */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else if (x3 < x2 && x0 > x2) {  /* two segments across x+1, down-left */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
                  stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
               } else {  /* one segment */
                  stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);
               }
            }
         }
      }
      e = e->next;
   }
}

/* directly AA rasterize edges w/o supersampling */
static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
{
   stbtt__hheap hh = { 0, 0, 0 };
   stbtt__active_edge *active = NULL;
   int y,j=0, i;
   float scanline_data[129], *scanline, *scanline2;

   STBTT__NOTUSED(vsubsample);

   if (result->w > 64)
      scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);
   else
      scanline = scanline_data;

   scanline2 = scanline + result->w;

   y = off_y;
   e[n].y0 = (float) (off_y + result->h) + 1;

   while (j < result->h) {
      /* find center of pixel for this scanline */
      float scan_y_top    = y + 0.0f;
      float scan_y_bottom = y + 1.0f;
      stbtt__active_edge **step = &active;

      STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));
      STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

      /* update all active edges; */
      /* remove all active edges that terminate before the top of this scanline */
      while (*step) {
         stbtt__active_edge * z = *step;
         if (z->ey <= scan_y_top) {
            *step = z->next; /* delete from list */
            STBTT_assert(z->direction);
            z->direction = 0;
            stbtt__hheap_free(&hh, z);
         } else {
            step = &((*step)->next); /* advance through list */
         }
      }

      /* insert all edges that start before the bottom of this scanline */
      while (e->y0 <= scan_y_bottom) {
         if (e->y0 != e->y1) {
            stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
            if (z != NULL) {
               STBTT_assert(z->ey >= scan_y_top);
               /* insert at front */
               z->next = active;
               active = z;
            }
         }
         ++e;
      }

      /* now process all active edges */
      if (active)
         stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

      {
         float sum = 0;
         for (i=0; i < result->w; ++i) {
            float k;
            int m;
            sum += scanline2[i];
            k = scanline[i] + sum;
            k = (float) STBTT_fabs(k)*255 + 0.5f;
            m = (int) k;
            if (m > 255) m = 255;

#ifndef STBTT_RGB_MODE
            result->pixels[j*result->stride + i] = (unsigned char) m;
#else
            const unsigned char * color = (const unsigned char*) userdata;
            unsigned char * pos = result->pixels + 3 * j * result->stride + 3 * i;
            pos[0] = pos[0] + (color[0] - pos[0]) * (m/255.f);
            pos[1] = pos[1] + (color[1] - pos[1]) * (m/255.f);
            pos[2] = pos[2] + (color[2] - pos[2]) * (m/255.f);
#endif
         }
      }
      /* advance all the edges */
      step = &active;
      while (*step) {
         stbtt__active_edge *z = *step;
         z->fx += z->fdx; /* advance to position for current scanline */
         step = &((*step)->next); /* advance through list */
      }

      ++y;
      ++j;
   }

   stbtt__hheap_cleanup(&hh, userdata);

   if (scanline != scanline_data)
      STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)
{
   int i,j;
   for (i=1; i < n; ++i) {
      stbtt__edge t = p[i], *a = &t;
      j = i;
      while (j > 0) {
         stbtt__edge *b = &p[j-1];
         int c = STBTT__COMPARE(a,b);
         if (!c) break;
         p[j] = p[j-1];
         --j;
      }
      if (i != j)
         p[j] = t;
   }
}

static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)
{
   /* threshhold for transitioning to insertion sort */
   while (n > 12) {
      stbtt__edge t;
      int c01,c12,c,m,i,j;

      /* compute median of three */
      m = n >> 1;
      c01 = STBTT__COMPARE(&p[0],&p[m]);
      c12 = STBTT__COMPARE(&p[m],&p[n-1]);
      /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
      if (c01 != c12) {
         /* otherwise, we'll need to swap something else to middle */
         int z;
         c = STBTT__COMPARE(&p[0],&p[n-1]);
         /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
         /* 0<mid && mid>n:  0>n => 0; 0<n => n */
         z = (c == c12) ? 0 : n-1;
         t = p[z];
         p[z] = p[m];
         p[m] = t;
      }
      /* now p[m] is the median-of-three */
      /* swap it to the beginning so it won't move around */
      t = p[0];
      p[0] = p[m];
      p[m] = t;

      /* partition loop */
      i=1;
      j=n-1;
      for(;;) {
         /* handling of equality is crucial here */
         /* for sentinels & efficiency with duplicates */
         for (;;++i) {
            if (!STBTT__COMPARE(&p[i], &p[0])) break;
         }
         for (;;--j) {
            if (!STBTT__COMPARE(&p[0], &p[j])) break;
         }
         /* make sure we haven't crossed */
         if (i >= j) break;
         t = p[i];
         p[i] = p[j];
         p[j] = t;

         ++i;
         --j;
      }
      /* recurse on smaller side, iterate on larger */
      if (j < (n-i)) {
         stbtt__sort_edges_quicksort(p,j);
         p = p+i;
         n = n-i;
      } else {
         stbtt__sort_edges_quicksort(p+i, n-i);
         n = j;
      }
   }
}

static void stbtt__sort_edges(stbtt__edge *p, int n)
{
   stbtt__sort_edges_quicksort(p, n);
   stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
   float x,y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
{
   float y_scale_inv = invert ? -scale_y : scale_y;
   stbtt__edge *e;
   int n,i,j,k,m;
#if STBTT_RASTERIZER_VERSION == 1
   int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
   int vsubsample = 1;
#else
   #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
   /* vsubsample should divide 255 evenly; otherwise we won't reach full opacity */

   /* now we have to blow out the windings into explicit edge lists */
   n = 0;
   for (i=0; i < windings; ++i)
      n += wcount[i];

   e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); /* add an extra one as a sentinel */
   if (e == 0) return;
   n = 0;

   m=0;
   for (i=0; i < windings; ++i) {
      stbtt__point *p = pts + m;
      m += wcount[i];
      j = wcount[i]-1;
      for (k=0; k < wcount[i]; j=k++) {
         int a=k,b=j;
         /* skip the edge if horizontal */
         if (p[j].y == p[k].y)
            continue;
         /* add edge from j to k to the list */
         e[n].invert = 0;
         if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
            e[n].invert = 1;
            a=j,b=k;
         }
         e[n].x0 = p[a].x * scale_x + shift_x;
         e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
         e[n].x1 = p[b].x * scale_x + shift_x;
         e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
         ++n;
      }
   }

   /* now sort the edges by their highest point (should snap to integer, and then by x) */
   /* STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare); */
   stbtt__sort_edges(e, n);

   /* now, traverse the scanlines and find the intersections on each scanline, use xor winding rule */
   stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

   STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point *points, int n, float x, float y)
{
   if (!points) return; /* during first pass, it's unallocated */
   points[n].x = x;
   points[n].y = y;
}

/* tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching */
static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
   /* midpoint */
   float mx = (x0 + 2*x1 + x2)/4;
   float my = (y0 + 2*y1 + y2)/4;
   /* versus directly drawn line */
   float dx = (x0+x2)/2 - mx;
   float dy = (y0+y2)/2 - my;
   if (n > 16) /* 65536 segments on one curve better be enough! */
      return 1;
   if (dx*dx+dy*dy > objspace_flatness_squared) { /* half-pixel error allowed... need to be smaller if AA */
      stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x2,y2);
      *num_points = *num_points+1;
   }
   return 1;
}

static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
   /* @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough */
   float dx0 = x1-x0;
   float dy0 = y1-y0;
   float dx1 = x2-x1;
   float dy1 = y2-y1;
   float dx2 = x3-x2;
   float dy2 = y3-y2;
   float dx = x3-x0;
   float dy = y3-y0;
   float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));
   float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);
   float flatness_squared = longlen*longlen-shortlen*shortlen;

   if (n > 16) /* 65536 segments on one curve better be enough! */
      return;

   if (flatness_squared > objspace_flatness_squared) {
      float x01 = (x0+x1)/2;
      float y01 = (y0+y1)/2;
      float x12 = (x1+x2)/2;
      float y12 = (y1+y2)/2;
      float x23 = (x2+x3)/2;
      float y23 = (y2+y3)/2;

      float xa = (x01+x12)/2;
      float ya = (y01+y12)/2;
      float xb = (x12+x23)/2;
      float yb = (y12+y23)/2;

      float mx = (xa+xb)/2;
      float my = (ya+yb)/2;

      stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);
      stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);
   } else {
      stbtt__add_point(points, *num_points,x3,y3);
      *num_points = *num_points+1;
   }
}

/* returns number of contours */
static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
{
   stbtt__point *points=0;
   int num_points=0;

   float objspace_flatness_squared = objspace_flatness * objspace_flatness;
   int i,n=0,start=0, pass;

   /* count how many "moves" there are to get the contour count */
   for (i=0; i < num_verts; ++i)
      if (vertices[i].type == STBTT_vmove)
         ++n;

   *num_contours = n;
   if (n == 0) return 0;

   *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

   if (*contour_lengths == 0) {
      *num_contours = 0;
      return 0;
   }

   /* make two passes through the points so we don't need to realloc */
   for (pass=0; pass < 2; ++pass) {
      float x=0,y=0;
      if (pass == 1) {
         points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);
         if (points == NULL) goto error;
      }
      num_points = 0;
      n= -1;
      for (i=0; i < num_verts; ++i) {
         switch (vertices[i].type) {
            case STBTT_vmove:
               /* start the next contour */
               if (n >= 0)
                  (*contour_lengths)[n] = num_points - start;
               ++n;
               start = num_points;

               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x,y);
               break;
            case STBTT_vline:
               x = vertices[i].x, y = vertices[i].y;
               stbtt__add_point(points, num_points++, x, y);
               break;
            case STBTT_vcurve:
               stbtt__tesselate_curve(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
            case STBTT_vcubic:
               stbtt__tesselate_cubic(points, &num_points, x,y,
                                        vertices[i].cx, vertices[i].cy,
                                        vertices[i].cx1, vertices[i].cy1,
                                        vertices[i].x,  vertices[i].y,
                                        objspace_flatness_squared, 0);
               x = vertices[i].x, y = vertices[i].y;
               break;
         }
      }
      (*contour_lengths)[n] = num_points - start;
   }

   return points;
error:
   STBTT_free(points, userdata);
   STBTT_free(*contour_lengths, userdata);
   *contour_lengths = 0;
   *num_contours = 0;
   return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
{
   float scale            = scale_x > scale_y ? scale_y : scale_x;
   int winding_count      = 0;
   int *winding_lengths   = NULL;
   stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
   if (windings) {
      stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
      STBTT_free(winding_lengths, userdata);
      STBTT_free(windings, userdata);
   }
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   int ix0,iy0,ix1,iy1;
   stbtt__bitmap gbm;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) {
         STBTT_free(vertices, info->userdata);
         return NULL;
      }
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,&ix1,&iy1);

   /* now we get the size */
   gbm.w = (ix1 - ix0);
   gbm.h = (iy1 - iy0);
   gbm.pixels = NULL; /* in case we error */

   if (width ) *width  = gbm.w;
   if (height) *height = gbm.h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   if (gbm.w && gbm.h) {
      gbm.pixels = (unsigned char *) STBTT_malloc(gbm.w * gbm.h, info->userdata);
      if (gbm.pixels) {
         gbm.stride = gbm.w;

         stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
      }
   }
   STBTT_free(vertices, info->userdata);
   return gbm.pixels;
}

STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
   int ix0,iy0;
   stbtt_vertex *vertices;
   int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
   stbtt__bitmap gbm;

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);
   gbm.pixels = output;
   gbm.w = out_w;
   gbm.h = out_h;
   gbm.stride = out_stride;

   if (gbm.w && gbm.h)
      stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

   STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, glyph);
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y,shift_x,shift_y, stbtt_FindGlyphIndex(info,codepoint), width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixelPrefilter(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, sub_x, sub_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
   stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info,codepoint));
}

STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f,0.0f, codepoint, width,height,xoff,yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
   stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f,0.0f, codepoint);
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* bitmap baking */
/*  */
/* This is SUPER-CRAPPY packing to keep source code small */

static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  /* font location (use offset=0 for plain .ttf) */
                                float pixel_height,                     /* height of font in pixels */
                                unsigned char *pixels, int pw, int ph,  /* bitmap to be filled in */
                                int first_char, int num_chars,          /* characters to bake */
                                stbtt_bakedchar *chardata)
{
   float scale;
   int x,y,bottom_y, i;
   stbtt_fontinfo f;
   f.userdata = NULL;
   if (!stbtt_InitFont(&f, data, offset))
      return -1;
   STBTT_memset(pixels, 0, pw*ph); /* background of 0 around pixels */
   x=y=1;
   bottom_y = 1;

   scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

   for (i=0; i < num_chars; ++i) {
      int advance, lsb, x0,y0,x1,y1,gw,gh;
      int g = stbtt_FindGlyphIndex(&f, first_char + i);
      stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
      stbtt_GetGlyphBitmapBox(&f, g, scale,scale, &x0,&y0,&x1,&y1);
      gw = x1-x0;
      gh = y1-y0;
      if (x + gw + 1 >= pw)
         y = bottom_y, x = 1; /* advance to next row */
      if (y + gh + 1 >= ph) /* check if it fits vertically AFTER potentially moving to next row */
         return -i;
      STBTT_assert(x+gw < pw);
      STBTT_assert(y+gh < ph);
      stbtt_MakeGlyphBitmap(&f, pixels+x+y*pw, gw,gh,pw, scale,scale, g);
      chardata[i].x0 = (stbtt_int16) x;
      chardata[i].y0 = (stbtt_int16) y;
      chardata[i].x1 = (stbtt_int16) (x + gw);
      chardata[i].y1 = (stbtt_int16) (y + gh);
      chardata[i].xadvance = scale * advance;
      chardata[i].xoff     = (float) x0;
      chardata[i].yoff     = (float) y0;
      x = x + gw + 1;
      if (y+gh+1 > bottom_y)
         bottom_y = y+gh+1;
   }
   return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
{
   float d3d_bias = opengl_fillrule ? 0 : -0.5f;
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_bakedchar *b = chardata + char_index;
   int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
   int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

   q->x0 = round_x + d3d_bias;
   q->y0 = round_y + d3d_bias;
   q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
   q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* rectangle packing replacement routines if you don't have stb_rect_pack.h */
/*  */

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

/* ////////////////////////////////////////////////////////////////////////////////// */
/* // */
/* // */
/* COMPILER WARNING ?!?!?                                                         // */
/* // */
/* // */
/* if you get a compile warning due to these symbols being defined more than      // */
/* once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         // */
/* // */
/* ////////////////////////////////////////////////////////////////////////////////// */

typedef struct
{
   int width,height;
   int x,y,bottom_y;
} stbrp_context;

typedef struct
{
   unsigned char x;
} stbrp_node;

struct stbrp_rect
{
   stbrp_coord x,y;
   int id,w,h,was_packed;
};

static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
{
   con->width  = pw;
   con->height = ph;
   con->x = 0;
   con->y = 0;
   con->bottom_y = 0;
   STBTT__NOTUSED(nodes);
   STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)
{
   int i;
   for (i=0; i < num_rects; ++i) {
      if (con->x + rects[i].w > con->width) {
         con->x = 0;
         con->y = con->bottom_y;
      }
      if (con->y + rects[i].h > con->height)
         break;
      rects[i].x = con->x;
      rects[i].y = con->y;
      rects[i].was_packed = 1;
      con->x += rects[i].w;
      if (con->y + rects[i].h > con->bottom_y)
         con->bottom_y = con->y + rects[i].h;
   }
   for (   ; i < num_rects; ++i)
      rects[i].was_packed = 0;
}
#endif

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* bitmap baking */
/*  */
/* This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If */
/* stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy. */

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
{
   stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);
   int            num_nodes = pw - padding;
   stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

   if (context == NULL || nodes == NULL) {
      if (context != NULL) STBTT_free(context, alloc_context);
      if (nodes   != NULL) STBTT_free(nodes  , alloc_context);
      return 0;
   }

   spc->user_allocator_context = alloc_context;
   spc->width = pw;
   spc->height = ph;
   spc->pixels = pixels;
   spc->pack_info = context;
   spc->nodes = nodes;
   spc->padding = padding;
   spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
   spc->h_oversample = 1;
   spc->v_oversample = 1;

   stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

   if (pixels)
      STBTT_memset(pixels, 0, pw*ph); /* background of 0 around pixels */

   return 1;
}

STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)
{
   STBTT_free(spc->nodes    , spc->user_allocator_context);
   STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
{
   STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
   STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
   if (h_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->h_oversample = h_oversample;
   if (v_oversample <= STBTT_MAX_OVERSAMPLE)
      spc->v_oversample = v_oversample;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_w = w - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); /* suppress bogus warning from VS2013 -analyze */
   for (j=0; j < h; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      /* make kernel_width a constant in common cases so compiler can optimize out the divide */
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_w; ++i) {
               total += pixels[i] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];
               pixels[i] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < w; ++i) {
         STBTT_assert(pixels[i] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i] = (unsigned char) (total / kernel_width);
      }

      pixels += stride_in_bytes;
   }
}

static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
   unsigned char buffer[STBTT_MAX_OVERSAMPLE];
   int safe_h = h - kernel_width;
   int j;
   STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); /* suppress bogus warning from VS2013 -analyze */
   for (j=0; j < w; ++j) {
      int i;
      unsigned int total;
      STBTT_memset(buffer, 0, kernel_width);

      total = 0;

      /* make kernel_width a constant in common cases so compiler can optimize out the divide */
      switch (kernel_width) {
         case 2:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 2);
            }
            break;
         case 3:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 3);
            }
            break;
         case 4:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 4);
            }
            break;
         case 5:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / 5);
            }
            break;
         default:
            for (i=0; i <= safe_h; ++i) {
               total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
               buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];
               pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
            }
            break;
      }

      for (; i < h; ++i) {
         STBTT_assert(pixels[i*stride_in_bytes] == 0);
         total -= buffer[i & STBTT__OVER_MASK];
         pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);
      }

      pixels += 1;
   }
}

static float stbtt__oversample_shift(int oversample)
{
   if (!oversample)
      return 0.0f;

   /* The prefilter is a box filter of width "oversample", */
   /* which shifts phase by (oversample - 1)/2 pixels in */
   /* oversampled space. We want to shift in the opposite */
   /* direction to counter this. */
   return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

/* rects array must be big enough to accommodate all characters in the given ranges */
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k;

   k=0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      ranges[i].h_oversample = (unsigned char) spc->h_oversample;
      ranges[i].v_oversample = (unsigned char) spc->v_oversample;
      for (j=0; j < ranges[i].num_chars; ++j) {
         int x0,y0,x1,y1;
         int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
         int glyph = stbtt_FindGlyphIndex(info, codepoint);
         stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,
                                         scale * spc->h_oversample,
                                         scale * spc->v_oversample,
                                         0,0,
                                         &x0,&y0,&x1,&y1);
         rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);
         rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
         ++k;
      }
   }

   return k;
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)
{
   stbtt_MakeGlyphBitmapSubpixel(info,
                                 output,
                                 out_w - (prefilter_x - 1),
                                 out_h - (prefilter_y - 1),
                                 out_stride,
                                 scale_x,
                                 scale_y,
                                 shift_x,
                                 shift_y,
                                 glyph);

   if (prefilter_x > 1)
      stbtt__h_prefilter(output, out_w, out_h, out_stride, prefilter_x);

   if (prefilter_y > 1)
      stbtt__v_prefilter(output, out_w, out_h, out_stride, prefilter_y);

   *sub_x = stbtt__oversample_shift(prefilter_x);
   *sub_y = stbtt__oversample_shift(prefilter_y);
}

/* rects array must be big enough to accommodate all characters in the given ranges */
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
{
   int i,j,k, return_value = 1;

   /* save current values */
   int old_h_over = spc->h_oversample;
   int old_v_over = spc->v_oversample;

   k = 0;
   for (i=0; i < num_ranges; ++i) {
      float fh = ranges[i].font_size;
      float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
      float recip_h,recip_v,sub_x,sub_y;
      spc->h_oversample = ranges[i].h_oversample;
      spc->v_oversample = ranges[i].v_oversample;
      recip_h = 1.0f / spc->h_oversample;
      recip_v = 1.0f / spc->v_oversample;
      sub_x = stbtt__oversample_shift(spc->h_oversample);
      sub_y = stbtt__oversample_shift(spc->v_oversample);
      for (j=0; j < ranges[i].num_chars; ++j) {
         stbrp_rect *r = &rects[k];
         if (r->was_packed) {
            stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];
            int advance, lsb, x0,y0,x1,y1;
            int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
            int glyph = stbtt_FindGlyphIndex(info, codepoint);
            stbrp_coord pad = (stbrp_coord) spc->padding;

            /* pad on left and top */
            r->x += pad;
            r->y += pad;
            r->w -= pad;
            r->h -= pad;
            stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
            stbtt_GetGlyphBitmapBox(info, glyph,
                                    scale * spc->h_oversample,
                                    scale * spc->v_oversample,
                                    &x0,&y0,&x1,&y1);
            stbtt_MakeGlyphBitmapSubpixel(info,
                                          spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                          r->w - spc->h_oversample+1,
                                          r->h - spc->v_oversample+1,
                                          spc->stride_in_bytes,
                                          scale * spc->h_oversample,
                                          scale * spc->v_oversample,
                                          0,0,
                                          glyph);

            if (spc->h_oversample > 1)
               stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->h_oversample);

            if (spc->v_oversample > 1)
               stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,
                                  r->w, r->h, spc->stride_in_bytes,
                                  spc->v_oversample);

            bc->x0       = (stbtt_int16)  r->x;
            bc->y0       = (stbtt_int16)  r->y;
            bc->x1       = (stbtt_int16) (r->x + r->w);
            bc->y1       = (stbtt_int16) (r->y + r->h);
            bc->xadvance =                scale * advance;
            bc->xoff     =       (float)  x0 * recip_h + sub_x;
            bc->yoff     =       (float)  y0 * recip_v + sub_y;
            bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
            bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
         } else {
            return_value = 0; /* if any fail, report failure */
         }

         ++k;
      }
   }

   /* restore original values */
   spc->h_oversample = old_h_over;
   spc->v_oversample = old_v_over;

   return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
{
   stbrp_pack_rects((stbrp_context *) spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
{
   stbtt_fontinfo info;
   int i,j,n, return_value = 1;
   /* stbrp_context *context = (stbrp_context *) spc->pack_info; */
   stbrp_rect    *rects;

   /* flag all characters as NOT packed */
   for (i=0; i < num_ranges; ++i)
      for (j=0; j < ranges[i].num_chars; ++j)
         ranges[i].chardata_for_range[j].x0 =
         ranges[i].chardata_for_range[j].y0 =
         ranges[i].chardata_for_range[j].x1 =
         ranges[i].chardata_for_range[j].y1 = 0;

   n = 0;
   for (i=0; i < num_ranges; ++i)
      n += ranges[i].num_chars;

   rects = (stbrp_rect *) STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
   if (rects == NULL)
      return 0;

   info.userdata = spc->user_allocator_context;
   stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata,font_index));

   n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

   stbtt_PackFontRangesPackRects(spc, rects, n);

   return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

   STBTT_free(rects, spc->user_allocator_context);
   return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,
            int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
{
   stbtt_pack_range range;
   range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
   range.array_of_unicode_codepoints = NULL;
   range.num_chars                   = num_chars_in_range;
   range.chardata_for_range          = chardata_for_range;
   range.font_size                   = font_size;
   return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
{
   float ipw = 1.0f / pw, iph = 1.0f / ph;
   const stbtt_packedchar *b = chardata + char_index;

   if (align_to_integer) {
      float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);
      float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
      q->x0 = x;
      q->y0 = y;
      q->x1 = x + b->xoff2 - b->xoff;
      q->y1 = y + b->yoff2 - b->yoff;
   } else {
      q->x0 = *xpos + b->xoff;
      q->y0 = *ypos + b->yoff;
      q->x1 = *xpos + b->xoff2;
      q->y1 = *ypos + b->yoff2;
   }

   q->s0 = b->x0 * ipw;
   q->t0 = b->y0 * iph;
   q->s1 = b->x1 * ipw;
   q->t1 = b->y1 * iph;

   *xpos += b->xadvance;
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* sdf computation */
/*  */

#define STBTT_min(a,b)  ((a) < (b) ? (a) : (b))
#define STBTT_max(a,b)  ((a) < (b) ? (b) : (a))

static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])
{
   float q0perp = q0[1]*ray[0] - q0[0]*ray[1];
   float q1perp = q1[1]*ray[0] - q1[0]*ray[1];
   float q2perp = q2[1]*ray[0] - q2[0]*ray[1];
   float roperp = orig[1]*ray[0] - orig[0]*ray[1];

   float a = q0perp - 2*q1perp + q2perp;
   float b = q1perp - q0perp;
   float c = q0perp - roperp;

   float s0 = 0., s1 = 0.;
   int num_s = 0;

   if (a != 0.0) {
      float discr = b*b - a*c;
      if (discr > 0.0) {
         float rcpna = -1 / a;
         float d = (float) STBTT_sqrt(discr);
         s0 = (b+d) * rcpna;
         s1 = (b-d) * rcpna;
         if (s0 >= 0.0 && s0 <= 1.0)
            num_s = 1;
         if (d > 0.0 && s1 >= 0.0 && s1 <= 1.0) {
            if (num_s == 0) s0 = s1;
            ++num_s;
         }
      }
   } else {
      /* 2*b*s + c = 0 */
      /* s = -c / (2*b) */
      s0 = c / (-2 * b);
      if (s0 >= 0.0 && s0 <= 1.0)
         num_s = 1;
   }

   if (num_s == 0)
      return 0;
   else {
      float rcp_len2 = 1 / (ray[0]*ray[0] + ray[1]*ray[1]);
      float rayn_x = ray[0] * rcp_len2, rayn_y = ray[1] * rcp_len2;

      float q0d =   q0[0]*rayn_x +   q0[1]*rayn_y;
      float q1d =   q1[0]*rayn_x +   q1[1]*rayn_y;
      float q2d =   q2[0]*rayn_x +   q2[1]*rayn_y;
      float rod = orig[0]*rayn_x + orig[1]*rayn_y;

      float q10d = q1d - q0d;
      float q20d = q2d - q0d;
      float q0rd = q0d - rod;

      hits[0][0] = q0rd + s0*(2.0f - 2.0f*s0)*q10d + s0*s0*q20d;
      hits[0][1] = a*s0+b;

      if (num_s > 1) {
         hits[1][0] = q0rd + s1*(2.0f - 2.0f*s1)*q10d + s1*s1*q20d;
         hits[1][1] = a*s1+b;
         return 2;
      } else {
         return 1;
      }
   }
}

static int equal(float *a, float *b)
{
   return (a[0] == b[0] && a[1] == b[1]);
}

static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)
{
   int i;
   float orig[2], ray[2] = { 1, 0 };
   float y_frac;
   int winding = 0;

   orig[0] = x;
   orig[1] = y;

   /* make sure y never passes through a vertex of the shape */
   y_frac = (float) STBTT_fmod(y, 1.0f);
   if (y_frac < 0.01f)
      y += 0.01f;
   else if (y_frac > 0.99f)
      y -= 0.01f;
   orig[1] = y;

   /* test a ray from (-infinity,y) to (x,y) */
   for (i=0; i < nverts; ++i) {
      if (verts[i].type == STBTT_vline) {
         int x0 = (int) verts[i-1].x, y0 = (int) verts[i-1].y;
         int x1 = (int) verts[i  ].x, y1 = (int) verts[i  ].y;
         if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
            float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
            if (x_inter < x)
               winding += (y0 < y1) ? 1 : -1;
         }
      }
      if (verts[i].type == STBTT_vcurve) {
         int x0 = (int) verts[i-1].x , y0 = (int) verts[i-1].y ;
         int x1 = (int) verts[i  ].cx, y1 = (int) verts[i  ].cy;
         int x2 = (int) verts[i  ].x , y2 = (int) verts[i  ].y ;
         int ax = STBTT_min(x0,STBTT_min(x1,x2)), ay = STBTT_min(y0,STBTT_min(y1,y2));
         int by = STBTT_max(y0,STBTT_max(y1,y2));
         if (y > ay && y < by && x > ax) {
            float q0[2],q1[2],q2[2];
            float hits[2][2];
            q0[0] = (float)x0;
            q0[1] = (float)y0;
            q1[0] = (float)x1;
            q1[1] = (float)y1;
            q2[0] = (float)x2;
            q2[1] = (float)y2;
            if (equal(q0,q1) || equal(q1,q2)) {
               x0 = (int)verts[i-1].x;
               y0 = (int)verts[i-1].y;
               x1 = (int)verts[i  ].x;
               y1 = (int)verts[i  ].y;
               if (y > STBTT_min(y0,y1) && y < STBTT_max(y0,y1) && x > STBTT_min(x0,x1)) {
                  float x_inter = (y - y0) / (y1 - y0) * (x1-x0) + x0;
                  if (x_inter < x)
                     winding += (y0 < y1) ? 1 : -1;
               }
            } else {
               int num_hits = stbtt__ray_intersect_bezier(orig, ray, q0, q1, q2, hits);
               if (num_hits >= 1)
                  if (hits[0][0] < 0)
                     winding += (hits[0][1] < 0 ? -1 : 1);
               if (num_hits >= 2)
                  if (hits[1][0] < 0)
                     winding += (hits[1][1] < 0 ? -1 : 1);
            }
         }
      }
   }
   return winding;
}

static float stbtt__cuberoot( float x )
{
   if (x<0)
      return -(float) STBTT_pow(-x,1.0f/3.0f);
   else
      return  (float) STBTT_pow( x,1.0f/3.0f);
}

/* x^3 + c*x^2 + b*x + a = 0 */
static int stbtt__solve_cubic(float a, float b, float c, float* r)
{
    float s = -a / 3;
    float p = b - a*a / 3;
    float q = a * (2*a*a - 9*b) / 27 + c;
   float p3 = p*p*p;
    float d = q*q + 4*p3 / 27;
    if (d >= 0) {
        float z = (float) STBTT_sqrt(d);
        float u = (-q + z) / 2;
        float v = (-q - z) / 2;
        u = stbtt__cuberoot(u);
        v = stbtt__cuberoot(v);
        r[0] = s + u + v;
        return 1;
    } else {
       float u = (float) STBTT_sqrt(-p/3);
       float v = (float) STBTT_acos(-STBTT_sqrt(-27/p3) * q / 2) / 3; /* p3 must be negative, since d is negative */
       float m = (float) STBTT_cos(v);
      float n = (float) STBTT_cos(v-3.141592/2)*1.732050808f;
       r[0] = s + u * 2 * m;
       r[1] = s - u * (m + n);
       r[2] = s - u * (m - n);

      /* STBTT_assert( STBTT_fabs(((r[0]+a)*r[0]+b)*r[0]+c) < 0.05f);  // these asserts may not be safe at all scales, though they're in bezier t parameter units so maybe? */
      /* STBTT_assert( STBTT_fabs(((r[1]+a)*r[1]+b)*r[1]+c) < 0.05f); */
      /* STBTT_assert( STBTT_fabs(((r[2]+a)*r[2]+b)*r[2]+c) < 0.05f); */
    return 3;
   }
}

STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   float scale_x = scale, scale_y = scale;
   int ix0,iy0,ix1,iy1;
   int w,h;
   unsigned char *data;

   /* if one scale is 0, use same scale for both */
   if (scale_x == 0) scale_x = scale_y;
   if (scale_y == 0) {
      if (scale_x == 0) return NULL;  /* if both scales are 0, return NULL */
      scale_y = scale_x;
   }

   stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale, scale, 0.0f,0.0f, &ix0,&iy0,&ix1,&iy1);

   /* if empty, return NULL */
   if (ix0 == ix1 || iy0 == iy1)
      return NULL;

   ix0 -= padding;
   iy0 -= padding;
   ix1 += padding;
   iy1 += padding;

   w = (ix1 - ix0);
   h = (iy1 - iy0);

   if (width ) *width  = w;
   if (height) *height = h;
   if (xoff  ) *xoff   = ix0;
   if (yoff  ) *yoff   = iy0;

   /* invert for y-downwards bitmaps */
   scale_y = -scale_y;

   {
      int x,y,i,j;
      float *precompute;
      stbtt_vertex *verts;
      int num_verts = stbtt_GetGlyphShape(info, glyph, &verts);
      data = (unsigned char *) STBTT_malloc(w * h, info->userdata);
      precompute = (float *) STBTT_malloc(num_verts * sizeof(float), info->userdata);

      for (i=0,j=num_verts-1; i < num_verts; j=i++) {
         if (verts[i].type == STBTT_vline) {
            float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;
            float x1 = verts[j].x*scale_x, y1 = verts[j].y*scale_y;
            float dist = (float) STBTT_sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0));
            precompute[i] = (dist == 0) ? 0.0f : 1.0f / dist;
         } else if (verts[i].type == STBTT_vcurve) {
            float x2 = verts[j].x *scale_x, y2 = verts[j].y *scale_y;
            float x1 = verts[i].cx*scale_x, y1 = verts[i].cy*scale_y;
            float x0 = verts[i].x *scale_x, y0 = verts[i].y *scale_y;
            float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
            float len2 = bx*bx + by*by;
            if (len2 != 0.0f)
               precompute[i] = 1.0f / (bx*bx + by*by);
            else
               precompute[i] = 0.0f;
         } else
            precompute[i] = 0.0f;
      }

      for (y=iy0; y < iy1; ++y) {
         for (x=ix0; x < ix1; ++x) {
            float val;
            float min_dist = 999999.0f;
            float sx = (float) x + 0.5f;
            float sy = (float) y + 0.5f;
            float x_gspace = (sx / scale_x);
            float y_gspace = (sy / scale_y);

            int winding = stbtt__compute_crossings_x(x_gspace, y_gspace, num_verts, verts); /* @OPTIMIZE: this could just be a rasterization, but needs to be line vs. non-tesselated curves so a new path */

            for (i=0; i < num_verts; ++i) {
               float x0 = verts[i].x*scale_x, y0 = verts[i].y*scale_y;

               /* check against every point here rather than inside line/curve primitives -- @TODO: wrong if multiple 'moves' in a row produce a garbage point, and given culling, probably more efficient to do within line/curve */
               float dist2 = (x0-sx)*(x0-sx) + (y0-sy)*(y0-sy);
               if (dist2 < min_dist*min_dist)
                  min_dist = (float) STBTT_sqrt(dist2);

               if (verts[i].type == STBTT_vline) {
                  float x1 = verts[i-1].x*scale_x, y1 = verts[i-1].y*scale_y;

                  /* coarse culling against bbox */
                  /* if (sx > STBTT_min(x0,x1)-min_dist && sx < STBTT_max(x0,x1)+min_dist && */
                  /* sy > STBTT_min(y0,y1)-min_dist && sy < STBTT_max(y0,y1)+min_dist) */
                  float dist = (float) STBTT_fabs((x1-x0)*(y0-sy) - (y1-y0)*(x0-sx)) * precompute[i];
                  STBTT_assert(i != 0);
                  if (dist < min_dist) {
                     /* check position along line */
                     /* x' = x0 + t*(x1-x0), y' = y0 + t*(y1-y0) */
                     /* minimize (x'-sx)*(x'-sx)+(y'-sy)*(y'-sy) */
                     float dx = x1-x0, dy = y1-y0;
                     float px = x0-sx, py = y0-sy;
                     /* minimize (px+t*dx)^2 + (py+t*dy)^2 = px*px + 2*px*dx*t + t^2*dx*dx + py*py + 2*py*dy*t + t^2*dy*dy */
                     /* derivative: 2*px*dx + 2*py*dy + (2*dx*dx+2*dy*dy)*t, set to 0 and solve */
                     float t = -(px*dx + py*dy) / (dx*dx + dy*dy);
                     if (t >= 0.0f && t <= 1.0f)
                        min_dist = dist;
                  }
               } else if (verts[i].type == STBTT_vcurve) {
                  float x2 = verts[i-1].x *scale_x, y2 = verts[i-1].y *scale_y;
                  float x1 = verts[i  ].cx*scale_x, y1 = verts[i  ].cy*scale_y;
                  float box_x0 = STBTT_min(STBTT_min(x0,x1),x2);
                  float box_y0 = STBTT_min(STBTT_min(y0,y1),y2);
                  float box_x1 = STBTT_max(STBTT_max(x0,x1),x2);
                  float box_y1 = STBTT_max(STBTT_max(y0,y1),y2);
                  /* coarse culling against bbox to avoid computing cubic unnecessarily */
                  if (sx > box_x0-min_dist && sx < box_x1+min_dist && sy > box_y0-min_dist && sy < box_y1+min_dist) {
                     int num=0;
                     float ax = x1-x0, ay = y1-y0;
                     float bx = x0 - 2*x1 + x2, by = y0 - 2*y1 + y2;
                     float mx = x0 - sx, my = y0 - sy;
                     float res[3],px,py,t,it;
                     float a_inv = precompute[i];
                     if (a_inv == 0.0) { /* if a_inv is 0, it's 2nd degree so use quadratic formula */
                        float a = 3*(ax*bx + ay*by);
                        float b = 2*(ax*ax + ay*ay) + (mx*bx+my*by);
                        float c = mx*ax+my*ay;
                        if (a == 0.0) { /* if a is 0, it's linear */
                           if (b != 0.0) {
                              res[num++] = -c/b;
                           }
                        } else {
                           float discriminant = b*b - 4*a*c;
                           if (discriminant < 0)
                              num = 0;
                           else {
                              float root = (float) STBTT_sqrt(discriminant);
                              res[0] = (-b - root)/(2*a);
                              res[1] = (-b + root)/(2*a);
                              num = 2; /* don't bother distinguishing 1-solution case, as code below will still work */
                           }
                        }
                     } else {
                        float b = 3*(ax*bx + ay*by) * a_inv; /* could precompute this as it doesn't depend on sample point */
                        float c = (2*(ax*ax + ay*ay) + (mx*bx+my*by)) * a_inv;
                        float d = (mx*ax+my*ay) * a_inv;
                        num = stbtt__solve_cubic(b, c, d, res);
                     }
                     if (num >= 1 && res[0] >= 0.0f && res[0] <= 1.0f) {
                        t = res[0], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 2 && res[1] >= 0.0f && res[1] <= 1.0f) {
                        t = res[1], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                     if (num >= 3 && res[2] >= 0.0f && res[2] <= 1.0f) {
                        t = res[2], it = 1.0f - t;
                        px = it*it*x0 + 2*t*it*x1 + t*t*x2;
                        py = it*it*y0 + 2*t*it*y1 + t*t*y2;
                        dist2 = (px-sx)*(px-sx) + (py-sy)*(py-sy);
                        if (dist2 < min_dist * min_dist)
                           min_dist = (float) STBTT_sqrt(dist2);
                     }
                  }
               }
            }
            if (winding == 0)
               min_dist = -min_dist;  /* if outside the shape, value is negative */
            val = onedge_value + pixel_dist_scale * min_dist;
            if (val < 0)
               val = 0;
            else if (val > 255)
               val = 255;
            data[(y-iy0)*w+(x-ix0)] = (unsigned char) val;
         }
      }
      STBTT_free(precompute, info->userdata);
      STBTT_free(verts, info->userdata);
   }
   return data;
}

STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)
{
   return stbtt_GetGlyphSDF(info, scale, stbtt_FindGlyphIndex(info, codepoint), padding, onedge_value, pixel_dist_scale, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)
{
   STBTT_free(bitmap, userdata);
}

/* //////////////////////////////////////////////////////////////////////////// */
/*  */
/* font name matching -- recommended not to use this */
/*  */

/* check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string */
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
{
   stbtt_int32 i=0;

   /* convert utf16 to utf8 and compare the results while converting */
   while (len2) {
      stbtt_uint16 ch = s2[0]*256 + s2[1];
      if (ch < 0x80) {
         if (i >= len1) return -1;
         if (s1[i++] != ch) return -1;
      } else if (ch < 0x800) {
         if (i+1 >= len1) return -1;
         if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
         if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
      } else if (ch >= 0xd800 && ch < 0xdc00) {
         stbtt_uint32 c;
         stbtt_uint16 ch2 = s2[2]*256 + s2[3];
         if (i+3 >= len1) return -1;
         c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
         if (s1[i++] != 0xf0 + (c >> 18)) return -1;
         if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c >>  6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((c      ) & 0x3f)) return -1;
         s2 += 2; /* plus another 2 below */
         len2 -= 2;
      } else if (ch >= 0xdc00 && ch < 0xe000) {
         return -1;
      } else {
         if (i+2 >= len1) return -1;
         if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
         if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
         if (s1[i++] != 0x80 + ((ch     ) & 0x3f)) return -1;
      }
      s2 += 2;
      len2 -= 2;
   }
   return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2)
{
   return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*) s1, len1, (stbtt_uint8*) s2, len2);
}

/* returns results in whatever encoding you request... but note that 2-byte encodings */
/* will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare */
STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
{
   stbtt_int32 i,count,stringOffset;
   stbtt_uint8 *fc = font->data;
   stbtt_uint32 offset = font->fontstart;
   stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return NULL;

   count = ttUSHORT(fc+nm+2);
   stringOffset = nm + ttUSHORT(fc+nm+4);
   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      if (platformID == ttUSHORT(fc+loc+0) && encodingID == ttUSHORT(fc+loc+2)
          && languageID == ttUSHORT(fc+loc+4) && nameID == ttUSHORT(fc+loc+6)) {
         *length = ttUSHORT(fc+loc+8);
         return (const char *) (fc+stringOffset+ttUSHORT(fc+loc+10));
      }
   }
   return NULL;
}

static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
   stbtt_int32 i;
   stbtt_int32 count = ttUSHORT(fc+nm+2);
   stbtt_int32 stringOffset = nm + ttUSHORT(fc+nm+4);

   for (i=0; i < count; ++i) {
      stbtt_uint32 loc = nm + 6 + 12 * i;
      stbtt_int32 id = ttUSHORT(fc+loc+6);
      if (id == target_id) {
         /* find the encoding */
         stbtt_int32 platform = ttUSHORT(fc+loc+0), encoding = ttUSHORT(fc+loc+2), language = ttUSHORT(fc+loc+4);

         /* is this a Unicode encoding? */
         if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
            stbtt_int32 slen = ttUSHORT(fc+loc+8);
            stbtt_int32 off = ttUSHORT(fc+loc+10);

            /* check if there's a prefix match */
            stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc+stringOffset+off,slen);
            if (matchlen >= 0) {
               /* check for target_id+1 immediately following, with same encoding & language */
               if (i+1 < count && ttUSHORT(fc+loc+12+6) == next_id && ttUSHORT(fc+loc+12) == platform && ttUSHORT(fc+loc+12+2) == encoding && ttUSHORT(fc+loc+12+4) == language) {
                  slen = ttUSHORT(fc+loc+12+8);
                  off = ttUSHORT(fc+loc+12+10);
                  if (slen == 0) {
                     if (matchlen == nlen)
                        return 1;
                  } else if (matchlen < nlen && name[matchlen] == ' ') {
                     ++matchlen;
                     if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*) (name+matchlen), nlen-matchlen, (char*)(fc+stringOffset+off),slen))
                        return 1;
                  }
               } else {
                  /* if nothing immediately following */
                  if (matchlen == nlen)
                     return 1;
               }
            }
         }

         /* @TODO handle other encodings */
      }
   }
   return 0;
}

static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
{
   stbtt_int32 nlen = (stbtt_int32) STBTT_strlen((char *) name);
   stbtt_uint32 nm,hd;
   if (!stbtt__isfont(fc+offset)) return 0;

   /* check italics/bold/underline flags in macStyle... */
   if (flags) {
      hd = stbtt__find_table(fc, offset, "head");
      if ((ttUSHORT(fc+hd+44) & 7) != (flags & 7)) return 0;
   }

   nm = stbtt__find_table(fc, offset, "name");
   if (!nm) return 0;

   if (flags) {
      /* if we checked the macStyle flags, then just check the family and ignore the subfamily */
      if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1, -1))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   } else {
      if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  1,  2))  return 1;
      if (stbtt__matchpair(fc, nm, name, nlen,  3, -1))  return 1;
   }

   return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
{
   stbtt_int32 i;
   for (i=0;;++i) {
      stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
      if (off < 0) return off;
      if (stbtt__matches((stbtt_uint8 *) font_collection, off, (stbtt_uint8*) name_utf8, flags))
         return off;
   }
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,
                                float pixel_height, unsigned char *pixels, int pw, int ph,
                                int first_char, int num_chars, stbtt_bakedchar *chardata)
{
   return stbtt_BakeFontBitmap_internal((unsigned char *) data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)
{
   return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)
{
   return stbtt_GetNumberOfFonts_internal((unsigned char *) data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)
{
   return stbtt_InitFont_internal(info, (unsigned char *) data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)
{
   return stbtt_FindMatchingFont_internal((unsigned char *) fontdata, (char *) name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)
{
   return stbtt_CompareUTF8toUTF16_bigendian_internal((char *) s1, len1, (char *) s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif /* STB_TRUETYPE_IMPLEMENTATION */


/* FULL VERSION HISTORY */
/*  */
/* 1.19 (2018-02-11) OpenType GPOS kerning (horizontal only), STBTT_fmod */
/* 1.18 (2018-01-29) add missing function */
/* 1.17 (2017-07-23) make more arguments const; doc fix */
/* 1.16 (2017-07-12) SDF support */
/* 1.15 (2017-03-03) make more arguments const */
/* 1.14 (2017-01-16) num-fonts-in-TTC function */
/* 1.13 (2017-01-02) support OpenType fonts, certain Apple fonts */
/* 1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual */
/* 1.11 (2016-04-02) fix unused-variable warning */
/* 1.10 (2016-04-02) allow user-defined fabs() replacement */
/* fix memory leak if fontsize=0.0 */
/* fix warning from duplicate typedef */
/* 1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges */
/* 1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges */
/* 1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints; */
/* allow PackFontRanges to pack and render in separate phases; */
/* fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?); */
/* fixed an assert() bug in the new rasterizer */
/* replace assert() with STBTT_assert() in new rasterizer */
/* 1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine) */
/* also more precise AA rasterizer, except if shapes overlap */
/* remove need for STBTT_sort */
/* 1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC */
/* 1.04 (2015-04-15) typo in example */
/* 1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes */
/* 1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++ */
/* 1.01 (2014-12-08) fix subpixel position when oversampling to exactly match */
/* non-oversampled; STBTT_POINT_SIZE for packed case only */
/* 1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling */
/* 0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg) */
/* 0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID */
/* 0.8b (2014-07-07) fix a warning */
/* 0.8  (2014-05-25) fix a few more warnings */
/* 0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back */
/* 0.6c (2012-07-24) improve documentation */
/* 0.6b (2012-07-20) fix a few more warnings */
/* 0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels, */
/* stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty */
/* 0.5  (2011-12-09) bugfixes: */
/* subpixel glyph renderer computed wrong bounding box */
/* first vertex of shape can be off-curve (FreeSans) */
/* 0.4b (2011-12-03) fixed an error in the font baking example */
/* 0.4  (2011-12-01) kerning, subpixel rendering (tor) */
/* bugfixes for: */
/* codepoint-to-glyph conversion using table fmt=12 */
/* codepoint-to-glyph conversion using table fmt=4 */
/* stbtt_GetBakedQuad with non-square texture (Zer) */
/* updated Hello World! sample to use kerning and subpixel */
/* fixed some warnings */
/* 0.3  (2009-06-24) cmap fmt=12, compound shapes (MM) */
/* userdata, malloc-from-userdata, non-zero fill (stb) */
/* 0.2  (2009-03-11) Fix unsigned/signed char warnings */
/* 0.1  (2009-03-09) First public release */
/*  */

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
/* This file was generated automatically. Do not edit. */
#ifndef DATA_DECLARATION_ONLY

#ifdef __cplusplus
extern "C" {
#endif

unsigned char font_buffer_profont[46628] = {
	0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x46, 0x46, 0x54, 0x4d, 
	0x65, 0x58, 0x7e, 0x4f, 0x00, 0x00, 0xb6, 0x08, 0x00, 0x00, 0x00, 0x1c, 0x47, 0x44, 0x45, 0x46, 
	0x00, 0x27, 0x01, 0x43, 0x00, 0x00, 0xb5, 0xe0, 0x00, 0x00, 0x00, 0x26, 0x4f, 0x53, 0x2f, 0x32, 
	0x70, 0xeb, 0x4a, 0x22, 0x00, 0x00, 0x01, 0x88, 0x00, 0x00, 0x00, 0x56, 0x63, 0x6d, 0x61, 0x70, 
	0xe5, 0x63, 0xe7, 0x25, 0x00, 0x00, 0x04, 0x24, 0x00, 0x00, 0x02, 0x9a, 0x63, 0x76, 0x74, 0x20, 
	0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x08, 0x28, 0x00, 0x00, 0x00, 0x02, 0x66, 0x70, 0x67, 0x6d, 
	0x32, 0x44, 0x73, 0x5d, 0x00, 0x00, 0x06, 0xc0, 0x00, 0x00, 0x01, 0x62, 0x67, 0x61, 0x73, 0x70, 
	0x00, 0x1b, 0x00, 0x09, 0x00, 0x00, 0xb5, 0xd0, 0x00, 0x00, 0x00, 0x10, 0x67, 0x6c, 0x79, 0x66, 
	0xad, 0xa2, 0x05, 0xa7, 0x00, 0x00, 0x0a, 0x68, 0x00, 0x00, 0xa4, 0x7c, 0x68, 0x65, 0x61, 0x64, 
	0xf2, 0xc0, 0x76, 0x1c, 0x00, 0x00, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x36, 0x68, 0x68, 0x65, 0x61, 
	0x05, 0xdf, 0x01, 0x11, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00, 0x00, 0x24, 0x68, 0x6d, 0x74, 0x78, 
	0x19, 0xfe, 0x11, 0xbe, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x02, 0x42, 0x6c, 0x6f, 0x63, 0x61, 
	0x2f, 0xda, 0x5a, 0x4e, 0x00, 0x00, 0x08, 0x2c, 0x00, 0x00, 0x02, 0x3c, 0x6d, 0x61, 0x78, 0x70, 
	0x03, 0x3a, 0x06, 0xd4, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x20, 0x6e, 0x61, 0x6d, 0x65, 
	0x68, 0x33, 0x1d, 0xe4, 0x00, 0x00, 0xae, 0xe4, 0x00, 0x00, 0x02, 0x85, 0x70, 0x6f, 0x73, 0x74, 
	0x59, 0x99, 0x30, 0x29, 0x00, 0x00, 0xb1, 0x6c, 0x00, 0x00, 0x04, 0x64, 0x70, 0x72, 0x65, 0x70, 
	0xb8, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x08, 0x24, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x02, 0x4c, 0xcc, 0xbf, 0x79, 0x2e, 0x82, 0x5f, 0x0f, 0x3c, 0xf5, 0x00, 0x1f, 0x04, 0xb0, 
	0x00, 0x00, 0x00, 0x00, 0xbc, 0x1e, 0xe1, 0x31, 0x00, 0x00, 0x00, 0x00, 0xd5, 0x15, 0x03, 0xf7, 
	0xff, 0xe0, 0xfe, 0xd4, 0x02, 0x78, 0x03, 0xa7, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x84, 0xfe, 0xd4, 0x00, 0x00, 0x02, 0x58, 
	0xff, 0xe0, 0xff, 0xe0, 0x02, 0x78, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x01, 0x1d, 0x00, 0x90, 
	0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 
	0x02, 0x00, 0x06, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x58, 0x01, 0x90, 0x00, 0x05, 
	0x00, 0x00, 0x01, 0x71, 0x01, 0x57, 0x00, 0x00, 0x00, 0x4c, 0x01, 0x71, 0x01, 0x57, 0x00, 0x00, 
	0x00, 0xef, 0x00, 0x3c, 0x01, 0x2c, 0x08, 0x05, 0x02, 0x00, 0x04, 0x09, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x23, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x55, 0x4e, 0x4b, 0x4e, 0x00, 0x40, 0x00, 0x20, 0xe0, 0xb3, 0x03, 0x84, 0xfe, 0xd4, 
	0x00, 0x00, 0x03, 0x84, 0x01, 0x2c, 0x40, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x58, 0x00, 0x00, 0x02, 0x58, 0x00, 0x00, 
	0x00, 0xc8, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x64, 
	0x00, 0x51, 0x00, 0x07, 0x00, 0x00, 0x00, 0x7d, 0x00, 0x64, 0x00, 0x96, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x96, 0x00, 0x7d, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x4b, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x23, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0x51, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0xc8, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 
	0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x64, 0x00, 0x00, 
	0x00, 0x96, 0x00, 0x96, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x57, 0x00, 0x96, 
	0x00, 0x64, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x64, 0x00, 0x57, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 
	0x00, 0x55, 0x00, 0x69, 0x00, 0xcd, 0x00, 0x69, 0x00, 0x64, 0x00, 0x00, 0x00, 0x05, 0x00, 0x64, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0xd1, 0x00, 0x09, 0x00, 0x64, 0x00, 0x6d, 0x00, 0x09, 
	0x00, 0x64, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0xc8, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 
	0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0xc8, 
	0x00, 0x64, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x64, 0x00, 0x64, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x64, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x46, 0x00, 0x00, 0xff, 0xe0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1c, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x94, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 
	0x00, 0x04, 0x01, 0x78, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x40, 0x00, 0x05, 0x00, 0x1a, 0x00, 0x7e, 
	0x00, 0xff, 0x01, 0x31, 0x01, 0x53, 0x01, 0x61, 0x01, 0x78, 0x01, 0x7e, 0x01, 0x92, 0x02, 0xc7, 
	0x02, 0xc9, 0x02, 0xdd, 0x03, 0xbc, 0x20, 0x10, 0x20, 0x14, 0x20, 0x1a, 0x20, 0x1e, 0x20, 0x22, 
	0x20, 0x26, 0x20, 0x30, 0x20, 0x3a, 0x20, 0xac, 0x21, 0x22, 0x22, 0x12, 0x22, 0x19, 0x23, 0x10, 
	0x25, 0x00, 0x25, 0x02, 0x25, 0x0c, 0x25, 0x10, 0x25, 0x14, 0x25, 0x18, 0x25, 0x1c, 0x25, 0x24, 
	0x25, 0x2c, 0x25, 0x34, 0x25, 0x3c, 0x25, 0x6c, 0x25, 0x80, 0x25, 0x84, 0x25, 0x88, 0x25, 0x8c, 
	0x25, 0x93, 0xe0, 0xa2, 0xe0, 0xb3, 0xff, 0xff, 0x00, 0x00, 0x00, 0x20, 0x00, 0xa0, 0x01, 0x31, 
	0x01, 0x52, 0x01, 0x60, 0x01, 0x78, 0x01, 0x7d, 0x01, 0x92, 0x02, 0xc6, 0x02, 0xc9, 0x02, 0xd8, 
	0x03, 0xbc, 0x20, 0x10, 0x20, 0x13, 0x20, 0x17, 0x20, 0x1c, 0x20, 0x20, 0x20, 0x26, 0x20, 0x30, 
	0x20, 0x39, 0x20, 0xac, 0x21, 0x22, 0x22, 0x12, 0x22, 0x19, 0x23, 0x10, 0x25, 0x00, 0x25, 0x02, 
	0x25, 0x0c, 0x25, 0x10, 0x25, 0x14, 0x25, 0x18, 0x25, 0x1c, 0x25, 0x24, 0x25, 0x2c, 0x25, 0x34, 
	0x25, 0x3c, 0x25, 0x50, 0x25, 0x80, 0x25, 0x84, 0x25, 0x88, 0x25, 0x8c, 0x25, 0x90, 0xe0, 0xa0, 
	0xe0, 0xb0, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xc2, 0xff, 0x91, 0xff, 0x71, 0xff, 0x65, 0xff, 0x4f, 
	0xff, 0x4b, 0xff, 0x38, 0xfe, 0x05, 0xfd, 0xa8, 0xfd, 0xf5, 0xfc, 0xbb, 0xe0, 0x00, 0xe0, 0xc0, 
	0xe0, 0xbe, 0xe0, 0xbd, 0xe0, 0xbc, 0xe0, 0xb9, 0xe0, 0xb0, 0xe0, 0xa8, 0xe0, 0x37, 0xdf, 0xc2, 
	0xde, 0x5d, 0xde, 0x60, 0xdd, 0xd5, 0xdb, 0xe6, 0xdb, 0xe5, 0xdb, 0xdc, 0xdb, 0xd9, 0xdb, 0xd6, 
	0xdb, 0xd3, 0xdb, 0xd0, 0xdb, 0xc9, 0xdb, 0xc2, 0xdb, 0xbb, 0xdb, 0xb4, 0xdb, 0xa1, 0xdb, 0x8e, 
	0xdb, 0x8b, 0xdb, 0x88, 0xdb, 0x85, 0xdb, 0x82, 0x20, 0x76, 0x20, 0x69, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x01, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x04, 
	0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 
	0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 
	0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 
	0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 
	0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 
	0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x00, 0x86, 0x87, 
	0x89, 0x8b, 0x93, 0x98, 0x9e, 0xa3, 0xa2, 0xa4, 0xa6, 0xa5, 0xa7, 0xa9, 0xab, 0xaa, 0xac, 0xad, 
	0xaf, 0xae, 0xb0, 0xb1, 0xb3, 0xb5, 0xb4, 0xb6, 0xb8, 0xb7, 0xbc, 0xbb, 0xbd, 0xbe, 0xdc, 0x72, 
	0x64, 0x65, 0x69, 0xde, 0x78, 0xa1, 0x70, 0x6b, 0xe4, 0x76, 0x6a, 0x00, 0x88, 0x9a, 0x00, 0x73, 
	0x00, 0x00, 0x67, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x7c, 0x00, 0xa8, 0xba, 0x81, 0x63, 
	0x6e, 0x00, 0xca, 0x00, 0x00, 0x6d, 0x7d, 0xdf, 0x62, 0x82, 0x85, 0x97, 0xc3, 0xc4, 0xd3, 0xd4, 
	0xd9, 0xda, 0xd6, 0xd7, 0xb9, 0x00, 0xc1, 0xc7, 0x00, 0xe3, 0xe1, 0xe2, 0x00, 0x00, 0xdd, 0x79, 
	0xd8, 0xdb, 0xe0, 0x84, 0x8c, 0x83, 0x8d, 0x8a, 0x8f, 0x90, 0x91, 0x8e, 0x95, 0x96, 0x00, 0x94, 
	0x9c, 0x9d, 0x9b, 0xc2, 0xcb, 0xd1, 0x71, 0xcd, 0xce, 0xcf, 0x7a, 0xd2, 0xd0, 0xcc, 0x00, 0x00, 
	0xb8, 0x00, 0x00, 0x2c, 0x4b, 0xb8, 0x00, 0x00, 0x50, 0x58, 0xb1, 0x01, 0x01, 0x8e, 0x59, 0xb8, 
	0x01, 0xff, 0x85, 0xb8, 0x00, 0x44, 0x1d, 0xb9, 0x00, 0x00, 0x00, 0x03, 0x5f, 0x5e, 0x2d, 0xb8, 
	0x00, 0x01, 0x2c, 0x20, 0x20, 0x45, 0x69, 0x44, 0xb0, 0x01, 0x60, 0x2d, 0xb8, 0x00, 0x02, 0x2c, 
	0xb8, 0x00, 0x01, 0x2a, 0x21, 0x2d, 0xb8, 0x00, 0x03, 0x2c, 0x20, 0x46, 0xb0, 0x03, 0x25, 0x46, 
	0x52, 0x58, 0x23, 0x59, 0x20, 0x8a, 0x20, 0x8a, 0x49, 0x64, 0x8a, 0x20, 0x46, 0x20, 0x68, 0x61, 
	0x64, 0xb0, 0x04, 0x25, 0x46, 0x20, 0x68, 0x61, 0x64, 0x52, 0x58, 0x23, 0x65, 0x8a, 0x59, 0x2f, 
	0x20, 0xb0, 0x00, 0x53, 0x58, 0x69, 0x20, 0xb0, 0x00, 0x54, 0x58, 0x21, 0xb0, 0x40, 0x59, 0x1b, 
	0x69, 0x20, 0xb0, 0x00, 0x54, 0x58, 0x21, 0xb0, 0x40, 0x65, 0x59, 0x59, 0x3a, 0x2d, 0xb8, 0x00, 
	0x04, 0x2c, 0x20, 0x46, 0xb0, 0x04, 0x25, 0x46, 0x52, 0x58, 0x23, 0x8a, 0x59, 0x20, 0x46, 0x20, 
	0x6a, 0x61, 0x64, 0xb0, 0x04, 0x25, 0x46, 0x20, 0x6a, 0x61, 0x64, 0x52, 0x58, 0x23, 0x8a, 0x59, 
	0x2f, 0xfd, 0x2d, 0xb8, 0x00, 0x05, 0x2c, 0x4b, 0x20, 0xb0, 0x03, 0x26, 0x50, 0x58, 0x51, 0x58, 
	0xb0, 0x80, 0x44, 0x1b, 0xb0, 0x40, 0x44, 0x59, 0x1b, 0x21, 0x21, 0x20, 0x45, 0xb0, 0xc0, 0x50, 
	0x58, 0xb0, 0xc0, 0x44, 0x1b, 0x21, 0x59, 0x59, 0x2d, 0xb8, 0x00, 0x06, 0x2c, 0x20, 0x20, 0x45, 
	0x69, 0x44, 0xb0, 0x01, 0x60, 0x20, 0x20, 0x45, 0x7d, 0x69, 0x18, 0x44, 0xb0, 0x01, 0x60, 0x2d, 
	0xb8, 0x00, 0x07, 0x2c, 0xb8, 0x00, 0x06, 0x2a, 0x2d, 0xb8, 0x00, 0x08, 0x2c, 0x4b, 0x20, 0xb0, 
	0x03, 0x26, 0x53, 0x58, 0xb0, 0x80, 0x1b, 0xb0, 0x40, 0x59, 0x8a, 0x8a, 0x20, 0xb0, 0x03, 0x26, 
	0x53, 0x58, 0x23, 0x21, 0xb0, 0xc0, 0x8a, 0x8a, 0x1b, 0x8a, 0x23, 0x59, 0x20, 0xb0, 0x03, 0x26, 
	0x53, 0x58, 0x23, 0x21, 0xb8, 0x01, 0x00, 0x8a, 0x8a, 0x1b, 0x8a, 0x23, 0x59, 0x20, 0xb0, 0x03, 
	0x26, 0x53, 0x58, 0x23, 0x21, 0xb8, 0x01, 0x40, 0x8a, 0x8a, 0x1b, 0x8a, 0x23, 0x59, 0x20, 0xb8, 
	0x00, 0x03, 0x26, 0x53, 0x58, 0xb0, 0x03, 0x25, 0x45, 0xb8, 0x01, 0x80, 0x50, 0x58, 0x23, 0x21, 
	0xb8, 0x01, 0x80, 0x23, 0x21, 0x1b, 0xb0, 0x03, 0x25, 0x45, 0x23, 0x21, 0x23, 0x21, 0x59, 0x1b, 
	0x21, 0x59, 0x44, 0x2d, 0xb8, 0x00, 0x09, 0x2c, 0x4b, 0x53, 0x58, 0x45, 0x44, 0x1b, 0x21, 0x21, 
	0x59, 0x2d, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x2b, 0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 
	0x00, 0x3a, 0x00, 0x3a, 0x00, 0x3a, 0x00, 0x66, 0x00, 0x94, 0x01, 0x24, 0x01, 0xee, 0x02, 0x50, 
	0x02, 0xa2, 0x02, 0xba, 0x02, 0xda, 0x02, 0xf8, 0x03, 0x20, 0x03, 0x56, 0x03, 0x74, 0x03, 0x8a, 
	0x03, 0xd2, 0x03, 0xe8, 0x04, 0x3a, 0x04, 0x70, 0x04, 0xd8, 0x05, 0x72, 0x05, 0xba, 0x06, 0x18, 
	0x06, 0x76, 0x06, 0xa8, 0x07, 0x80, 0x07, 0xda, 0x08, 0x08, 0x08, 0x38, 0x08, 0x52, 0x08, 0x74, 
	0x08, 0x8e, 0x08, 0xf6, 0x09, 0xa4, 0x09, 0xec, 0x0a, 0x7a, 0x0a, 0xd0, 0x0b, 0x14, 0x0b, 0x48, 
	0x0b, 0x76, 0x0b, 0xd4, 0x0c, 0x12, 0x0c, 0x44, 0x0c, 0x7e, 0x0c, 0xa4, 0x0c, 0xc4, 0x0d, 0x2a, 
	0x0d, 0x6a, 0x0d, 0xbc, 0x0e, 0x2a, 0x0e, 0x86, 0x0e, 0xe8, 0x0f, 0x7e, 0x0f, 0xa4, 0x0f, 0xe2, 
	0x10, 0x18, 0x10, 0x7a, 0x10, 0xc4, 0x11, 0x18, 0x11, 0x3e, 0x11, 0x6a, 0x11, 0x7e, 0x11, 0xa6, 
	0x11, 0xc0, 0x11, 0xd6, 0x11, 0xea, 0x12, 0x38, 0x12, 0x80, 0x12, 0xba, 0x13, 0x02, 0x13, 0x4e, 
	0x13, 0x8e, 0x13, 0xe2, 0x14, 0x1c, 0x14, 0x46, 0x14, 0x7c, 0x14, 0x9a, 0x14, 0xcc, 0x15, 0x2e, 
	0x15, 0x76, 0x15, 0xc6, 0x16, 0x10, 0x16, 0x5a, 0x16, 0x8c, 0x16, 0xce, 0x17, 0x0e, 0x17, 0x52, 
	0x17, 0x76, 0x17, 0xf0, 0x18, 0x1a, 0x18, 0x64, 0x18, 0x88, 0x18, 0xb8, 0x18, 0xce, 0x18, 0xfe, 
	0x19, 0x30, 0x19, 0x30, 0x19, 0x82, 0x19, 0xf4, 0x1a, 0x38, 0x1a, 0x80, 0x1a, 0xd8, 0x1a, 0xfc, 
	0x1b, 0x78, 0x1b, 0xae, 0x1c, 0x04, 0x1c, 0x7e, 0x1c, 0xa2, 0x1c, 0xc0, 0x1c, 0xd6, 0x1d, 0x1c, 
	0x1d, 0x32, 0x1d, 0xc6, 0x1e, 0x08, 0x1e, 0x3c, 0x1e, 0x92, 0x1e, 0xa6, 0x1e, 0xf0, 0x1f, 0x6c, 
	0x1f, 0xb4, 0x1f, 0xd4, 0x20, 0x02, 0x20, 0xaa, 0x20, 0xce, 0x21, 0x50, 0x21, 0xb2, 0x22, 0x92, 
	0x22, 0xfc, 0x23, 0x60, 0x23, 0xc4, 0x24, 0x18, 0x24, 0x60, 0x24, 0xd2, 0x25, 0x1c, 0x25, 0x86, 
	0x26, 0x04, 0x26, 0x44, 0x26, 0x84, 0x26, 0xce, 0x27, 0x34, 0x27, 0x7a, 0x27, 0xc2, 0x28, 0x0e, 
	0x28, 0x9c, 0x28, 0xf8, 0x29, 0x3a, 0x29, 0xa2, 0x2a, 0x0a, 0x2a, 0x88, 0x2a, 0xe2, 0x2b, 0x62, 
	0x2b, 0x86, 0x2b, 0xd8, 0x2c, 0x1c, 0x2c, 0x60, 0x2c, 0xa6, 0x2d, 0x10, 0x2d, 0x68, 0x2d, 0xda, 
	0x2e, 0x20, 0x2e, 0x78, 0x2e, 0xd0, 0x2f, 0x2a, 0x2f, 0x7c, 0x30, 0x00, 0x30, 0x5a, 0x30, 0xca, 
	0x31, 0x18, 0x31, 0x70, 0x31, 0xc8, 0x32, 0x22, 0x32, 0xa2, 0x32, 0xde, 0x33, 0x1a, 0x33, 0x58, 
	0x33, 0xea, 0x34, 0x58, 0x34, 0xa4, 0x34, 0xfe, 0x35, 0x58, 0x35, 0xb4, 0x36, 0x0c, 0x36, 0x8a, 
	0x36, 0xf2, 0x37, 0x50, 0x37, 0x9a, 0x37, 0xe4, 0x38, 0x32, 0x38, 0xaa, 0x38, 0xfa, 0x39, 0x48, 
	0x39, 0xc4, 0x39, 0xf6, 0x3a, 0x56, 0x3a, 0xb0, 0x3b, 0x3e, 0x3b, 0x8e, 0x3c, 0x18, 0x3c, 0x52, 
	0x3c, 0x86, 0x3c, 0xca, 0x3c, 0xe4, 0x3c, 0xfe, 0x3d, 0x26, 0x3d, 0x6e, 0x3d, 0xa8, 0x3d, 0xca, 
	0x3d, 0xfc, 0x3e, 0x1a, 0x3e, 0x30, 0x3e, 0x46, 0x3e, 0x68, 0x3e, 0x88, 0x3e, 0xa8, 0x3e, 0xc6, 
	0x3f, 0x02, 0x3f, 0x40, 0x3f, 0x7c, 0x3f, 0xb4, 0x40, 0x08, 0x40, 0x24, 0x40, 0x72, 0x40, 0xea, 
	0x41, 0x00, 0x41, 0x16, 0x41, 0xaa, 0x41, 0xce, 0x41, 0xec, 0x42, 0x00, 0x42, 0x18, 0x42, 0x36, 
	0x42, 0x56, 0x42, 0x76, 0x42, 0x96, 0x42, 0xba, 0x42, 0xe2, 0x43, 0x08, 0x43, 0x2c, 0x43, 0x60, 
	0x43, 0x82, 0x43, 0xb2, 0x43, 0xde, 0x44, 0x14, 0x44, 0x4e, 0x44, 0x7c, 0x44, 0xb0, 0x44, 0xee, 
	0x45, 0x1a, 0x45, 0x4e, 0x45, 0x8a, 0x45, 0xb8, 0x45, 0xea, 0x46, 0x28, 0x46, 0x5c, 0x46, 0x9a, 
	0x46, 0xf0, 0x47, 0x26, 0x47, 0x62, 0x47, 0xb2, 0x47, 0xe4, 0x48, 0x1e, 0x48, 0x68, 0x48, 0x98, 
	0x48, 0xd2, 0x49, 0x1c, 0x49, 0x72, 0x49, 0xd2, 0x4a, 0x46, 0x4a, 0x5a, 0x4a, 0x6e, 0x4a, 0x82, 
	0x4a, 0x96, 0x4a, 0xaa, 0x4c, 0x3a, 0x50, 0x00, 0x51, 0x6a, 0x51, 0x9a, 0x51, 0xbc, 0x51, 0xfa, 
	0x52, 0x08, 0x52, 0x1c, 0x52, 0x2a, 0x52, 0x3e, 0x00, 0x02, 0x00, 0x00, 0xff, 0x38, 0x01, 0xf4, 
	0x03, 0x20, 0x00, 0x03, 0x00, 0x08, 0x00, 0x47, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x0a, 0x2f, 
	0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x04, 0x10, 
	0xb8, 0x00, 0x07, 0xd0, 0x00, 0xba, 0x00, 0x02, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x02, 
	0x10, 0xba, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0x30, 0x31, 0x13, 
	0x11, 0x21, 0x11, 0x25, 0x21, 0x11, 0x21, 0x35, 0x64, 0x01, 0x2c, 0xfe, 0x70, 0x01, 0xf4, 0xfe, 
	0x0c, 0x02, 0xbc, 0xfc, 0xe0, 0x03, 0x20, 0x64, 0xfc, 0x18, 0x64, 0x00, 0x00, 0x02, 0x00, 0xc8, 
	0x00, 0x00, 0x01, 0x2c, 0x02, 0xbc, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x1f, 0xba, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 
	0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0x30, 0x31, 0x25, 0x23, 0x11, 0x33, 0x11, 
	0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x2c, 0x64, 0x64, 0x1d, 
	0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x01, 0xf4, 0xfd, 0x76, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x00, 0x00, 0x02, 0x00, 0x64, 0x01, 0xf4, 0x01, 0x90, 0x03, 0x20, 0x00, 0x03, 
	0x00, 0x07, 0x00, 0x33, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 
	0xb8, 0x00, 0x04, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x02, 
	0x2f, 0xb8, 0x00, 0x06, 0x2f, 0x30, 0x31, 0x01, 0x23, 0x11, 0x33, 0x03, 0x23, 0x11, 0x33, 0x01, 
	0x90, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 0xf4, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x2c, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0xc8, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x1b, 0x00, 0x1f, 0x00, 0xcb, 
	0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x03, 0xdc, 
	0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x06, 0xdc, 
	0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 
	0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x13, 0xd0, 
	0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x19, 0xd0, 
	0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x1c, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 
	0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x10, 0x2f, 0xb8, 0x00, 0x14, 
	0x2f, 0xba, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1b, 0x10, 0xba, 0x00, 0x0f, 
	0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 
	0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x1b, 0x10, 0xb8, 0x00, 0x0a, 
	0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x16, 
	0xd0, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xb8, 0x00, 0x1b, 0x10, 0xb8, 0x00, 0x1c, 
	0xd0, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x1d, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x15, 0x23, 0x35, 
	0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x35, 
	0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x23, 0x35, 0x23, 0x15, 0x01, 0xf4, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0xc8, 0x64, 0x01, 0x2c, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0xff, 0x9d, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x21, 0x00, 0x28, 0x00, 0x2f, 
	0x01, 0x11, 0xb8, 0x00, 0x30, 0x2f, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 
	0x05, 0xdc, 0x41, 0x03, 0x00, 0x50, 0x00, 0x05, 0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0x90, 0x00, 
	0x05, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x05, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x1b, 
	0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x1b, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x1b, 
	0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0x90, 0x00, 0x1b, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x1a, 0xdc, 
	0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x04, 0x10, 
	0xb8, 0x00, 0x16, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 0xb8, 0x00, 0x05, 0x10, 
	0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x26, 0xd0, 0xb8, 0x00, 0x1b, 0x10, 
	0xb8, 0x00, 0x29, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x2c, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 
	0xb8, 0x00, 0x31, 0xdc, 0x00, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x2d, 
	0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x2d, 0x10, 0xba, 0x00, 0x17, 0x00, 0x1e, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x17, 0x10, 0xba, 0x00, 0x22, 0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x22, 
	0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 0x0d, 
	0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x22, 0x10, 0xb8, 0x00, 0x1f, 
	0xd0, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x23, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x2c, 
	0xd0, 0x30, 0x31, 0x25, 0x14, 0x06, 0x23, 0x15, 0x23, 0x35, 0x22, 0x26, 0x35, 0x33, 0x14, 0x16, 
	0x33, 0x35, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x35, 0x33, 0x15, 0x32, 0x16, 0x15, 0x23, 0x34, 
	0x26, 0x23, 0x15, 0x32, 0x16, 0x25, 0x35, 0x22, 0x06, 0x15, 0x14, 0x16, 0x17, 0x34, 0x26, 0x23, 
	0x15, 0x32, 0x36, 0x01, 0xf4, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x53, 0x75, 0x75, 
	0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x52, 0x76, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0xf1, 0x3b, 
	0x29, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x63, 0x63, 0x75, 0x53, 0x29, 0x3b, 0xc8, 0x75, 0x53, 0x53, 
	0x75, 0x64, 0x64, 0x76, 0x52, 0x29, 0x3b, 0xc8, 0x76, 0x76, 0xc8, 0x3b, 0x29, 0x29, 0x3b, 0xc8, 
	0x29, 0x3b, 0xc8, 0x3b, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x19, 
	0x00, 0x20, 0x00, 0x2c, 0x00, 0x38, 0x00, 0x1e, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcd, 0x00, 
	0x0f, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xcd, 0x00, 0x10, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 
	0xc2, 0x00, 0x12, 0x00, 0x01, 0x5d, 0x25, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x37, 0x07, 
	0x15, 0x23, 0x35, 0x37, 0x26, 0x27, 0x26, 0x35, 0x34, 0x36, 0x33, 0x21, 0x15, 0x07, 0x1e, 0x01, 
	0x03, 0x35, 0x23, 0x16, 0x15, 0x14, 0x07, 0x27, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 
	0x33, 0x32, 0x36, 0x13, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x01, 
	0xf4, 0x58, 0x3e, 0x3e, 0x58, 0x02, 0x66, 0x64, 0x83, 0x3d, 0x23, 0x23, 0x58, 0x3e, 0x01, 0x5e, 
	0x82, 0x39, 0x49, 0x64, 0x79, 0x15, 0x01, 0x63, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x53, 0x75, 0x75, 0x53, 0x0b, 0x14, 
	0x66, 0x81, 0xab, 0x83, 0x0d, 0x38, 0x35, 0x4c, 0x53, 0x75, 0xab, 0x82, 0x0c, 0x71, 0x01, 0x29, 
	0x1d, 0x30, 0x34, 0x15, 0x09, 0x1e, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0xfe, 0xfd, 0x29, 
	0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xff, 0xf1, 0x02, 0x0a, 
	0x02, 0xbc, 0x00, 0x1c, 0x00, 0x28, 0x00, 0x32, 0x00, 0x0b, 0x30, 0x31, 0x41, 0x03, 0x00, 0xc3, 
	0x00, 0x15, 0x00, 0x01, 0x5d, 0x25, 0x07, 0x17, 0x07, 0x27, 0x07, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x3f, 0x01, 0x27, 0x26, 0x35, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x0f, 0x01, 
	0x17, 0x37, 0x27, 0x36, 0x35, 0x34, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x14, 0x1f, 0x01, 0x13, 0x27, 
	0x07, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x37, 0x02, 0x0a, 0x66, 0x60, 0x45, 0x61, 0x3a, 0x2a, 
	0x32, 0x52, 0x76, 0x16, 0x3a, 0x3a, 0x16, 0x75, 0x53, 0x3e, 0x39, 0x51, 0x08, 0xac, 0x82, 0x67, 
	0x9a, 0x01, 0x19, 0x4b, 0x29, 0x3b, 0x07, 0x2c, 0x82, 0x83, 0x2b, 0x07, 0x3b, 0x29, 0x16, 0x0f, 
	0xfd, 0x67, 0x61, 0x44, 0x60, 0x3b, 0x16, 0x75, 0x53, 0x32, 0x2a, 0x39, 0x3b, 0x2a, 0x32, 0x53, 
	0x75, 0x51, 0x38, 0x1d, 0x0b, 0xad, 0x83, 0x67, 0xf5, 0x04, 0x04, 0x19, 0x3b, 0x29, 0x16, 0x0f, 
	0x2c, 0xfe, 0xf3, 0x82, 0x2b, 0x0f, 0x16, 0x29, 0x3b, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 
	0x01, 0xf4, 0x01, 0x2c, 0x03, 0x20, 0x00, 0x03, 0x00, 0x13, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x2b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0x30, 0x31, 0x01, 0x23, 0x11, 
	0x33, 0x01, 0x2c, 0x64, 0x64, 0x01, 0xf4, 0x01, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x64, 
	0xff, 0x8a, 0x01, 0xa3, 0x03, 0x33, 0x00, 0x07, 0x00, 0x17, 0xba, 0x00, 0x07, 0x00, 0x02, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0x00, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 
	0x31, 0x05, 0x07, 0x27, 0x11, 0x37, 0x17, 0x07, 0x11, 0x01, 0xa3, 0x45, 0xfa, 0xfa, 0x45, 0xdb, 
	0x31, 0x45, 0xf9, 0x01, 0xb6, 0xfa, 0x45, 0xdb, 0xfe, 0x96, 0x00, 0x00, 0x00, 0x01, 0x00, 0x51, 
	0xff, 0x8a, 0x01, 0x90, 0x03, 0x33, 0x00, 0x07, 0x00, 0x13, 0xba, 0x00, 0x00, 0x00, 0x03, 0x00, 
	0x03, 0x2b, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 0x31, 0x25, 0x07, 0x27, 
	0x37, 0x11, 0x27, 0x37, 0x17, 0x01, 0x90, 0xfa, 0x45, 0xdb, 0xdb, 0x45, 0xfa, 0x83, 0xf9, 0x45, 
	0xda, 0x01, 0x6a, 0xdb, 0x45, 0xfa, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0xc8, 0x01, 0xed, 
	0x02, 0xbc, 0x00, 0x11, 0x00, 0x0f, 0x00, 0x7d, 0xb8, 0x00, 0x08, 0x2f, 0x18, 0x7d, 0xb8, 0x00, 
	0x11, 0x2f, 0x18, 0x30, 0x31, 0x01, 0x07, 0x27, 0x15, 0x23, 0x35, 0x07, 0x27, 0x37, 0x27, 0x37, 
	0x17, 0x35, 0x33, 0x15, 0x37, 0x17, 0x07, 0x01, 0xed, 0x31, 0x90, 0x64, 0x8e, 0x32, 0x8e, 0x8f, 
	0x31, 0x90, 0x64, 0x8d, 0x32, 0x8d, 0x01, 0x75, 0x58, 0x4f, 0xa4, 0xa4, 0x52, 0x56, 0x52, 0x4d, 
	0x58, 0x50, 0xa5, 0xa3, 0x51, 0x56, 0x52, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64, 0x01, 0xf4, 
	0x02, 0x58, 0x00, 0x0b, 0x00, 0x43, 0xba, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x02, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 
	0x09, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 
	0x00, 0x0b, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 
	0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0xf4, 0xc8, 0x64, 0xc8, 0xc8, 0x64, 0xc8, 0x01, 0x2c, 0xc8, 
	0xc8, 0x64, 0xc8, 0xc8, 0x00, 0x01, 0x00, 0x7d, 0xff, 0x39, 0x01, 0x5e, 0x00, 0xe1, 0x00, 0x0d, 
	0x00, 0x08, 0x7d, 0xb8, 0x00, 0x07, 0x2f, 0x18, 0x30, 0x31, 0x05, 0x07, 0x27, 0x37, 0x35, 0x22, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x15, 0x01, 0x5e, 0x9c, 0x45, 0x7d, 0x29, 0x3b, 0x3b, 
	0x29, 0x29, 0x3b, 0x2b, 0x9c, 0x45, 0x7d, 0x1e, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x64, 0x01, 0x2c, 0x01, 0x90, 0x01, 0x90, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 
	0x21, 0x01, 0x90, 0xfe, 0xd4, 0x01, 0x2c, 0x01, 0x2c, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x96, 
	0x00, 0x19, 0x01, 0x5a, 0x00, 0xe1, 0x00, 0x0b, 0x00, 0x62, 0xba, 0x00, 0x00, 0x00, 0x06, 0x00, 
	0x03, 0x2b, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 
	0x00, 0xc6, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x00, 
	0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x26, 0x00, 
	0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x06, 0x71, 
	0x41, 0x05, 0x00, 0x65, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x02, 0x71, 0x00, 0xba, 0x00, 
	0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x23, 
	0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x5a, 0x37, 0x29, 0x29, 0x3b, 0x3b, 0x29, 
	0x29, 0x37, 0x7d, 0x2a, 0x3a, 0x3b, 0x29, 0x29, 0x3b, 0x3a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xff, 0x42, 0x02, 0x3b, 0x03, 0x20, 0x00, 0x03, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 
	0x00, 0x03, 0x2f, 0x30, 0x31, 0x09, 0x01, 0x27, 0x01, 0x02, 0x3b, 0xfe, 0x1e, 0x59, 0x01, 0xe2, 
	0x02, 0xf2, 0xfc, 0x50, 0x2d, 0x03, 0xb1, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0f, 0x00, 0x17, 0x00, 0x1f, 0x00, 0x3f, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 
	0x21, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 
	0x07, 0x2f, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x18, 0xdc, 0x00, 0xba, 
	0x00, 0x1d, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x12, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x27, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 
	0x01, 0x05, 0x35, 0x01, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0x76, 0x52, 0x64, 0x52, 0x76, 0x73, 0x1e, 0x37, 0x64, 0x29, 0x3b, 0x01, 0x2c, 0xfe, 0xe5, 0x1e, 
	0x35, 0x64, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0x36, 
	0x2e, 0x3b, 0x29, 0xe7, 0x45, 0xe5, 0xfe, 0xe5, 0x2e, 0x3b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0d, 0x00, 0x3b, 0xba, 0x00, 0x0c, 0x00, 0x03, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0x00, 0xb8, 
	0x00, 0x0a, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 
	0x00, 0x07, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 
	0x00, 0x02, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x32, 0x36, 0x35, 
	0x33, 0x11, 0x33, 0x01, 0xf4, 0xfe, 0x0c, 0xc8, 0x96, 0x32, 0x29, 0x3b, 0x64, 0xc8, 0x64, 0x01, 
	0x90, 0x64, 0x3b, 0x29, 0xfd, 0xa8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x18, 0x00, 0x7e, 0xba, 0x00, 0x14, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x14, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x41, 0x05, 0x00, 0x6a, 0x00, 0x05, 0x00, 0x7a, 0x00, 0x05, 
	0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x05, 0x00, 0xa9, 0x00, 0x05, 0x00, 0xb9, 0x00, 
	0x05, 0x00, 0xc9, 0x00, 0x05, 0x00, 0xd9, 0x00, 0x05, 0x00, 0xe9, 0x00, 0x05, 0x00, 0xf9, 0x00, 
	0x05, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x05, 0x00, 0x19, 0x00, 0x05, 0x00, 0x29, 
	0x00, 0x05, 0x00, 0x39, 0x00, 0x05, 0x00, 0x49, 0x00, 0x05, 0x00, 0x59, 0x00, 0x05, 0x00, 0x06, 
	0x71, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x1a, 0xdc, 0x00, 0xba, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 0x11, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x11, 0x10, 0x30, 0x31, 0x29, 0x01, 0x35, 0x01, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 
	0x15, 0x23, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x07, 0x01, 0x21, 0x01, 0xf4, 0xfe, 
	0x0c, 0x01, 0x89, 0x07, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x76, 0x52, 0x64, 0x52, 0x76, 0x16, 
	0xfe, 0xcb, 0x01, 0x4b, 0x45, 0x01, 0x8a, 0x0f, 0x16, 0x29, 0x3b, 0x3b, 0x29, 0x52, 0x76, 0x75, 
	0x53, 0x32, 0x2a, 0xfe, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x2a, 0x00, 0xc2, 0xb8, 0x00, 0x2b, 0x2f, 0xb8, 0x00, 0x2c, 0x2f, 0xb8, 0x00, 
	0x2b, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xb8, 0x00, 0x18, 0x2f, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 
	0x00, 0xd0, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 0x23, 0xdc, 0xb8, 0x00, 0x07, 0xdc, 0x41, 0x05, 
	0x00, 0x6a, 0x00, 0x07, 0x00, 0x7a, 0x00, 0x07, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 
	0x07, 0x00, 0xa9, 0x00, 0x07, 0x00, 0xb9, 0x00, 0x07, 0x00, 0xc9, 0x00, 0x07, 0x00, 0xd9, 0x00, 
	0x07, 0x00, 0xe9, 0x00, 0x07, 0x00, 0xf9, 0x00, 0x07, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 
	0x00, 0x07, 0x00, 0x19, 0x00, 0x07, 0x00, 0x29, 0x00, 0x07, 0x00, 0x39, 0x00, 0x07, 0x00, 0x49, 
	0x00, 0x07, 0x00, 0x59, 0x00, 0x07, 0x00, 0x06, 0x71, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 0x00, 0x23, 
	0x10, 0xb8, 0x00, 0x1f, 0xd0, 0xba, 0x00, 0x21, 0x00, 0x23, 0x00, 0x07, 0x11, 0x12, 0x39, 0xb8, 
	0x00, 0x18, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0x00, 0xba, 0x00, 0x04, 0x00, 0x26, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x1c, 0x00, 0x13, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1c, 0x10, 
	0xba, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 0x00, 0x21, 0x00, 
	0x0a, 0x00, 0x0d, 0x11, 0x12, 0x39, 0x30, 0x31, 0x37, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 
	0x34, 0x26, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 
	0x23, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x07, 0x16, 0x15, 0x14, 0x06, 0x2b, 0x01, 
	0x22, 0x26, 0x35, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x64, 0x29, 0x3b, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x64, 0x75, 0x53, 0x64, 0x53, 0x75, 0x55, 0x55, 0x75, 0x53, 0x64, 0x53, 
	0x75, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x64, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x53, 
	0x75, 0x75, 0x53, 0x5a, 0x3c, 0x3c, 0x5a, 0x53, 0x75, 0x75, 0x53, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0e, 0x00, 0x12, 0x00, 0x4f, 0xba, 0x00, 0x0d, 0x00, 
	0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x03, 0x10, 
	0xb8, 0x00, 0x0f, 0xd0, 0x00, 0xb8, 0x00, 0x07, 0x2f, 0xba, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0e, 0x10, 0xba, 0x00, 0x0f, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 
	0x10, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x09, 
	0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x35, 
	0x21, 0x35, 0x01, 0x33, 0x11, 0x33, 0x15, 0x23, 0x15, 0x33, 0x27, 0x35, 0x07, 0x15, 0x01, 0xf4, 
	0xfe, 0xd4, 0x64, 0xfe, 0xd4, 0x01, 0x4b, 0x45, 0x64, 0x64, 0x64, 0xc8, 0xc8, 0x64, 0x64, 0xa9, 
	0x01, 0x4b, 0xfe, 0x70, 0x64, 0x64, 0xc8, 0xe7, 0xc8, 0x1f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x1d, 0x00, 0x63, 0xb8, 0x00, 0x1e, 0x2f, 0xb8, 0x00, 
	0x1f, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 
	0x07, 0x2f, 0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0f, 0xdc, 0xb8, 0x00, 
	0x07, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0xb8, 0x00, 
	0x08, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0x00, 0xba, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0c, 0x10, 0xba, 0x00, 0x16, 0x00, 0x17, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x16, 0x10, 0xba, 
	0x00, 0x1a, 0x00, 0x13, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1a, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 
	0x2b, 0x01, 0x22, 0x26, 0x35, 0x33, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x3d, 0x01, 0x34, 0x26, 
	0x23, 0x21, 0x11, 0x21, 0x15, 0x21, 0x15, 0x33, 0x32, 0x16, 0x15, 0x01, 0xf4, 0x76, 0x52, 0x64, 
	0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x01, 0xf4, 0xfe, 0x70, 
	0xc8, 0x52, 0x76, 0xc8, 0x52, 0x76, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x01, 
	0x2c, 0x64, 0x64, 0x76, 0x52, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x15, 0x00, 0x22, 0x00, 0x57, 0xb8, 0x00, 0x23, 0x2f, 0xb8, 0x00, 0x24, 0x2f, 
	0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x24, 0x10, 
	0xb8, 0x00, 0x15, 0xdc, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x07, 0x10, 
	0xb8, 0x00, 0x1c, 0xdc, 0xb8, 0x00, 0x11, 0xd0, 0x00, 0xba, 0x00, 0x20, 0x00, 0x03, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x20, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 
	0x10, 0xba, 0x00, 0x12, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x15, 0x23, 0x22, 0x06, 
	0x15, 0x33, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x15, 0x14, 0x16, 0x3b, 0x01, 
	0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 
	0x52, 0x76, 0x64, 0x3b, 0x29, 0xc8, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 0x52, 
	0x01, 0x2c, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0xc8, 0x29, 0x3b, 
	0x3b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x09, 
	0x00, 0x37, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 
	0x0a, 0x10, 0xb8, 0x00, 0x03, 0xd0, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 
	0x00, 0x10, 0xb8, 0x00, 0x05, 0xdc, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x06, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x01, 0x07, 0x15, 0x23, 0x11, 0x37, 0x35, 
	0x21, 0x35, 0x21, 0x01, 0xf4, 0xc8, 0x64, 0xc8, 0xfe, 0x70, 0x01, 0xf4, 0x01, 0xaf, 0xc8, 0xe7, 
	0x01, 0x0d, 0xc8, 0x83, 0x64, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x15, 0x00, 0x23, 0x00, 0x31, 0x01, 0x25, 0xb8, 0x00, 0x32, 0x2f, 0xb8, 0x00, 
	0x33, 0x2f, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 0x20, 0xdc, 0x41, 0x05, 0x00, 0x6a, 0x00, 0x20, 
	0x00, 0x7a, 0x00, 0x20, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x20, 0x00, 0xa9, 0x00, 
	0x20, 0x00, 0xb9, 0x00, 0x20, 0x00, 0xc9, 0x00, 0x20, 0x00, 0xd9, 0x00, 0x20, 0x00, 0xe9, 0x00, 
	0x20, 0x00, 0xf9, 0x00, 0x20, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x20, 0x00, 0x19, 
	0x00, 0x20, 0x00, 0x29, 0x00, 0x20, 0x00, 0x39, 0x00, 0x20, 0x00, 0x49, 0x00, 0x20, 0x00, 0x59, 
	0x00, 0x20, 0x00, 0x06, 0x71, 0xba, 0x00, 0x05, 0x00, 0x03, 0x00, 0x20, 0x11, 0x12, 0x39, 0xb8, 
	0x00, 0x03, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x32, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0xb8, 
	0x00, 0x0e, 0x2f, 0xb8, 0x00, 0x2e, 0xdc, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x2e, 0x00, 0xa6, 0x00, 
	0x2e, 0x00, 0xb6, 0x00, 0x2e, 0x00, 0xc6, 0x00, 0x2e, 0x00, 0xd6, 0x00, 0x2e, 0x00, 0xe6, 0x00, 
	0x2e, 0x00, 0xf6, 0x00, 0x2e, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x2e, 0x00, 0x16, 
	0x00, 0x2e, 0x00, 0x26, 0x00, 0x2e, 0x00, 0x36, 0x00, 0x2e, 0x00, 0x46, 0x00, 0x2e, 0x00, 0x56, 
	0x00, 0x2e, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x2e, 0x00, 0x75, 0x00, 0x2e, 0x00, 
	0x02, 0x71, 0xba, 0x00, 0x10, 0x00, 0x0e, 0x00, 0x2e, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x0e, 0x10, 
	0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x19, 0xd0, 0xb8, 0x00, 0x20, 0x10, 
	0xb8, 0x00, 0x27, 0xd0, 0x00, 0xba, 0x00, 0x24, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x24, 
	0x10, 0xba, 0x00, 0x15, 0x00, 0x16, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x15, 0x10, 0xba, 0x00, 0x1d, 
	0x00, 0x2a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x05, 0x00, 0x2a, 0x00, 0x1d, 
	0x11, 0x12, 0x39, 0xba, 0x00, 0x10, 0x00, 0x2a, 0x00, 0x1d, 0x11, 0x12, 0x39, 0x30, 0x31, 0x01, 
	0x32, 0x16, 0x15, 0x14, 0x07, 0x16, 0x15, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x34, 0x37, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 
	0x34, 0x26, 0x23, 0x11, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x14, 0x16, 
	0x33, 0x01, 0x2c, 0x53, 0x75, 0x55, 0x55, 0x75, 0x53, 0x64, 0x53, 0x75, 0x55, 0x55, 0x75, 0x53, 
	0x2a, 0x3a, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x2a, 0x3a, 0x3b, 0x29, 0x64, 0x29, 0x3b, 
	0x3b, 0x29, 0x02, 0xbc, 0x75, 0x53, 0x5a, 0x3c, 0x3c, 0x5a, 0x53, 0x75, 0x75, 0x53, 0x5a, 0x3c, 
	0x3c, 0x5a, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0xfe, 0x0c, 0x3b, 
	0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x15, 0x00, 0x22, 0x00, 0x53, 0xb8, 0x00, 0x23, 0x2f, 0xb8, 0x00, 0x24, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 
	0xb8, 0x00, 0x1f, 0xdc, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x09, 0xdc, 
	0xb8, 0x00, 0x16, 0xd0, 0x00, 0xba, 0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 
	0x10, 0xba, 0x00, 0x12, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xba, 0x00, 0x16, 
	0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x16, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 
	0x35, 0x33, 0x32, 0x36, 0x35, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 
	0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x01, 0xf4, 
	0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0xc8, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x02, 0x00, 0x96, 
	0x00, 0x19, 0x01, 0x5e, 0x02, 0x0d, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x0e, 0x7d, 0xb8, 0x00, 0x06, 
	0x2f, 0x18, 0x7d, 0xb8, 0x00, 0x12, 0x2f, 0x18, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 
	0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x11, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x16, 0x01, 0x5e, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 
	0x3b, 0x29, 0x29, 0x3b, 0x01, 0xa9, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0xfe, 0xab, 0x29, 
	0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x7d, 0xff, 0x39, 0x01, 0x5e, 
	0x02, 0x0d, 0x00, 0x0b, 0x00, 0x19, 0x00, 0x0e, 0x7d, 0xb8, 0x00, 0x06, 0x2f, 0x18, 0x7d, 0xb8, 
	0x00, 0x13, 0x2f, 0x18, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x16, 0x11, 0x07, 0x27, 0x37, 0x35, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x15, 
	0x01, 0x5e, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x9c, 0x45, 0x7d, 0x29, 0x3b, 0x3b, 
	0x29, 0x29, 0x3b, 0x01, 0xa9, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0xfe, 0x03, 0x9c, 0x45, 
	0x7d, 0x1e, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x01, 0x00, 0x4f, 0xff, 0xe8, 0x02, 0x0d, 
	0x02, 0xcf, 0x00, 0x05, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 
	0x31, 0x25, 0x07, 0x09, 0x01, 0x17, 0x01, 0x02, 0x0d, 0x45, 0xfe, 0x87, 0x01, 0x73, 0x45, 0xfe, 
	0xd6, 0x2c, 0x44, 0x01, 0x76, 0x01, 0x71, 0x45, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0xc8, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x03, 0x00, 0x07, 0x00, 0x1b, 0x00, 0xba, 0x00, 0x07, 
	0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 0x21, 0x11, 0x21, 0x35, 0x21, 0x01, 
	0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0x01, 0x90, 0x64, 0xfe, 0xd4, 0x64, 0x00, 
	0x00, 0x01, 0x00, 0x4b, 0xff, 0xee, 0x02, 0x09, 0x02, 0xd5, 0x00, 0x05, 0x00, 0x0b, 0x00, 0xb8, 
	0x00, 0x05, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 0x31, 0x09, 0x01, 0x27, 0x09, 0x01, 0x37, 0x02, 
	0x09, 0xfe, 0x8d, 0x45, 0x01, 0x2a, 0xfe, 0xd0, 0x45, 0x01, 0x5e, 0xfe, 0x90, 0x44, 0x01, 0x2c, 
	0x01, 0x32, 0x45, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x16, 
	0x00, 0x22, 0x00, 0x66, 0xba, 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0x2b, 0x41, 0x05, 0x00, 0x6a, 
	0x00, 0x08, 0x00, 0x7a, 0x00, 0x08, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x08, 0x00, 
	0xa9, 0x00, 0x08, 0x00, 0xb9, 0x00, 0x08, 0x00, 0xc9, 0x00, 0x08, 0x00, 0xd9, 0x00, 0x08, 0x00, 
	0xe9, 0x00, 0x08, 0x00, 0xf9, 0x00, 0x08, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x08, 
	0x00, 0x19, 0x00, 0x08, 0x00, 0x29, 0x00, 0x08, 0x00, 0x39, 0x00, 0x08, 0x00, 0x49, 0x00, 0x08, 
	0x00, 0x59, 0x00, 0x08, 0x00, 0x06, 0x71, 0x00, 0xb8, 0x00, 0x1a, 0x2f, 0xba, 0x00, 0x14, 0x00, 
	0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0x30, 0x31, 0x01, 0x14, 0x0f, 0x01, 0x23, 0x35, 
	0x37, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x23, 0x34, 0x36, 0x3b, 0x01, 0x32, 
	0x16, 0x03, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0xf4, 0x16, 
	0xd1, 0x45, 0xc1, 0x07, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x76, 0x52, 0x64, 0x52, 0x76, 0xc8, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0xf4, 0x32, 0x2a, 0xd0, 0x45, 0xc2, 0x0f, 
	0x16, 0x29, 0x3b, 0x3b, 0x29, 0x52, 0x76, 0x75, 0xfd, 0xeb, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x25, 
	0x00, 0x31, 0x00, 0xd9, 0xb8, 0x00, 0x32, 0x2f, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 
	0xb8, 0x00, 0x14, 0xdc, 0x41, 0x03, 0x00, 0x50, 0x00, 0x14, 0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 
	0x90, 0x00, 0x14, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x14, 0x00, 0x01, 0x5d, 0xb8, 
	0x00, 0x01, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 
	0x00, 0x26, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x26, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 
	0x00, 0x26, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x26, 0x00, 0x01, 0x71, 0xb8, 0x00, 
	0x0d, 0xdc, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x11, 0xdc, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x19, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x1d, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x21, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x24, 0xd0, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x2c, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 
	0x33, 0xdc, 0x00, 0xba, 0x00, 0x25, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x25, 0x10, 0xba, 
	0x00, 0x09, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x14, 0x00, 0x11, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0xba, 0x00, 0x18, 0x00, 0x2a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x18, 0x10, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x2f, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x22, 
	0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x22, 
	0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x11, 0x14, 
	0x16, 0x33, 0x21, 0x27, 0x35, 0x34, 0x2b, 0x01, 0x22, 0x1d, 0x01, 0x14, 0x3b, 0x01, 0x32, 0x01, 
	0xf4, 0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x29, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0x2c, 0x64, 0x19, 0x32, 0x19, 0x19, 
	0x32, 0x19, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0xc8, 0x2a, 0x3a, 0x3d, 0x27, 0x64, 
	0x29, 0x3b, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0xe1, 0x32, 0x19, 0x19, 0x32, 0x19, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x09, 0x00, 0x0c, 0x00, 0x59, 
	0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x02, 0xd0, 
	0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x07, 0xdc, 
	0xb8, 0x00, 0x08, 0xdc, 0xba, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x07, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x00, 0xb8, 
	0x00, 0x01, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0x30, 0x31, 0x37, 0x15, 0x23, 0x11, 0x13, 0x33, 0x13, 
	0x11, 0x23, 0x35, 0x0b, 0x01, 0x21, 0x64, 0x64, 0xbc, 0x7d, 0xbb, 0x64, 0x96, 0x96, 0x01, 0x2c, 
	0xc8, 0xc8, 0x01, 0x45, 0x01, 0x77, 0xfe, 0x89, 0xfe, 0xbb, 0xc8, 0x01, 0x90, 0xfe, 0xd4, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0c, 0x00, 0x15, 0x00, 0x1e, 
	0x00, 0xba, 0xb8, 0x00, 0x1f, 0x2f, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 
	0x12, 0xdc, 0x41, 0x05, 0x00, 0x6a, 0x00, 0x12, 0x00, 0x7a, 0x00, 0x12, 0x00, 0x02, 0x71, 0x41, 
	0x0f, 0x00, 0x99, 0x00, 0x12, 0x00, 0xa9, 0x00, 0x12, 0x00, 0xb9, 0x00, 0x12, 0x00, 0xc9, 0x00, 
	0x12, 0x00, 0xd9, 0x00, 0x12, 0x00, 0xe9, 0x00, 0x12, 0x00, 0xf9, 0x00, 0x12, 0x00, 0x07, 0x5d, 
	0x41, 0x0d, 0x00, 0x09, 0x00, 0x12, 0x00, 0x19, 0x00, 0x12, 0x00, 0x29, 0x00, 0x12, 0x00, 0x39, 
	0x00, 0x12, 0x00, 0x49, 0x00, 0x12, 0x00, 0x59, 0x00, 0x12, 0x00, 0x06, 0x71, 0xba, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x12, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 
	0x00, 0x1f, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 
	0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x1b, 0xd0, 0x00, 0xba, 0x00, 0x18, 0x00, 
	0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x0e, 0x00, 0x16, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 
	0xba, 0x00, 0x02, 0x00, 0x16, 0x00, 0x0e, 0x11, 0x12, 0x39, 0x30, 0x31, 0x01, 0x14, 0x07, 0x16, 
	0x15, 0x14, 0x06, 0x23, 0x21, 0x11, 0x21, 0x32, 0x16, 0x25, 0x15, 0x33, 0x32, 0x36, 0x35, 0x34, 
	0x26, 0x23, 0x03, 0x15, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x23, 0x01, 0xf4, 0x55, 0x55, 0x75, 
	0x53, 0xfe, 0xd4, 0x01, 0x2c, 0x53, 0x75, 0xfe, 0x70, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0xc8, 0xc8, 
	0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x5a, 0x3c, 0x3c, 0x5a, 0x53, 0x75, 0x02, 0xbc, 0x75, 0x11, 
	0xc8, 0x3b, 0x29, 0x29, 0x3b, 0xfe, 0xd4, 0xc8, 0x3b, 0x29, 0x29, 0x3b, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x1f, 0x00, 0x4f, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 
	0x21, 0x2f, 0xb8, 0x00, 0x0f, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 
	0x07, 0x10, 0xb8, 0x00, 0x18, 0xdc, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 0x00, 0xba, 
	0x00, 0x1c, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1c, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x13, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 
	0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 
	0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 
	0xd4, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x09, 0x00, 0x13, 0x00, 0x43, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 
	0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x10, 0xdc, 
	0x00, 0xba, 0x00, 0x11, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xba, 0x00, 0x06, 
	0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x23, 0x21, 
	0x11, 0x21, 0x32, 0x16, 0x15, 0x03, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x11, 0x33, 0x32, 0x36, 0x01, 
	0xf4, 0x76, 0x52, 0xfe, 0xd4, 0x01, 0x2c, 0x52, 0x76, 0x64, 0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 
	0xc8, 0x52, 0x76, 0x02, 0xbc, 0x76, 0x52, 0xfe, 0xd4, 0x01, 0x2c, 0x29, 0x3b, 0xfe, 0x0c, 0x3b, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x37, 0xba, 0x00, 
	0x0a, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xba, 
	0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xba, 0x00, 0x03, 0x00, 0x04, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0xba, 0x00, 0x07, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x07, 0x10, 0x30, 0x31, 0x29, 0x01, 0x11, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 
	0x21, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x90, 0x02, 
	0xbc, 0x64, 0xc8, 0x64, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x09, 0x00, 0x2f, 0xba, 0x00, 0x06, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x06, 0x10, 0xb8, 0x00, 0x01, 0xd0, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x15, 0x21, 0x15, 0x21, 0x11, 0x23, 0x11, 0x21, 0x01, 
	0xf4, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x64, 0x01, 0xf4, 0x02, 0x58, 0xc8, 0x64, 0xfe, 0xd4, 
	0x02, 0xbc, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x23, 
	0x00, 0x57, 0xba, 0x00, 0x18, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 
	0x00, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 
	0x00, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x1f, 0xd0, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 
	0x21, 0xd0, 0x00, 0xba, 0x00, 0x1c, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1c, 0x10, 0xba, 
	0x00, 0x0c, 0x00, 0x13, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xba, 0x00, 0x22, 0x00, 0x21, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x22, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 
	0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x3d, 0x01, 0x23, 0x35, 0x33, 0x01, 0xf4, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x64, 0xc8, 0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 
	0x52, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x64, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x4b, 0xb8, 0x00, 
	0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 
	0x0c, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 
	0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x02, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x21, 0x23, 0x11, 0x21, 0x11, 0x23, 0x11, 
	0x33, 0x11, 0x21, 0x11, 0x33, 0x01, 0xf4, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x01, 
	0x2c, 0xfe, 0xd4, 0x02, 0xbc, 0xfe, 0xd4, 0x01, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x37, 0xba, 0x00, 0x0a, 0x00, 0x03, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0x00, 0xba, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0b, 0x10, 0xba, 0x00, 0x06, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xb8, 
	0x00, 0x0b, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0x30, 
	0x31, 0x29, 0x01, 0x35, 0x33, 0x11, 0x23, 0x35, 0x21, 0x15, 0x23, 0x11, 0x33, 0x01, 0xf4, 0xfe, 
	0x0c, 0xc8, 0xc8, 0x01, 0xf4, 0xc8, 0xc8, 0x64, 0x01, 0xf4, 0x64, 0x64, 0xfe, 0x0c, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x13, 0x00, 0x37, 0xb8, 0x00, 
	0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x11, 0xdc, 0x00, 0xb8, 0x00, 0x12, 0x2f, 0xba, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0e, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x33, 0x15, 
	0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0xc8, 0x53, 0x75, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 
	0x3b, 0x29, 0x01, 0xf4, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0c, 
	0x00, 0x14, 0x30, 0x31, 0x41, 0x03, 0x00, 0xcd, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 
	0xcd, 0x00, 0x08, 0x00, 0x01, 0x5d, 0x21, 0x23, 0x01, 0x11, 0x23, 0x11, 0x33, 0x11, 0x01, 0x33, 
	0x15, 0x09, 0x01, 0x01, 0xf4, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0xc7, 0x01, 
	0x39, 0x01, 0x2c, 0xfe, 0xd4, 0x02, 0xbc, 0xfe, 0xd4, 0x01, 0x2c, 0x25, 0xfe, 0xc7, 0xfe, 0xc8, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x05, 0x00, 0x1f, 0xba, 0x00, 
	0x04, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xba, 
	0x00, 0x05, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0x30, 0x31, 0x29, 0x01, 0x11, 
	0x33, 0x11, 0x21, 0x01, 0xf4, 0xfe, 0x0c, 0x64, 0x01, 0x90, 0x02, 0xbc, 0xfd, 0xa8, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0e, 0x00, 0x97, 0xb8, 0x00, 
	0x0f, 0x2f, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0x41, 0x03, 
	0x00, 0x50, 0x00, 0x05, 0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0x90, 0x00, 0x05, 0x00, 0x01, 0x5d, 
	0x41, 0x03, 0x00, 0xf0, 0x00, 0x05, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x01, 0xdc, 0x41, 0x03, 0x00, 
	0xf0, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0x50, 0x00, 0x01, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x05, 0x10, 
	0xb8, 0x00, 0x04, 0xdc, 0xba, 0x00, 0x07, 0x00, 0x09, 0x00, 0x05, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x09, 0x10, 0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0x00, 0xb8, 
	0x00, 0x00, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xba, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x11, 0x12, 0x39, 0xba, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0a, 
	0x11, 0x12, 0x39, 0x30, 0x31, 0x21, 0x23, 0x11, 0x07, 0x15, 0x23, 0x35, 0x27, 0x11, 0x23, 0x11, 
	0x33, 0x17, 0x37, 0x33, 0x01, 0xf4, 0x64, 0x64, 0x64, 0x64, 0x64, 0x4b, 0xaf, 0xaf, 0x4b, 0x02, 
	0x0d, 0x64, 0x7d, 0x7d, 0x64, 0xfd, 0xf3, 0x02, 0xbc, 0xaf, 0xaf, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0a, 0x00, 0x4f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 
	0x0c, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 
	0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 
	0x08, 0xd0, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 
	0x00, 0x09, 0x2f, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x11, 0x12, 0x39, 0xba, 0x00, 0x08, 
	0x00, 0x00, 0x00, 0x06, 0x11, 0x12, 0x39, 0x30, 0x31, 0x21, 0x23, 0x35, 0x01, 0x11, 0x23, 0x11, 
	0x33, 0x01, 0x11, 0x33, 0x01, 0xf4, 0x64, 0xfe, 0xd4, 0x64, 0x45, 0x01, 0x4b, 0x64, 0xe7, 0x01, 
	0x2c, 0xfd, 0xed, 0x02, 0xbc, 0xfe, 0xb5, 0x01, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0f, 0x00, 0x1f, 0x00, 0x43, 0xb8, 0x00, 0x20, 0x2f, 
	0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x07, 0xd0, 
	0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x07, 0x10, 
	0xb8, 0x00, 0x19, 0xdc, 0x00, 0xba, 0x00, 0x1d, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 
	0x10, 0xba, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x03, 
	0x11, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 
	0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 
	0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 
	0x52, 0xfe, 0xd4, 0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0a, 0x00, 0x13, 0x00, 0x96, 
	0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 
	0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x0b, 0xdc, 0x41, 0x05, 0x00, 0x6a, 0x00, 0x0b, 0x00, 0x7a, 0x00, 0x0b, 0x00, 0x02, 
	0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x0b, 0x00, 0xa9, 0x00, 0x0b, 0x00, 0xb9, 0x00, 0x0b, 0x00, 
	0xc9, 0x00, 0x0b, 0x00, 0xd9, 0x00, 0x0b, 0x00, 0xe9, 0x00, 0x0b, 0x00, 0xf9, 0x00, 0x0b, 0x00, 
	0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x0b, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x29, 0x00, 0x0b, 
	0x00, 0x39, 0x00, 0x0b, 0x00, 0x49, 0x00, 0x0b, 0x00, 0x59, 0x00, 0x0b, 0x00, 0x06, 0x71, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x08, 0x00, 
	0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xba, 0x00, 0x11, 0x00, 0x03, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x11, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x11, 0x23, 0x11, 0x21, 0x32, 
	0x16, 0x07, 0x34, 0x26, 0x2b, 0x01, 0x15, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0xc8, 0x64, 
	0x01, 0x2c, 0x53, 0x75, 0x64, 0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 0x01, 0xf4, 0x52, 0x76, 0xfe, 
	0xd4, 0x02, 0xbc, 0x75, 0x53, 0x29, 0x3b, 0xc8, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0xff, 0x92, 0x01, 0xff, 0x02, 0xbc, 0x00, 0x13, 0x00, 0x25, 0x00, 0x45, 0xb8, 0x00, 0x26, 0x2f, 
	0xb8, 0x00, 0x27, 0x2f, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 
	0xb8, 0x00, 0x27, 0x10, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x14, 0xdc, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x1d, 0xdc, 0xba, 0x00, 0x21, 0x00, 0x08, 0x00, 0x11, 0x11, 0x12, 0x39, 0x00, 0xb8, 
	0x00, 0x01, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0x30, 
	0x31, 0x05, 0x07, 0x27, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 
	0x16, 0x15, 0x11, 0x14, 0x07, 0x27, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x11, 0x14, 
	0x16, 0x3f, 0x01, 0x27, 0x37, 0x17, 0x36, 0x01, 0xff, 0x47, 0x70, 0x12, 0x0a, 0x64, 0x52, 0x76, 
	0x76, 0x52, 0x64, 0x52, 0x76, 0x4a, 0x1a, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x1d, 0x27, 
	0x47, 0x5e, 0x2d, 0x26, 0x48, 0x70, 0x02, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0xfe, 
	0xd4, 0x60, 0x3b, 0x9b, 0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x2a, 0x3b, 0x01, 0x01, 
	0x27, 0x46, 0x5e, 0x1e, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x11, 
	0x00, 0x1a, 0x00, 0x6f, 0xb8, 0x00, 0x1b, 0x2f, 0xb8, 0x00, 0x1c, 0x2f, 0xb8, 0x00, 0x11, 0xdc, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x1b, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 
	0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xba, 0x00, 0x0e, 0x00, 
	0x11, 0x00, 0x00, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 
	0x00, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 
	0x00, 0x09, 0x00, 0x19, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x13, 0x00, 0x04, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xba, 0x00, 0x0e, 0x00, 0x04, 0x00, 0x13, 0x11, 0x12, 
	0x39, 0x30, 0x31, 0x21, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x11, 0x23, 0x11, 0x21, 0x32, 0x16, 0x15, 
	0x14, 0x07, 0x16, 0x1d, 0x01, 0x01, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x01, 0x90, 
	0x3b, 0x29, 0xc8, 0x64, 0x01, 0x2c, 0x53, 0x75, 0x55, 0x55, 0xfe, 0x70, 0xc8, 0x29, 0x3b, 0x3b, 
	0x29, 0xc8, 0xc8, 0x29, 0x3b, 0xfe, 0xd4, 0x02, 0xbc, 0x75, 0x53, 0x5a, 0x3c, 0x3c, 0x5a, 0xc8, 
	0x01, 0x90, 0x3b, 0x29, 0x29, 0x3b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x2b, 0x00, 0xb6, 0xb8, 0x00, 0x2c, 0x2f, 0xb8, 0x00, 0x2d, 0x2f, 0xb8, 0x00, 
	0x00, 0xdc, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 
	0x08, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0f, 0xdc, 0x41, 0x05, 0x00, 0x6a, 0x00, 0x0f, 
	0x00, 0x7a, 0x00, 0x0f, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x0f, 0x00, 0xa9, 0x00, 
	0x0f, 0x00, 0xb9, 0x00, 0x0f, 0x00, 0xc9, 0x00, 0x0f, 0x00, 0xd9, 0x00, 0x0f, 0x00, 0xe9, 0x00, 
	0x0f, 0x00, 0xf9, 0x00, 0x0f, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x0f, 0x00, 0x19, 
	0x00, 0x0f, 0x00, 0x29, 0x00, 0x0f, 0x00, 0x39, 0x00, 0x0f, 0x00, 0x49, 0x00, 0x0f, 0x00, 0x59, 
	0x00, 0x0f, 0x00, 0x06, 0x71, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0xb8, 0x00, 0x00, 
	0x10, 0xb8, 0x00, 0x1d, 0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 0xb8, 0x00, 0x08, 
	0x10, 0xb8, 0x00, 0x25, 0xd0, 0x00, 0xba, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x0c, 0x10, 0xba, 0x00, 0x1a, 0x00, 0x21, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1a, 0x10, 0xba, 0x00, 
	0x29, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x29, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 
	0x01, 0x22, 0x26, 0x35, 0x33, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 
	0x22, 0x26, 0x35, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 
	0x06, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x16, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x52, 0x76, 0xc8, 0x52, 0x76, 0x75, 0x53, 0x29, 
	0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x76, 0x52, 0x52, 0x76, 0x76, 0x52, 0x29, 0x3b, 0x3b, 0x29, 0x29, 
	0x3b, 0x76, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x07, 
	0x00, 0x27, 0xba, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x02, 0x10, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xba, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xb8, 
	0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 
	0x21, 0x01, 0xf4, 0xc8, 0x64, 0xc8, 0x01, 0xf4, 0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0x64, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x13, 0x00, 0x3b, 0xb8, 0x00, 
	0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x11, 0xdc, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x12, 0x2f, 0xba, 0x00, 0x0e, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 0xf4, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0xc8, 0x53, 0x75, 0x75, 0x53, 
	0x01, 0xf4, 0xfe, 0x0c, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x09, 0x00, 0x3d, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 
	0x0b, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0xb8, 0x00, 
	0x02, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0x00, 0xb8, 
	0x00, 0x01, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xba, 0x00, 0x06, 0x00, 0x01, 
	0x00, 0x03, 0x11, 0x12, 0x39, 0x30, 0x31, 0x01, 0x0b, 0x01, 0x35, 0x33, 0x15, 0x1b, 0x01, 0x35, 
	0x33, 0x01, 0xf4, 0xfa, 0xfa, 0x64, 0x96, 0x96, 0x64, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0xc8, 
	0xb1, 0xfe, 0xd6, 0x01, 0x2c, 0xaf, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0e, 0x00, 0x8d, 0xb8, 0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 
	0x04, 0x2f, 0xb8, 0x00, 0x08, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x08, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0x90, 0x00, 0x08, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x08, 0x00, 0x01, 
	0x71, 0xb8, 0x00, 0x0c, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x0c, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0x50, 0x00, 0x0c, 0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0x90, 0x00, 0x0c, 0x00, 0x01, 0x5d, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x0b, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0x00, 0xb8, 0x00, 0x00, 
	0x2f, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xba, 0x00, 0x07, 
	0x00, 0x00, 0x00, 0x05, 0x11, 0x12, 0x39, 0xba, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x05, 0x11, 0x12, 
	0x39, 0x30, 0x31, 0x21, 0x23, 0x27, 0x07, 0x23, 0x11, 0x33, 0x11, 0x37, 0x35, 0x33, 0x15, 0x17, 
	0x11, 0x33, 0x01, 0xf4, 0x4b, 0xaf, 0xaf, 0x4b, 0x64, 0x64, 0x64, 0x64, 0x64, 0xaf, 0xaf, 0x02, 
	0xbc, 0xfd, 0xf3, 0x64, 0x7d, 0x7d, 0x64, 0x02, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x13, 0x00, 0x53, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 
	0x15, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 
	0x09, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 
	0x0e, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 
	0x00, 0x05, 0x2f, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0f, 0x2f, 0x30, 0x31, 0x21, 0x23, 0x35, 
	0x27, 0x07, 0x15, 0x23, 0x35, 0x37, 0x27, 0x35, 0x33, 0x15, 0x17, 0x37, 0x35, 0x33, 0x15, 0x07, 
	0x17, 0x01, 0xf4, 0x64, 0x96, 0x96, 0x64, 0xb5, 0xb5, 0x64, 0x96, 0x96, 0x64, 0xb5, 0xb5, 0x83, 
	0x96, 0x96, 0x83, 0xa9, 0xb5, 0xb5, 0xa9, 0x83, 0x96, 0x96, 0x83, 0xa9, 0xb5, 0xb5, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0c, 0x00, 0x75, 0xb8, 0x00, 
	0x0d, 0x2f, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x03, 0xdc, 0x41, 0x03, 
	0x00, 0xf0, 0x00, 0x03, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 0x00, 0x03, 0x00, 0x01, 0x5d, 
	0x41, 0x03, 0x00, 0x50, 0x00, 0x03, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x0a, 0xdc, 0x41, 0x03, 0x00, 
	0x90, 0x00, 0x0a, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x0a, 0x00, 0x01, 0x71, 0x41, 
	0x03, 0x00, 0xf0, 0x00, 0x0a, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x03, 0x10, 
	0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x0e, 0xdc, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0b, 
	0x2f, 0x30, 0x31, 0x01, 0x07, 0x15, 0x23, 0x35, 0x27, 0x11, 0x33, 0x15, 0x17, 0x37, 0x35, 0x33, 
	0x01, 0xf4, 0xc8, 0x64, 0xc8, 0x64, 0x96, 0x96, 0x64, 0x01, 0xaf, 0xc8, 0xe7, 0xe7, 0xc8, 0x01, 
	0x0d, 0xe7, 0x96, 0x96, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x1b, 0x00, 0xba, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0b, 0x10, 0xba, 0x00, 0x07, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0x30, 
	0x31, 0x29, 0x01, 0x35, 0x01, 0x35, 0x21, 0x35, 0x21, 0x15, 0x01, 0x15, 0x21, 0x01, 0xf4, 0xfe, 
	0x0c, 0x01, 0x90, 0xfe, 0x70, 0x01, 0xf4, 0xfe, 0x70, 0x01, 0x90, 0xb3, 0x01, 0x8f, 0x16, 0x64, 
	0xa2, 0xfe, 0x70, 0x26, 0x00, 0x01, 0x00, 0xc8, 0xff, 0x9d, 0x01, 0x90, 0x03, 0x20, 0x00, 0x07, 
	0x00, 0x33, 0xba, 0x00, 0x06, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x03, 0xd0, 0x00, 0xba, 0x00, 0x07, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0x30, 0x31, 0x05, 0x23, 0x11, 0x33, 0x15, 0x23, 0x11, 0x33, 0x01, 0x90, 0xc8, 
	0xc8, 0x64, 0x64, 0x63, 0x03, 0x83, 0x64, 0xfd, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x23, 
	0xff, 0x42, 0x02, 0x58, 0x03, 0x21, 0x00, 0x03, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 
	0x00, 0x01, 0x2f, 0x30, 0x31, 0x05, 0x07, 0x01, 0x37, 0x02, 0x58, 0x52, 0xfe, 0x1d, 0x59, 0x91, 
	0x2d, 0x03, 0xb1, 0x2e, 0x00, 0x01, 0x00, 0x64, 0xff, 0x9d, 0x01, 0x2c, 0x03, 0x20, 0x00, 0x07, 
	0x00, 0x2f, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0xba, 0x00, 0x06, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x30, 
	0x31, 0x05, 0x23, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x01, 0x2c, 0xc8, 0x64, 0x64, 0xc8, 0x63, 
	0x63, 0x02, 0xbc, 0x64, 0x00, 0x01, 0x00, 0x02, 0x01, 0x80, 0x02, 0x14, 0x02, 0xd1, 0x00, 0x05, 
	0x00, 0x0f, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0x30, 
	0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x01, 0x02, 0x14, 0x46, 0xc3, 0xc2, 0x47, 0x01, 0x09, 0x01, 
	0xc7, 0x47, 0xc3, 0xc2, 0x47, 0x01, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xff, 0x39, 0x02, 0x58, 
	0xff, 0x9d, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0x30, 0x31, 0x05, 0x21, 0x35, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0xc7, 
	0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x51, 0x02, 0x39, 0x01, 0x38, 0x03, 0x20, 0x00, 0x03, 
	0x00, 0x0b, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x27, 
	0x37, 0x01, 0x38, 0x44, 0xa3, 0x45, 0x02, 0x7d, 0x44, 0xa2, 0x45, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x4b, 0xb8, 0x00, 0x1a, 0x2f, 
	0xb8, 0x00, 0x1b, 0x2f, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x1a, 0x10, 
	0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x12, 0xdc, 0xb8, 0x00, 0x02, 0x10, 
	0xb8, 0x00, 0x18, 0xd0, 0x00, 0xba, 0x00, 0x15, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x15, 
	0x10, 0xba, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x06, 
	0x10, 0xb8, 0x00, 0x01, 0xd0, 0x30, 0x31, 0x01, 0x11, 0x23, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 
	0x3d, 0x01, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 
	0x35, 0x01, 0xf4, 0x64, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x32, 
	0x32, 0x64, 0x01, 0xf4, 0xfe, 0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x15, 0x00, 0x47, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x17, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 
	0xb8, 0x00, 0x12, 0xdc, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0c, 0xdc, 
	0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 
	0x10, 0xba, 0x00, 0x08, 0x00, 0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x23, 0x21, 0x11, 0x33, 0x15, 0x33, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 
	0x01, 0x11, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0xfe, 0xd4, 0x64, 0xc8, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x02, 0xbc, 0xc8, 0x76, 0x52, 0x64, 0x64, 
	0x29, 0x3b, 0xfe, 0xd4, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x01, 0xf4, 0x00, 0x19, 0x00, 0x27, 0xba, 0x00, 0x15, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x15, 0x10, 0x00, 0xba, 0x00, 0x19, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x19, 0x10, 0xba, 
	0x00, 0x09, 0x00, 0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x29, 0x01, 0x22, 
	0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 
	0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x21, 0x01, 0xf4, 0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 0x64, 
	0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0x2c, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x76, 0x52, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x15, 0x00, 0x4b, 0xb8, 0x00, 0x16, 0x2f, 
	0xb8, 0x00, 0x17, 0x2f, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 
	0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x0b, 0xdc, 0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x0c, 0xd0, 
	0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x12, 0xdc, 0x00, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 0x00, 0x0c, 
	0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0d, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x29, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 
	0x01, 0x35, 0x33, 0x03, 0x11, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x01, 0xf4, 0xfe, 
	0xd4, 0x52, 0x76, 0x76, 0x52, 0xc8, 0x64, 0x64, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x76, 0x52, 0x64, 
	0x52, 0x76, 0xc8, 0xfd, 0xa8, 0x01, 0x2c, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x12, 0x00, 0x1a, 0x00, 0x47, 0xba, 0x00, 0x0e, 0x00, 
	0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x1a, 0xd0, 0x00, 0xba, 0x00, 0x12, 
	0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xba, 0x00, 0x09, 0x00, 0x16, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x05, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 
	0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x13, 
	0xd0, 0x30, 0x31, 0x29, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 
	0x01, 0x21, 0x14, 0x16, 0x33, 0x21, 0x27, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x01, 0xf4, 
	0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0xfe, 0x70, 0x3b, 0x29, 0x01, 0x2c, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x29, 0x3b, 0xc8, 
	0x29, 0x3b, 0x3b, 0x29, 0x00, 0x01, 0x00, 0x64, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x11, 
	0x00, 0x47, 0xba, 0x00, 0x08, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x04, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xba, 
	0x00, 0x11, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x22, 0x06, 0x15, 0x33, 0x15, 
	0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 0x33, 0x34, 0x36, 0x3b, 0x01, 0x01, 0xf4, 0x64, 0x29, 0x3b, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x76, 0x52, 0x64, 0x02, 0x58, 0x3b, 0x29, 0x64, 0xfe, 0x70, 0x01, 
	0x90, 0x64, 0x52, 0x76, 0x00, 0x02, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x12, 
	0x00, 0x1c, 0x00, 0x53, 0xb8, 0x00, 0x1d, 0x2f, 0xb8, 0x00, 0x1e, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x19, 0xdc, 
	0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x09, 0xdc, 0xb8, 0x00, 0x13, 0xd0, 
	0x00, 0xba, 0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xba, 0x00, 0x12, 
	0x00, 0x14, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xba, 0x00, 0x13, 0x00, 0x09, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x13, 0x10, 0x30, 0x31, 0x21, 0x14, 0x06, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 
	0x35, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x21, 0x03, 0x11, 0x23, 0x22, 0x06, 0x1d, 
	0x01, 0x14, 0x16, 0x33, 0x01, 0xf4, 0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 
	0x52, 0x01, 0x2c, 0x64, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x52, 0x75, 0x64, 0x3b, 0x28, 0x76, 0x52, 
	0x64, 0x52, 0x76, 0xfe, 0x70, 0x01, 0x2c, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0f, 0x00, 0x3f, 0xb8, 0x00, 0x10, 0x2f, 0xb8, 0x00, 
	0x11, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 
	0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x0a, 0xd0, 0x00, 0xb8, 
	0x00, 0x09, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0xba, 0x00, 0x0c, 0x00, 0x05, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x21, 0x23, 0x11, 0x34, 0x26, 0x2b, 0x01, 
	0x11, 0x23, 0x11, 0x33, 0x15, 0x33, 0x32, 0x16, 0x15, 0x01, 0xf4, 0x64, 0x3b, 0x29, 0xc8, 0x64, 
	0x64, 0xc8, 0x52, 0x76, 0x01, 0x2c, 0x29, 0x3b, 0xfe, 0x70, 0x02, 0xbc, 0xc8, 0x76, 0x52, 0x00, 
	0x00, 0x02, 0x00, 0x64, 0x00, 0x00, 0x01, 0x90, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x15, 0x00, 0x09, 
	0x00, 0x7d, 0xb8, 0x00, 0x09, 0x2f, 0x18, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x36, 0x33, 0x32, 0x16, 0x13, 0x21, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x01, 
	0x2c, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 
	0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x64, 0x01, 0x2c, 0x64, 0xfe, 
	0x70, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0x39, 0x01, 0x2c, 0x02, 0xbc, 0x00, 0x0b, 
	0x00, 0x19, 0x00, 0x1c, 0x00, 0x7d, 0xb8, 0x00, 0x09, 0x2f, 0x18, 0x30, 0x31, 0x01, 0x41, 0x03, 
	0x00, 0xd1, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc2, 0x00, 0x0e, 0x00, 0x01, 0x5d, 
	0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x11, 0x14, 0x06, 0x2b, 
	0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x11, 0x23, 0x35, 0x33, 0x01, 0x2c, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x64, 0xc8, 0x02, 0x8a, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x52, 0x75, 0x64, 0x3b, 0x28, 0x01, 0x90, 0x64, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0c, 0x00, 0x0b, 0x30, 0x31, 
	0x41, 0x03, 0x00, 0xc3, 0x00, 0x0a, 0x00, 0x01, 0x5d, 0x21, 0x23, 0x27, 0x07, 0x15, 0x23, 0x11, 
	0x33, 0x11, 0x37, 0x33, 0x07, 0x17, 0x01, 0xf4, 0x45, 0xe7, 0x64, 0x64, 0x64, 0xe7, 0x8a, 0xc8, 
	0xe7, 0xe7, 0x64, 0x83, 0x02, 0xbc, 0xfe, 0x51, 0xe7, 0xc8, 0xe7, 0x00, 0x00, 0x01, 0x00, 0x64, 
	0x00, 0x00, 0x01, 0x90, 0x02, 0xbc, 0x00, 0x09, 0x00, 0x3b, 0xba, 0x00, 0x08, 0x00, 0x02, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 
	0x05, 0xd0, 0x00, 0xba, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 
	0x00, 0x06, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x02, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x01, 
	0x90, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 0xf4, 0x64, 0xfd, 0xa8, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x10, 0x00, 0x89, 0xb8, 0x00, 
	0x11, 0x2f, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x07, 0xdc, 0x41, 0x03, 
	0x00, 0x90, 0x00, 0x07, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x07, 0x00, 0x01, 0x5d, 
	0x41, 0x03, 0x00, 0x50, 0x00, 0x07, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x01, 0xdc, 0x41, 0x03, 0x00, 
	0x90, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0x50, 0x00, 0x01, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x07, 0x10, 
	0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x0a, 0xdc, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x12, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0a, 
	0x2f, 0xba, 0x00, 0x0d, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x05, 
	0x10, 0xb8, 0x00, 0x08, 0xd0, 0x30, 0x31, 0x21, 0x23, 0x11, 0x34, 0x26, 0x23, 0x11, 0x23, 0x11, 
	0x23, 0x11, 0x23, 0x11, 0x21, 0x32, 0x16, 0x15, 0x01, 0xf4, 0x64, 0x3b, 0x29, 0x64, 0x64, 0x64, 
	0x01, 0x2c, 0x52, 0x76, 0x01, 0x2c, 0x29, 0x3b, 0xfe, 0x70, 0x01, 0x90, 0xfe, 0x70, 0x01, 0xf4, 
	0x76, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x13, 
	0x00, 0x4d, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x12, 0xd0, 0xb8, 0x00, 0x12, 0x2f, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 
	0x15, 0x10, 0xb8, 0x00, 0x08, 0xdc, 0xba, 0x00, 0x01, 0x00, 0x12, 0x00, 0x08, 0x11, 0x12, 0x39, 
	0xb8, 0x00, 0x09, 0xdc, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x11, 0x2f, 0xba, 0x00, 0x04, 
	0x00, 0x0d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x30, 0x31, 0x13, 
	0x15, 0x37, 0x36, 0x33, 0x32, 0x16, 0x15, 0x11, 0x23, 0x11, 0x34, 0x26, 0x23, 0x22, 0x0f, 0x01, 
	0x15, 0x23, 0x11, 0x64, 0x3f, 0x4b, 0x3e, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 
	0x01, 0xf4, 0x89, 0x3e, 0x4b, 0x75, 0x53, 0xfe, 0xd4, 0x01, 0x2c, 0x29, 0x3b, 0x32, 0x64, 0xfa, 
	0x01, 0xf4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x0f, 
	0x00, 0x1f, 0x00, 0x43, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x19, 0xdc, 0x00, 0xba, 0x00, 0x1d, 
	0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x14, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 
	0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 
	0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 
	0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0xc8, 0x52, 
	0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 
	0x3b, 0x3b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x0b, 
	0x00, 0x15, 0x00, 0x4b, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x17, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 
	0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0c, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x11, 0xd0, 
	0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x08, 0x00, 0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 
	0x10, 0xba, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x2b, 0x01, 0x15, 0x23, 0x11, 0x21, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 
	0x01, 0x11, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0xc8, 0x64, 0x01, 0x2c, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0xc7, 0x02, 0xbb, 0x76, 0x52, 0x64, 0x64, 
	0x29, 0x3b, 0xfe, 0xd4, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 
	0x01, 0xf4, 0x00, 0x0b, 0x00, 0x15, 0x00, 0x4b, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x17, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x06, 0xd0, 
	0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x06, 0x10, 
	0xb8, 0x00, 0x12, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x0d, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 
	0x10, 0x30, 0x31, 0x05, 0x23, 0x35, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x21, 0x03, 
	0x11, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x01, 0xf4, 0x64, 0xc8, 0x52, 0x76, 0x76, 
	0x52, 0x01, 0x2c, 0x64, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0xc7, 0xc7, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0xfe, 0x70, 0x01, 0x2c, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x11, 0x00, 0x27, 0xba, 0x00, 0x0f, 0x00, 0x10, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x00, 0xb8, 0x00, 0x0f, 0x2f, 0xba, 
	0x00, 0x04, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x30, 
	0x31, 0x13, 0x15, 0x37, 0x36, 0x33, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x23, 0x22, 0x0f, 0x01, 
	0x15, 0x23, 0x11, 0x64, 0x3f, 0x4b, 0x3e, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 
	0x01, 0xf4, 0x89, 0x3e, 0x4b, 0x75, 0x53, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0x01, 0xf4, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x1f, 0x00, 0x27, 0x00, 0xba, 
	0x00, 0x12, 0x00, 0x0f, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xba, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x00, 0x10, 0xba, 0x00, 0x09, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x09, 0x10, 0x30, 0x31, 0x01, 0x15, 0x21, 0x22, 0x06, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 
	0x16, 0x15, 0x14, 0x06, 0x23, 0x21, 0x35, 0x21, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x01, 0xf4, 0xfe, 0xfa, 0x34, 0x49, 0x49, 0x34, 0x19, 0x5d, 0x84, 
	0x84, 0x5d, 0xfe, 0xf9, 0x01, 0x07, 0x33, 0x4a, 0x4a, 0x33, 0x19, 0x5e, 0x83, 0x83, 0x5e, 0x01, 
	0xf4, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x58, 0x3e, 0x3e, 0x58, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x58, 
	0x3e, 0x3e, 0x58, 0x00, 0x00, 0x01, 0x00, 0x64, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x13, 
	0x00, 0x47, 0xba, 0x00, 0x0f, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 
	0x04, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0x00, 0xb8, 
	0x00, 0x09, 0x2f, 0xba, 0x00, 0x13, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xba, 
	0x00, 0x08, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0x30, 0x31, 0x21, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x23, 
	0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x01, 0xf4, 0x64, 
	0x52, 0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x3b, 0x29, 0x64, 0x76, 0x52, 0xc8, 0x64, 0xc8, 0xc8, 
	0x64, 0xc8, 0x29, 0x3b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x13, 
	0x00, 0x47, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x13, 0xdc, 0xb8, 0x00, 
	0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 
	0x0a, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 
	0x00, 0x11, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 
	0x00, 0x04, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x30, 0x31, 0x21, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 
	0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x33, 0x11, 0x01, 0x90, 0x3e, 
	0x4b, 0x3f, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 
	0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0xfe, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x0a, 0x00, 0x19, 0x00, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 
	0x00, 0x04, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0xba, 0x00, 0x07, 0x00, 0x01, 0x00, 0x04, 0x11, 0x12, 
	0x39, 0x30, 0x31, 0x01, 0x03, 0x23, 0x03, 0x35, 0x33, 0x15, 0x1b, 0x01, 0x35, 0x33, 0x01, 0xf4, 
	0xc8, 0x64, 0xc8, 0x64, 0x96, 0x96, 0x64, 0x01, 0x90, 0xfe, 0x70, 0x01, 0x90, 0x64, 0x4b, 0xfe, 
	0xd4, 0x01, 0x2c, 0x4b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x1f, 
	0x00, 0x95, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 
	0x08, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x0e, 0xdc, 0x41, 0x03, 0x00, 0x90, 0x00, 0x0e, 
	0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 
	0x00, 0x0e, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x17, 
	0xdc, 0x41, 0x03, 0x00, 0x90, 0x00, 0x17, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x17, 
	0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x17, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x1a, 0xdc, 
	0xb8, 0x00, 0x21, 0xdc, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x18, 
	0x2f, 0xba, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0b, 
	0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x02, 
	0x10, 0xb8, 0x00, 0x1d, 0xd0, 0x30, 0x31, 0x37, 0x06, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 
	0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x11, 
	0x33, 0x11, 0x14, 0x06, 0x23, 0x22, 0x27, 0xf4, 0x29, 0x35, 0x3e, 0x58, 0x64, 0x1d, 0x15, 0x15, 
	0x1d, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x35, 0x29, 0x64, 0x64, 0x84, 0x5d, 0x01, 
	0x13, 0xfe, 0xed, 0x34, 0x4a, 0x4a, 0x34, 0x01, 0x13, 0xfe, 0xed, 0x34, 0x49, 0x49, 0x34, 0x01, 
	0x13, 0xfe, 0xed, 0x5d, 0x84, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x01, 0xf4, 0x00, 0x13, 0x00, 0x13, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 
	0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0f, 0x2f, 0x30, 0x31, 0x21, 0x23, 0x35, 0x27, 0x07, 0x15, 0x23, 
	0x35, 0x37, 0x27, 0x35, 0x33, 0x15, 0x17, 0x37, 0x35, 0x33, 0x15, 0x07, 0x17, 0x01, 0xf4, 0x64, 
	0x96, 0x96, 0x64, 0xb5, 0xb5, 0x64, 0x96, 0x96, 0x64, 0xb5, 0xb5, 0x1f, 0x96, 0x96, 0x1f, 0x45, 
	0xb5, 0xb5, 0x45, 0x1f, 0x96, 0x96, 0x1f, 0x45, 0xb5, 0xb5, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xff, 0x39, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x16, 0x00, 0x4f, 0xb8, 0x00, 0x17, 0x2f, 0xb8, 0x00, 
	0x18, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 
	0x0d, 0x2f, 0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x09, 0xdc, 0xb8, 0x00, 0x14, 0xd0, 0x00, 0xb8, 0x00, 0x0e, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xba, 
	0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xba, 0x00, 0x14, 0x00, 0x09, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0x30, 0x31, 0x21, 0x14, 0x06, 0x2b, 0x01, 0x35, 0x33, 
	0x32, 0x36, 0x35, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x11, 0x33, 
	0x01, 0xf4, 0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x64, 0x3b, 0x29, 0xc8, 0x64, 
	0x52, 0x75, 0x64, 0x3b, 0x28, 0x76, 0x52, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x01, 0x90, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x09, 0x00, 0x1b, 0x00, 0xba, 
	0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x06, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x30, 0x31, 0x29, 0x01, 0x35, 0x01, 0x21, 0x35, 0x21, 
	0x15, 0x01, 0x21, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0x4b, 0xfe, 0xb5, 0x01, 0xf4, 0xfe, 0xb5, 0x01, 
	0x4b, 0x45, 0x01, 0x4b, 0x64, 0x45, 0xfe, 0xb5, 0x00, 0x01, 0x00, 0x64, 0xff, 0x39, 0x01, 0x90, 
	0x03, 0x84, 0x00, 0x1d, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0x30, 
	0x31, 0x05, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x26, 0x23, 0x35, 0x32, 0x36, 0x3d, 0x01, 0x34, 0x36, 
	0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x07, 0x15, 0x16, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x01, 
	0x90, 0x53, 0x75, 0x3b, 0x29, 0x29, 0x3b, 0x75, 0x53, 0x29, 0x3b, 0x64, 0x64, 0x3b, 0x29, 0xc7, 
	0x67, 0x48, 0xe0, 0x29, 0x3b, 0x64, 0x3b, 0x29, 0xe1, 0x48, 0x67, 0x64, 0x3b, 0x29, 0xfa, 0x35, 
	0x29, 0x0c, 0x29, 0x35, 0xfa, 0x28, 0x3b, 0x00, 0x00, 0x01, 0x00, 0xc8, 0xff, 0x9d, 0x01, 0x2c, 
	0x03, 0x20, 0x00, 0x03, 0x00, 0x13, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0x30, 0x31, 0x05, 0x23, 0x11, 0x33, 0x01, 0x2c, 0x64, 
	0x64, 0x63, 0x03, 0x83, 0x00, 0x01, 0x00, 0x64, 0xff, 0x39, 0x01, 0x90, 0x03, 0x84, 0x00, 0x1d, 
	0x00, 0x0b, 0x00, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0x30, 0x31, 0x01, 0x22, 0x06, 
	0x1d, 0x01, 0x14, 0x06, 0x23, 0x35, 0x32, 0x36, 0x3d, 0x01, 0x34, 0x37, 0x35, 0x26, 0x3d, 0x01, 
	0x34, 0x26, 0x23, 0x35, 0x32, 0x16, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x01, 0x90, 0x29, 0x3b, 0x75, 
	0x53, 0x29, 0x3b, 0x64, 0x64, 0x3b, 0x29, 0x53, 0x75, 0x3b, 0x29, 0x01, 0x2c, 0x3b, 0x29, 0xe0, 
	0x48, 0x67, 0x64, 0x3b, 0x28, 0xfa, 0x35, 0x29, 0x0c, 0x29, 0x35, 0xfa, 0x29, 0x3b, 0x64, 0x67, 
	0x48, 0xe1, 0x29, 0x3b, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x19, 
	0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 
	0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 
	0x33, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 
	0x3f, 0x25, 0x15, 0x1d, 0x64, 0x01, 0xc2, 0x3e, 0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 
	0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0x00, 0x00, 0x00, 0x02, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x90, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x6a, 0xba, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x2b, 
	0x41, 0x0f, 0x00, 0x96, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0xc6, 
	0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x00, 0x00, 0x07, 
	0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
	0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x06, 0x71, 0x41, 0x05, 
	0x00, 0x65, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x02, 0x71, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 
	0x00, 0x06, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0x00, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x0c, 0x2f, 
	0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x11, 0x23, 
	0x11, 0x33, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x64, 0x64, 0x02, 0x8a, 
	0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x01, 0xf4, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0xff, 0x9d, 0x01, 0xf4, 0x02, 0x58, 0x00, 0x17, 0x00, 0x1f, 0x00, 0x87, 0xb8, 0x00, 0x20, 0x2f, 
	0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 0x20, 0x10, 
	0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 
	0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x15, 0xd0, 
	0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x1d, 0xdc, 
	0x00, 0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 0x00, 0x17, 0x00, 0x00, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x17, 0x10, 0xba, 0x00, 0x0e, 0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 
	0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x0b, 
	0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x19, 
	0xd0, 0x30, 0x31, 0x21, 0x23, 0x15, 0x23, 0x35, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x35, 
	0x33, 0x15, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x23, 0x11, 0x33, 0x21, 0x11, 0x22, 0x06, 0x1d, 
	0x01, 0x14, 0x16, 0x01, 0xf4, 0xc8, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 
	0x29, 0xc8, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x63, 0x63, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x64, 
	0x76, 0x52, 0x29, 0x3b, 0xfe, 0xd4, 0x01, 0x2c, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x1b, 0x00, 0x37, 0xba, 0x00, 
	0x17, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0x00, 0xba, 
	0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 0x08, 0x00, 0x0f, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xba, 0x00, 0x14, 0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x14, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x23, 0x21, 0x11, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x15, 0x23, 0x34, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x33, 0x15, 0x23, 0x11, 0x33, 0x32, 0x36, 
	0x35, 0x01, 0xf4, 0x7a, 0x4e, 0xfe, 0xd4, 0x76, 0x52, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x29, 0x3b, 
	0xc8, 0xc8, 0xc8, 0x24, 0x40, 0xc8, 0x4e, 0x7a, 0x02, 0x58, 0x52, 0x76, 0x76, 0x52, 0x29, 0x3b, 
	0x3b, 0x29, 0x64, 0x64, 0xfe, 0xd4, 0x40, 0x24, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x01, 0xf4, 0x00, 0x1b, 0x00, 0x27, 0x00, 0x13, 0x00, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x07, 
	0x2f, 0xb8, 0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0x30, 0x31, 0x25, 0x07, 0x27, 0x06, 0x23, 
	0x22, 0x27, 0x07, 0x27, 0x37, 0x26, 0x35, 0x34, 0x37, 0x27, 0x37, 0x17, 0x36, 0x33, 0x32, 0x17, 
	0x37, 0x17, 0x07, 0x16, 0x15, 0x14, 0x07, 0x27, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 
	0x33, 0x32, 0x36, 0x01, 0xf4, 0x47, 0x72, 0x1e, 0x23, 0x23, 0x1e, 0x72, 0x47, 0x73, 0x0f, 0x0f, 
	0x73, 0x47, 0x72, 0x1e, 0x23, 0x23, 0x1e, 0x72, 0x47, 0x73, 0x0f, 0x0f, 0x55, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x47, 0x47, 0x73, 0x0f, 0x0f, 0x73, 0x47, 0x72, 0x1e, 0x23, 0x23, 
	0x1e, 0x72, 0x47, 0x73, 0x0f, 0x0f, 0x73, 0x47, 0x72, 0x1e, 0x23, 0x23, 0x1e, 0x41, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x19, 
	0x02, 0xcf, 0x00, 0x16, 0x00, 0x69, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x09, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0x00, 0xb8, 
	0x00, 0x14, 0x2f, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0xba, 0x00, 0x06, 0x00, 0x07, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xba, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x02, 0x10, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 
	0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 
	0x00, 0x11, 0xd0, 0xba, 0x00, 0x12, 0x00, 0x09, 0x00, 0x14, 0x11, 0x12, 0x39, 0x30, 0x31, 0x01, 
	0x07, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 
	0x35, 0x33, 0x27, 0x37, 0x17, 0x37, 0x02, 0x19, 0x96, 0x84, 0xc8, 0xc8, 0xc8, 0x64, 0xc8, 0xc8, 
	0xc8, 0x83, 0x96, 0x45, 0xc8, 0xc8, 0x02, 0x8a, 0x96, 0x64, 0x64, 0x64, 0xc8, 0xc8, 0x64, 0x64, 
	0x64, 0x96, 0x45, 0xc8, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xc8, 0xff, 0x9d, 0x01, 0x2c, 
	0x03, 0x20, 0x00, 0x03, 0x00, 0x07, 0x00, 0x1f, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xb8, 0x00, 0x02, 
	0x2f, 0xb8, 0x00, 0x04, 0x2f, 0x30, 0x31, 0x01, 0x23, 0x11, 0x33, 0x11, 0x23, 0x11, 0x33, 0x01, 
	0x2c, 0x64, 0x64, 0x64, 0x64, 0x01, 0x90, 0x01, 0x90, 0xfc, 0x7d, 0x01, 0x8f, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0xff, 0x9d, 0x01, 0xf5, 0x03, 0x84, 0x00, 0x1a, 0x00, 0x34, 0x00, 0x63, 
	0xb8, 0x00, 0x35, 0x2f, 0xb8, 0x00, 0x36, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 
	0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 
	0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x35, 0x10, 0xb8, 0x00, 0x24, 0xd0, 
	0xb8, 0x00, 0x24, 0x2f, 0xb8, 0x00, 0x27, 0xdc, 0xb8, 0x00, 0x24, 0x10, 0xb8, 0x00, 0x31, 0xd0, 
	0xb8, 0x00, 0x27, 0x10, 0xb8, 0x00, 0x33, 0xd0, 0x00, 0xba, 0x00, 0x2b, 0x00, 0x20, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x2b, 0x10, 0xba, 0x00, 0x09, 0x00, 0x13, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0x30, 0x31, 0x25, 0x23, 0x35, 0x01, 0x26, 0x35, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 
	0x16, 0x27, 0x23, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x14, 0x17, 0x01, 0x07, 0x16, 
	0x15, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x33, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 
	0x36, 0x35, 0x34, 0x27, 0x01, 0x35, 0x33, 0x15, 0x01, 0xf4, 0x64, 0xfe, 0xa2, 0x16, 0x71, 0x3b, 
	0x64, 0x53, 0x75, 0x01, 0x01, 0x64, 0x3b, 0x29, 0x70, 0x15, 0x1d, 0x06, 0x01, 0x64, 0x32, 0x16, 
	0x71, 0x3b, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x71, 0x14, 0x1e, 0x06, 0xfe, 0x9b, 0x64, 0xc8, 
	0x83, 0x01, 0x5d, 0x16, 0x20, 0x38, 0x6e, 0x75, 0x53, 0x66, 0x02, 0x64, 0x29, 0x3b, 0x1d, 0x15, 
	0x0e, 0x0a, 0xfe, 0x9b, 0xf9, 0x16, 0x20, 0x38, 0x6d, 0x75, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x1d, 
	0x15, 0x0d, 0x0b, 0x01, 0x65, 0xa9, 0x83, 0x00, 0x00, 0x02, 0x00, 0x64, 0x02, 0x58, 0x01, 0x90, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x1f, 0x00, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 
	0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 
	0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x15, 
	0x00, 0x27, 0x00, 0x39, 0x30, 0x31, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x02, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0xc4, 0x00, 0x14, 0x00, 0x01, 0x5d, 0x00, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x06, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0xce, 0x00, 0x10, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xcc, 0x00, 
	0x19, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x1b, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 
	0x23, 0x22, 0x27, 0x35, 0x16, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x23, 0x22, 0x07, 0x35, 0x36, 
	0x33, 0x32, 0x16, 0x03, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x3b, 0x01, 0x15, 0x23, 0x22, 0x06, 
	0x15, 0x14, 0x16, 0x3b, 0x01, 0x01, 0xf4, 0xcd, 0x91, 0x4f, 0x47, 0x42, 0x54, 0x68, 0x92, 0x92, 
	0x68, 0x52, 0x44, 0x47, 0x4f, 0x91, 0xcd, 0xc8, 0x96, 0x3e, 0x58, 0x58, 0x3e, 0x96, 0x96, 0x15, 
	0x1d, 0x1d, 0x15, 0x96, 0x01, 0x5e, 0x91, 0xcd, 0x22, 0x74, 0x32, 0x92, 0x68, 0x68, 0x92, 0x32, 
	0x74, 0x22, 0xcd, 0xfe, 0xd9, 0x58, 0x3e, 0x3e, 0x58, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x64, 0x01, 0x2c, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x15, 
	0x00, 0xaa, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x17, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 
	0x16, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x09, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x0d, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x12, 0xdc, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x12, 
	0x00, 0xa6, 0x00, 0x12, 0x00, 0xb6, 0x00, 0x12, 0x00, 0xc6, 0x00, 0x12, 0x00, 0xd6, 0x00, 0x12, 
	0x00, 0xe6, 0x00, 0x12, 0x00, 0xf6, 0x00, 0x12, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 
	0x12, 0x00, 0x16, 0x00, 0x12, 0x00, 0x26, 0x00, 0x12, 0x00, 0x36, 0x00, 0x12, 0x00, 0x46, 0x00, 
	0x12, 0x00, 0x56, 0x00, 0x12, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x12, 0x00, 0x75, 
	0x00, 0x12, 0x00, 0x02, 0x71, 0x00, 0xba, 0x00, 0x0c, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x0c, 0x10, 0xba, 0x00, 0x07, 0x00, 0x0f, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 
	0x0d, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0x30, 0x31, 0x01, 0x23, 0x22, 0x26, 
	0x35, 0x34, 0x36, 0x3b, 0x01, 0x11, 0x21, 0x35, 0x21, 0x27, 0x35, 0x23, 0x22, 0x06, 0x15, 0x14, 
	0x16, 0x33, 0x01, 0xf4, 0xc8, 0x52, 0x76, 0x76, 0x52, 0xc8, 0xfe, 0x70, 0x01, 0x90, 0x64, 0x64, 
	0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x76, 0x52, 0x52, 0x76, 0xfd, 0xa8, 0x64, 0xc8, 0xc8, 0x3b, 
	0x29, 0x29, 0x3b, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0xe3, 0x01, 0xea, 0x01, 0xae, 0x00, 0x05, 
	0x00, 0x0b, 0x00, 0x13, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x01, 
	0x2f, 0xb8, 0x00, 0x07, 0x2f, 0x30, 0x31, 0x25, 0x07, 0x27, 0x37, 0x17, 0x0f, 0x02, 0x27, 0x37, 
	0x17, 0x07, 0x01, 0xea, 0x5c, 0x62, 0x62, 0x5c, 0x54, 0xd8, 0x5c, 0x62, 0x62, 0x5c, 0x54, 0x09, 
	0x26, 0xe5, 0xe6, 0x27, 0xbf, 0xbf, 0x26, 0xe5, 0xe6, 0x27, 0xbf, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x64, 0x01, 0xf4, 0x01, 0x90, 0x00, 0x05, 0x00, 0x1b, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x2b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x05, 0x10, 0x30, 0x31, 0x25, 0x23, 0x35, 0x21, 0x35, 0x21, 0x01, 0xf4, 0x64, 0xfe, 0x70, 
	0x01, 0xf4, 0x64, 0xc8, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x01, 0xf4, 
	0x01, 0x90, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 0x21, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0x01, 
	0x2c, 0x64, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x64, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x20, 
	0x00, 0x29, 0x00, 0x15, 0x30, 0x31, 0x41, 0x03, 0x00, 0xc5, 0x00, 0x0f, 0x00, 0x01, 0x5d, 0x00, 
	0x41, 0x03, 0x00, 0xcc, 0x00, 0x1a, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x27, 0x23, 
	0x15, 0x23, 0x11, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 0x17, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x34, 
	0x26, 0x23, 0x22, 0x07, 0x35, 0x36, 0x33, 0x32, 0x16, 0x15, 0x21, 0x34, 0x26, 0x2b, 0x01, 0x15, 
	0x33, 0x32, 0x36, 0x01, 0xf4, 0x66, 0x49, 0x5f, 0x63, 0x1f, 0x64, 0x96, 0x3e, 0x58, 0x3c, 0x1f, 
	0x10, 0x2f, 0x42, 0x92, 0x68, 0x52, 0x44, 0x47, 0x4f, 0x91, 0xcd, 0xfe, 0xd4, 0x1d, 0x15, 0x32, 
	0x32, 0x15, 0x1d, 0x01, 0x13, 0x49, 0x66, 0x64, 0x64, 0x01, 0x90, 0x58, 0x3e, 0x4a, 0x2d, 0x1f, 
	0x42, 0x2f, 0x25, 0x68, 0x92, 0x32, 0x74, 0x22, 0xcd, 0x91, 0x15, 0x1d, 0x64, 0x1d, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x64, 0x02, 0x58, 0x01, 0x90, 0x02, 0xbc, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 
	0x21, 0x01, 0x90, 0xfe, 0xd4, 0x01, 0x2c, 0x02, 0x58, 0x64, 0x00, 0x00, 0x00, 0x02, 0x00, 0x64, 
	0x01, 0x90, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x0b, 0x00, 0x17, 0x00, 0xd9, 0xb8, 0x00, 0x18, 0x2f, 
	0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x06, 0xd0, 
	0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0c, 0xdc, 0x41, 0x05, 0x00, 0x6a, 
	0x00, 0x0c, 0x00, 0x7a, 0x00, 0x0c, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 0x0c, 0x00, 
	0xa9, 0x00, 0x0c, 0x00, 0xb9, 0x00, 0x0c, 0x00, 0xc9, 0x00, 0x0c, 0x00, 0xd9, 0x00, 0x0c, 0x00, 
	0xe9, 0x00, 0x0c, 0x00, 0xf9, 0x00, 0x0c, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 0x00, 0x0c, 
	0x00, 0x19, 0x00, 0x0c, 0x00, 0x29, 0x00, 0x0c, 0x00, 0x39, 0x00, 0x0c, 0x00, 0x49, 0x00, 0x0c, 
	0x00, 0x59, 0x00, 0x0c, 0x00, 0x06, 0x71, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x12, 0xdc, 0x41, 
	0x0f, 0x00, 0x96, 0x00, 0x12, 0x00, 0xa6, 0x00, 0x12, 0x00, 0xb6, 0x00, 0x12, 0x00, 0xc6, 0x00, 
	0x12, 0x00, 0xd6, 0x00, 0x12, 0x00, 0xe6, 0x00, 0x12, 0x00, 0xf6, 0x00, 0x12, 0x00, 0x07, 0x5d, 
	0x41, 0x0d, 0x00, 0x06, 0x00, 0x12, 0x00, 0x16, 0x00, 0x12, 0x00, 0x26, 0x00, 0x12, 0x00, 0x36, 
	0x00, 0x12, 0x00, 0x46, 0x00, 0x12, 0x00, 0x56, 0x00, 0x12, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 
	0x65, 0x00, 0x12, 0x00, 0x75, 0x00, 0x12, 0x00, 0x02, 0x71, 0x00, 0xba, 0x00, 0x15, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x15, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0f, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x09, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 
	0x16, 0x07, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x75, 
	0x53, 0x52, 0x76, 0x76, 0x52, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 
	0x02, 0x58, 0x52, 0x76, 0x76, 0x52, 0x53, 0x75, 0x76, 0x52, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 
	0x3b, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0x58, 0x00, 0x0f, 
	0x00, 0x53, 0xba, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 
	0x03, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 
	0x00, 0x08, 0x2f, 0xba, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 
	0x00, 0x07, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 
	0x00, 0x02, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 
	0x00, 0x0c, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 
	0x33, 0x15, 0x23, 0x15, 0x33, 0x01, 0xf4, 0xfe, 0x0c, 0xc8, 0xc8, 0xc8, 0x64, 0xc8, 0xc8, 0xc8, 
	0x64, 0xc8, 0x64, 0xc8, 0xc8, 0x64, 0xc8, 0x00, 0x00, 0x01, 0x00, 0x96, 0x02, 0x26, 0x01, 0x90, 
	0x03, 0x84, 0x00, 0x18, 0x00, 0x1e, 0x00, 0x41, 0x03, 0x00, 0xc5, 0x00, 0x07, 0x00, 0x01, 0x5d, 
	0x30, 0x31, 0x41, 0x03, 0x00, 0xcf, 0x00, 0x0f, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xcf, 0x00, 
	0x10, 0x00, 0x01, 0x5d, 0x01, 0x07, 0x33, 0x15, 0x23, 0x35, 0x37, 0x36, 0x35, 0x34, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x15, 0x23, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x01, 0x85, 0x9b, 
	0xa6, 0xfa, 0xc4, 0x04, 0x1d, 0x15, 0x32, 0x15, 0x1d, 0x32, 0x3b, 0x29, 0x32, 0x29, 0x3b, 0x02, 
	0xf2, 0x9a, 0x32, 0x22, 0xc5, 0x09, 0x0a, 0x15, 0x1d, 0x1d, 0x15, 0x29, 0x3b, 0x3b, 0x29, 0x19, 
	0x00, 0x01, 0x00, 0x96, 0x02, 0x26, 0x01, 0x90, 0x03, 0x84, 0x00, 0x2a, 0x00, 0x39, 0x30, 0x31, 
	0x41, 0x03, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xca, 0x00, 0x21, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0xc5, 0x00, 0x2a, 0x00, 0x01, 0x5d, 0x00, 0x41, 0x03, 0x00, 0xc0, 
	0x00, 0x00, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xcf, 0x00, 0x18, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0xc0, 0x00, 0x2a, 0x00, 0x01, 0x5d, 0x13, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x34, 
	0x26, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x23, 
	0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x07, 0x16, 0x15, 0x14, 0x06, 0x2b, 0x01, 0x22, 
	0x26, 0x35, 0xc8, 0x1d, 0x15, 0x32, 0x15, 0x1d, 0x1d, 0x15, 0x32, 0x32, 0x15, 0x1d, 0x1d, 0x15, 
	0x32, 0x15, 0x1d, 0x32, 0x3b, 0x29, 0x32, 0x29, 0x3b, 0x2a, 0x2a, 0x3b, 0x29, 0x32, 0x29, 0x3b, 
	0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x32, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x29, 
	0x3b, 0x3b, 0x29, 0x2d, 0x1e, 0x1e, 0x2d, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x01, 0x00, 0xc0, 
	0x02, 0x4c, 0x01, 0xa8, 0x03, 0x33, 0x00, 0x03, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 
	0x00, 0x00, 0x2f, 0x30, 0x31, 0x01, 0x27, 0x37, 0x17, 0x01, 0x05, 0x45, 0xa3, 0x45, 0x02, 0x4c, 
	0x44, 0xa3, 0x45, 0x00, 0x00, 0x01, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x14, 
	0x00, 0x53, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 
	0x16, 0x10, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x0e, 0xdc, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 
	0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x14, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x14, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 
	0x00, 0x0a, 0xd0, 0x30, 0x31, 0x21, 0x22, 0x27, 0x06, 0x2b, 0x01, 0x15, 0x23, 0x11, 0x33, 0x11, 
	0x33, 0x32, 0x36, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x33, 0x01, 0xf4, 0x5a, 0x3c, 0x3a, 0x5c, 
	0x64, 0x64, 0x64, 0x64, 0x29, 0x3b, 0x64, 0x3b, 0x29, 0x44, 0x44, 0xc7, 0x02, 0xbb, 0xfe, 0x70, 
	0x3b, 0x29, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x20, 0x00, 0x0d, 0x00, 0x11, 0x00, 0x18, 0x00, 0xa3, 0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 
	0x09, 0xd0, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0x41, 0x03, 0x00, 0x50, 0x00, 0x05, 
	0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0x90, 0x00, 0x05, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 
	0x00, 0x05, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x01, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x01, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 
	0x01, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x04, 0xdc, 
	0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x12, 0xd0, 
	0xba, 0x00, 0x13, 0x00, 0x09, 0x00, 0x00, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 
	0x16, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x1a, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 
	0x00, 0x04, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x0f, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 
	0x00, 0x0e, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0x30, 0x31, 0x21, 0x23, 0x11, 
	0x23, 0x11, 0x23, 0x11, 0x2e, 0x01, 0x35, 0x34, 0x36, 0x3b, 0x01, 0x03, 0x11, 0x23, 0x11, 0x27, 
	0x11, 0x0e, 0x01, 0x15, 0x14, 0x16, 0x01, 0xf4, 0x64, 0x64, 0x64, 0x56, 0x72, 0x92, 0x68, 0xfa, 
	0x64, 0x64, 0x64, 0x2c, 0x38, 0x38, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x31, 0x11, 0x8a, 0x5a, 0x68, 
	0x92, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x09, 0x01, 0x1a, 0x10, 0x4d, 0x30, 0x30, 0x4e, 0x00, 
	0x00, 0x01, 0x00, 0xc8, 0x00, 0xe1, 0x01, 0x90, 0x01, 0xa9, 0x00, 0x0b, 0x00, 0x62, 0xba, 0x00, 
	0x00, 0x00, 0x06, 0x00, 0x03, 0x2b, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 
	0x00, 0xb6, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 
	0x00, 0xf6, 0x00, 0x00, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 
	0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x56, 0x00, 
	0x00, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x02, 
	0x71, 0x00, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 
	0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x90, 0x3b, 0x29, 
	0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x01, 0x45, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x00, 
	0x00, 0x01, 0x00, 0x57, 0xff, 0x39, 0x01, 0x2c, 0x00, 0x64, 0x00, 0x07, 0x00, 0x1f, 0xba, 0x00, 
	0x07, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xba, 
	0x00, 0x05, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0x30, 0x31, 0x17, 0x27, 0x37, 
	0x35, 0x23, 0x35, 0x33, 0x15, 0x9c, 0x45, 0x71, 0x64, 0xc8, 0xc7, 0x45, 0x70, 0x12, 0x64, 0x9b, 
	0x00, 0x01, 0x00, 0x96, 0x02, 0x26, 0x01, 0x90, 0x03, 0x84, 0x00, 0x0d, 0x00, 0x2b, 0xba, 0x00, 
	0x0c, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 
	0x0a, 0xd0, 0x00, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0d, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 
	0x33, 0x32, 0x36, 0x35, 0x33, 0x11, 0x33, 0x01, 0x90, 0xfa, 0x64, 0x4b, 0x19, 0x15, 0x1d, 0x32, 
	0x64, 0x02, 0x26, 0x32, 0xc8, 0x32, 0x1d, 0x15, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x03, 0x00, 0x64, 
	0x01, 0x2c, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x1b, 0x00, 0xf5, 0xb8, 0x00, 
	0x1c, 0x2f, 0xb8, 0x00, 0x1d, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 
	0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 
	0x06, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xdc, 0x41, 0x05, 
	0x00, 0x6a, 0x00, 0x10, 0x00, 0x7a, 0x00, 0x10, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 0x99, 0x00, 
	0x10, 0x00, 0xa9, 0x00, 0x10, 0x00, 0xb9, 0x00, 0x10, 0x00, 0xc9, 0x00, 0x10, 0x00, 0xd9, 0x00, 
	0x10, 0x00, 0xe9, 0x00, 0x10, 0x00, 0xf9, 0x00, 0x10, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x09, 
	0x00, 0x10, 0x00, 0x19, 0x00, 0x10, 0x00, 0x29, 0x00, 0x10, 0x00, 0x39, 0x00, 0x10, 0x00, 0x49, 
	0x00, 0x10, 0x00, 0x59, 0x00, 0x10, 0x00, 0x06, 0x71, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x16, 
	0xdc, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x16, 0x00, 0xa6, 0x00, 0x16, 0x00, 0xb6, 0x00, 0x16, 0x00, 
	0xc6, 0x00, 0x16, 0x00, 0xd6, 0x00, 0x16, 0x00, 0xe6, 0x00, 0x16, 0x00, 0xf6, 0x00, 0x16, 0x00, 
	0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x26, 0x00, 0x16, 
	0x00, 0x36, 0x00, 0x16, 0x00, 0x46, 0x00, 0x16, 0x00, 0x56, 0x00, 0x16, 0x00, 0x06, 0x71, 0x41, 
	0x05, 0x00, 0x65, 0x00, 0x16, 0x00, 0x75, 0x00, 0x16, 0x00, 0x02, 0x71, 0x00, 0xba, 0x00, 0x0f, 
	0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 0x00, 0x09, 0x00, 0x13, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x19, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x19, 
	0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x11, 
	0x21, 0x35, 0x21, 0x03, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x01, 
	0xf4, 0x75, 0x53, 0x52, 0x76, 0x76, 0x52, 0x52, 0x76, 0xfe, 0x70, 0x01, 0x90, 0x64, 0x3b, 0x29, 
	0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x02, 0xbc, 0x52, 0x76, 0x75, 0x53, 0x53, 0x75, 0x76, 0xfe, 
	0x1e, 0x64, 0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x02, 0x00, 0x0a, 
	0xff, 0xe3, 0x01, 0xf4, 0x01, 0xae, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x13, 0x00, 0xb8, 0x00, 0x05, 
	0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0x30, 0x31, 0x25, 
	0x07, 0x27, 0x37, 0x27, 0x37, 0x0f, 0x01, 0x27, 0x37, 0x27, 0x37, 0x01, 0xf4, 0x62, 0x5c, 0x54, 
	0x54, 0x5c, 0xca, 0x62, 0x5c, 0x54, 0x54, 0x5c, 0xc8, 0xe5, 0x26, 0xbf, 0xbf, 0x27, 0xe6, 0xe5, 
	0x26, 0xbf, 0xbf, 0x27, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x58, 0x03, 0x84, 0x00, 0x0d, 
	0x00, 0x11, 0x00, 0x20, 0x00, 0x24, 0x00, 0x95, 0xba, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x0c, 0x10, 0xba, 0x00, 0x13, 0x00, 0x20, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 
	0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 
	0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x17, 0xd0, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x1d, 0xdc, 
	0xb8, 0x00, 0x23, 0xd0, 0xba, 0x00, 0x24, 0x00, 0x20, 0x00, 0x13, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x13, 0x10, 0xb8, 0x00, 0x26, 0xdc, 0x00, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 0x00, 0x19, 0x00, 0x1a, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x19, 0x10, 0xba, 0x00, 0x15, 0x00, 0x16, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x15, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 
	0x00, 0x02, 0xd0, 0xb8, 0x00, 0x19, 0x10, 0xb8, 0x00, 0x1c, 0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 
	0x00, 0x1e, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x22, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x35, 
	0x33, 0x35, 0x23, 0x35, 0x33, 0x32, 0x36, 0x35, 0x33, 0x11, 0x33, 0x25, 0x01, 0x27, 0x01, 0x03, 
	0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x17, 0x15, 
	0x33, 0x35, 0x01, 0x2c, 0xfa, 0x64, 0x4b, 0x19, 0x15, 0x1d, 0x32, 0x64, 0x01, 0x2c, 0xfd, 0xcb, 
	0x23, 0x02, 0x35, 0x63, 0x22, 0x32, 0x32, 0x32, 0x96, 0x32, 0x96, 0x32, 0x64, 0x02, 0x26, 0x32, 
	0xc8, 0x32, 0x1d, 0x15, 0xfe, 0xd4, 0x35, 0xfd, 0xcb, 0x23, 0x02, 0x35, 0xfe, 0xae, 0xc8, 0x32, 
	0x32, 0x32, 0x32, 0x32, 0x54, 0x12, 0x10, 0x74, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x0d, 0x00, 0x11, 0x00, 0x2a, 0x00, 0x43, 0xba, 0x00, 0x0c, 0x00, 0x03, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0x00, 0xb8, 
	0x00, 0x0a, 0x2f, 0xba, 0x00, 0x14, 0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0xba, 
	0x00, 0x26, 0x00, 0x1d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x26, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x35, 
	0x33, 0x35, 0x23, 0x35, 0x33, 0x32, 0x36, 0x35, 0x33, 0x11, 0x33, 0x25, 0x01, 0x27, 0x01, 0x03, 
	0x07, 0x33, 0x15, 0x23, 0x35, 0x37, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x23, 
	0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x01, 0x2c, 0xfa, 0x64, 0x4b, 0x19, 0x15, 0x1d, 
	0x32, 0x64, 0x01, 0x2c, 0xfd, 0xcb, 0x23, 0x02, 0x35, 0x1a, 0x9b, 0xa6, 0xfa, 0xc4, 0x04, 0x1d, 
	0x15, 0x32, 0x15, 0x1d, 0x32, 0x3b, 0x29, 0x32, 0x29, 0x3b, 0x02, 0x26, 0x32, 0xc8, 0x32, 0x1d, 
	0x15, 0xfe, 0xd4, 0x35, 0xfd, 0xcb, 0x23, 0x02, 0x35, 0xfe, 0x1c, 0x9a, 0x32, 0x22, 0xc5, 0x09, 
	0x0a, 0x15, 0x1d, 0x1d, 0x15, 0x29, 0x3b, 0x3b, 0x29, 0x19, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x02, 0x58, 0x03, 0x84, 0x00, 0x2a, 0x00, 0x2e, 0x00, 0x3d, 0x00, 0x41, 0x01, 0x0c, 
	0xba, 0x00, 0x23, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x07, 0x10, 
	0xb8, 0x00, 0x10, 0xd0, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x23, 0x00, 0xa6, 0x00, 0x23, 0x00, 0xb6, 
	0x00, 0x23, 0x00, 0xc6, 0x00, 0x23, 0x00, 0xd6, 0x00, 0x23, 0x00, 0xe6, 0x00, 0x23, 0x00, 0xf6, 
	0x00, 0x23, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x23, 0x00, 0x16, 0x00, 0x23, 0x00, 
	0x26, 0x00, 0x23, 0x00, 0x36, 0x00, 0x23, 0x00, 0x46, 0x00, 0x23, 0x00, 0x56, 0x00, 0x23, 0x00, 
	0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x23, 0x00, 0x75, 0x00, 0x23, 0x00, 0x02, 0x71, 0xb8, 
	0x00, 0x23, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 0xba, 0x00, 0x21, 0x00, 0x07, 0x00, 0x23, 0x11, 0x12, 
	0x39, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x30, 0xdc, 0xb8, 0x00, 0x35, 0x10, 0xb8, 0x00, 0x31, 
	0xd0, 0xb8, 0x00, 0x30, 0x10, 0xb8, 0x00, 0x34, 0xd0, 0xb8, 0x00, 0x30, 0x10, 0xb8, 0x00, 0x3a, 
	0xdc, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x3c, 0xd0, 0xb8, 0x00, 0x3a, 0x10, 0xb8, 0x00, 0x40, 
	0xd0, 0xba, 0x00, 0x41, 0x00, 0x23, 0x00, 0x30, 0x11, 0x12, 0x39, 0x00, 0xba, 0x00, 0x36, 0x00, 
	0x37, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x36, 0x10, 0xba, 0x00, 0x1c, 0x00, 0x13, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x1c, 0x10, 0xba, 0x00, 0x32, 0x00, 0x33, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x32, 0x10, 
	0xba, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 0x00, 0x04, 0x00, 
	0x26, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x21, 0x00, 0x0a, 0x00, 0x0d, 0x11, 
	0x12, 0x39, 0xb8, 0x00, 0x36, 0x10, 0xb8, 0x00, 0x39, 0xd0, 0xb8, 0x00, 0x33, 0x10, 0xb8, 0x00, 
	0x3b, 0xd0, 0xb8, 0x00, 0x32, 0x10, 0xb8, 0x00, 0x3f, 0xd0, 0x30, 0x31, 0x13, 0x14, 0x16, 0x3b, 
	0x01, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x34, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x15, 0x23, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x07, 0x16, 0x15, 
	0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x25, 0x01, 0x27, 0x01, 0x03, 0x33, 0x15, 0x33, 0x15, 
	0x23, 0x15, 0x33, 0x15, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x17, 0x15, 0x33, 0x35, 0x64, 0x1d, 
	0x15, 0x32, 0x15, 0x1d, 0x1d, 0x15, 0x32, 0x32, 0x15, 0x1d, 0x1d, 0x15, 0x32, 0x15, 0x1d, 0x32, 
	0x3b, 0x29, 0x32, 0x29, 0x3b, 0x2a, 0x2a, 0x3b, 0x29, 0x32, 0x29, 0x3b, 0x02, 0x26, 0xfd, 0xcb, 
	0x23, 0x02, 0x35, 0x63, 0x22, 0x32, 0x32, 0x32, 0x96, 0x32, 0x96, 0x32, 0x64, 0x02, 0x8a, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x32, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x29, 0x3b, 0x3b, 0x29, 
	0x2d, 0x1e, 0x1e, 0x2d, 0x29, 0x3b, 0x3b, 0x29, 0x03, 0xfd, 0xcb, 0x23, 0x02, 0x35, 0xfe, 0xae, 
	0xc8, 0x32, 0x32, 0x32, 0x32, 0x32, 0x54, 0x12, 0x10, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x22, 0x00, 0x6a, 0xba, 0x00, 0x1b, 0x00, 
	0x13, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1b, 0x10, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x1b, 0x00, 0xa6, 
	0x00, 0x1b, 0x00, 0xb6, 0x00, 0x1b, 0x00, 0xc6, 0x00, 0x1b, 0x00, 0xd6, 0x00, 0x1b, 0x00, 0xe6, 
	0x00, 0x1b, 0x00, 0xf6, 0x00, 0x1b, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x1b, 0x00, 
	0x16, 0x00, 0x1b, 0x00, 0x26, 0x00, 0x1b, 0x00, 0x36, 0x00, 0x1b, 0x00, 0x46, 0x00, 0x1b, 0x00, 
	0x56, 0x00, 0x1b, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x1b, 0x00, 0x75, 0x00, 0x1b, 
	0x00, 0x02, 0x71, 0x00, 0xb8, 0x00, 0x09, 0x2f, 0xba, 0x00, 0x1f, 0x00, 0x0f, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x1f, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x16, 0x13, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x34, 0x3f, 0x01, 0x33, 0x15, 0x07, 
	0x06, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x01, 0x2c, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 
	0x15, 0x15, 0x1d, 0xc8, 0x76, 0x52, 0x64, 0x52, 0x76, 0x16, 0xd1, 0x45, 0xc1, 0x07, 0x3b, 0x29, 
	0x64, 0x29, 0x3b, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfe, 0x29, 0x52, 0x76, 
	0x75, 0x53, 0x32, 0x2a, 0xd0, 0x45, 0xc2, 0x0f, 0x16, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0e, 0x00, 0x11, 0x00, 0x81, 
	0xb8, 0x00, 0x12, 0x2f, 0xb8, 0x00, 0x13, 0x2f, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 
	0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0xba, 0x00, 0x00, 0x00, 
	0x0c, 0x00, 0x07, 0x11, 0x12, 0x39, 0xba, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x07, 0x11, 0x12, 0x39, 
	0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x0b, 0xdc, 0xba, 0x00, 0x0f, 0x00, 
	0x0c, 0x00, 0x07, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x11, 0xd0, 0x00, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 
	0x00, 0x11, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xba, 0x00, 0x00, 0x00, 0x07, 
	0x00, 0x02, 0x11, 0x12, 0x39, 0xba, 0x00, 0x04, 0x00, 0x07, 0x00, 0x02, 0x11, 0x12, 0x39, 0x30, 
	0x31, 0x13, 0x27, 0x37, 0x17, 0x07, 0x33, 0x13, 0x11, 0x23, 0x35, 0x21, 0x15, 0x23, 0x11, 0x13, 
	0x17, 0x03, 0x21, 0xd5, 0x84, 0x45, 0xa2, 0x25, 0x26, 0xbb, 0x64, 0xfe, 0xd4, 0x64, 0xbc, 0x3e, 
	0x96, 0x01, 0x2c, 0x02, 0xbc, 0x83, 0x45, 0xa2, 0x26, 0xfe, 0x89, 0xfe, 0xbb, 0xc8, 0xc8, 0x01, 
	0x45, 0x01, 0x77, 0x64, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x0e, 0x00, 0x11, 0x00, 0x81, 0xb8, 0x00, 0x12, 0x2f, 0xb8, 0x00, 0x13, 0x2f, 
	0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x13, 0x10, 
	0xb8, 0x00, 0x03, 0xdc, 0xba, 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x04, 0xdc, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0xba, 0x00, 0x0b, 0x00, 0x08, 0x00, 
	0x03, 0x11, 0x12, 0x39, 0xba, 0x00, 0x0f, 0x00, 0x08, 0x00, 0x03, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x10, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0x00, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 
	0x00, 0x03, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0xba, 0x00, 0x11, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x11, 0x10, 0xba, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0d, 0x11, 0x12, 0x39, 0xba, 0x00, 0x0b, 
	0x00, 0x03, 0x00, 0x0d, 0x11, 0x12, 0x39, 0x30, 0x31, 0x01, 0x33, 0x13, 0x11, 0x23, 0x35, 0x21, 
	0x15, 0x23, 0x11, 0x13, 0x33, 0x27, 0x37, 0x17, 0x07, 0x03, 0x21, 0x01, 0x20, 0x19, 0xbb, 0x64, 
	0xfe, 0xd4, 0x64, 0xbc, 0x25, 0x25, 0xa2, 0x45, 0xa9, 0x96, 0x01, 0x2c, 0x02, 0xbc, 0xfe, 0x89, 
	0xfe, 0xbb, 0xc8, 0xc8, 0x01, 0x45, 0x01, 0x77, 0x26, 0xa2, 0x45, 0xe7, 0xfe, 0xd4, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x05, 0x00, 0x0f, 0x00, 0x12, 
	0x00, 0x59, 0xb8, 0x00, 0x13, 0x2f, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 
	0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x0d, 0xdc, 0xb8, 0x00, 0x0e, 0xdc, 0xba, 0x00, 0x10, 0x00, 0x08, 0x00, 0x0d, 0x11, 0x12, 0x39, 
	0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x12, 0xd0, 
	0x00, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x11, 
	0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0x30, 0x31, 0x13, 0x07, 0x27, 0x37, 0x17, 
	0x07, 0x03, 0x15, 0x23, 0x11, 0x13, 0x33, 0x13, 0x11, 0x23, 0x35, 0x0b, 0x01, 0x21, 0xfa, 0x5e, 
	0x45, 0xa3, 0xa3, 0x45, 0xf4, 0x64, 0xbc, 0x7d, 0xbb, 0x64, 0x96, 0x96, 0x01, 0x2c, 0x02, 0xfb, 
	0x5e, 0x45, 0xa2, 0xa2, 0x45, 0xfe, 0x2b, 0xc8, 0x01, 0x45, 0x01, 0x77, 0xfe, 0x89, 0xfe, 0xbb, 
	0xc8, 0x01, 0x90, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x19, 0x00, 0x23, 0x00, 0x26, 0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 
	0xcc, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 
	0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x01, 0x15, 0x23, 0x11, 0x13, 0x33, 0x13, 
	0x11, 0x23, 0x35, 0x0b, 0x01, 0x21, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 0x26, 0x15, 0x1d, 
	0x64, 0x58, 0x3e, 0x3f, 0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0xfe, 0x70, 0x64, 0xbc, 0x7d, 0xbb, 
	0x64, 0x96, 0x96, 0x01, 0x2c, 0x03, 0x52, 0x3e, 0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 
	0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0xfd, 0x44, 0xc8, 0x01, 0x45, 0x01, 0x77, 0xfe, 0x89, 0xfe, 
	0xbb, 0xc8, 0x01, 0x90, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x21, 0x00, 0x24, 0x00, 0x6b, 0xb8, 0x00, 0x25, 0x2f, 
	0xb8, 0x00, 0x26, 0x2f, 0xb8, 0x00, 0x1e, 0xdc, 0xb8, 0x00, 0x24, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 
	0xb8, 0x00, 0x25, 0x10, 0xb8, 0x00, 0x1a, 0xd0, 0xb8, 0x00, 0x1a, 0x2f, 0xb8, 0x00, 0x19, 0xdc, 
	0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x24, 0x10, 0xb8, 0x00, 0x20, 0xd0, 0xb8, 0x00, 0x19, 0x10, 
	0xb8, 0x00, 0x23, 0xd0, 0x00, 0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x1f, 0x2f, 0xba, 0x00, 0x09, 
	0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x23, 0x00, 0x18, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 
	0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x03, 
	0x15, 0x23, 0x11, 0x13, 0x33, 0x13, 0x11, 0x23, 0x35, 0x0b, 0x01, 0x21, 0x01, 0x90, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x64, 
	0x64, 0xbc, 0x7d, 0xbb, 0x64, 0x96, 0x96, 0x01, 0x2c, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0xc8, 0x01, 0x45, 0x01, 
	0x77, 0xfe, 0x89, 0xfe, 0xbb, 0xc8, 0x01, 0x90, 0xfe, 0xd4, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x12, 0x00, 0x1e, 0x00, 0x21, 0x00, 0x27, 0x30, 0x31, 
	0x41, 0x03, 0x00, 0xca, 0x00, 0x00, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc5, 0x00, 0x0a, 0x00, 
	0x01, 0x5d, 0x00, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x03, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc4, 
	0x00, 0x07, 0x00, 0x01, 0x5d, 0x13, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 
	0x13, 0x11, 0x23, 0x35, 0x21, 0x15, 0x23, 0x11, 0x13, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x34, 
	0x26, 0x23, 0x22, 0x06, 0x17, 0x03, 0x21, 0x9b, 0x37, 0x58, 0x3e, 0x3e, 0x58, 0x37, 0x9b, 0x64, 
	0xfe, 0xd4, 0x64, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x32, 0x96, 0x01, 0x2c, 
	0x02, 0x7a, 0x2d, 0x47, 0x3e, 0x58, 0x58, 0x3e, 0x47, 0x2d, 0xfe, 0xcb, 0xfe, 0xbb, 0xc8, 0xc8, 
	0x01, 0x45, 0x01, 0xa9, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xab, 0xfe, 0xd4, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x12, 0x00, 0x18, 0x00, 0x87, 
	0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x1a, 0x2f, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x01, 0xdc, 
	0xb8, 0x00, 0x19, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 
	0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 
	0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x17, 0xd0, 
	0x00, 0xba, 0x00, 0x12, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xba, 0x00, 0x0a, 
	0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xba, 0x00, 0x13, 0x00, 0x02, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x13, 
	0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x0b, 
	0x10, 0xb8, 0x00, 0x14, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x11, 0x23, 0x11, 0x23, 0x11, 0x34, 0x36, 
	0x33, 0x21, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x01, 0x35, 0x22, 0x06, 0x1d, 0x01, 
	0x01, 0xf4, 0xfe, 0xd4, 0x64, 0x64, 0x76, 0x52, 0x01, 0x2c, 0xc8, 0x64, 0x64, 0xc8, 0xfe, 0xd4, 
	0x29, 0x3b, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0xf4, 0x53, 0x75, 0x64, 0xc8, 0x64, 0xc8, 0x01, 0x2c, 
	0xc8, 0x3b, 0x29, 0x64, 0x00, 0x02, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x24, 
	0x00, 0x26, 0x00, 0x8b, 0xb8, 0x00, 0x27, 0x2f, 0xb8, 0x00, 0x28, 0x2f, 0xb8, 0x00, 0x14, 0xdc, 
	0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x27, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x0c, 0x2f, 
	0xba, 0x00, 0x04, 0x00, 0x0c, 0x00, 0x14, 0x11, 0x12, 0x39, 0xba, 0x00, 0x08, 0x00, 0x0c, 0x00, 
	0x14, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x15, 0xdc, 0xb8, 0x00, 0x0c, 0x10, 
	0xb8, 0x00, 0x1d, 0xdc, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x24, 0xd0, 0xba, 0x00, 0x25, 0x00, 
	0x0c, 0x00, 0x14, 0x11, 0x12, 0x39, 0xba, 0x00, 0x26, 0x00, 0x0c, 0x00, 0x14, 0x11, 0x12, 0x39, 
	0x00, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x11, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 
	0x10, 0xba, 0x00, 0x21, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x21, 0x10, 0xb8, 0x00, 0x03, 
	0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x25, 0xd0, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x2b, 0x01, 0x17, 0x07, 0x27, 0x37, 0x23, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 
	0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x3b, 
	0x01, 0x32, 0x36, 0x35, 0x07, 0x23, 0x01, 0xf4, 0x75, 0x53, 0x13, 0x26, 0xa3, 0x45, 0x84, 0x13, 
	0x53, 0x75, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 
	0x29, 0x3b, 0x77, 0x3e, 0xc8, 0x53, 0x75, 0x24, 0xa3, 0x45, 0x82, 0x76, 0x52, 0x01, 0x2c, 0x52, 
	0x76, 0x76, 0x52, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x29, 0xc8, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x10, 0x00, 0x43, 0xba, 0x00, 
	0x08, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x03, 0xd0, 0x00, 0xb8, 
	0x00, 0x0f, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 
	0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x30, 
	0x31, 0x01, 0x33, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x11, 0x33, 0x27, 
	0x37, 0x17, 0x01, 0x13, 0xe1, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x90, 0xfe, 0x0c, 0xd5, 
	0x84, 0x45, 0xa3, 0x02, 0xbc, 0x64, 0xc8, 0x64, 0xc8, 0x64, 0x02, 0xbc, 0x83, 0x45, 0xa2, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x7e, 0x00, 0x10, 0x00, 0x43, 0xba, 0x00, 
	0x08, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x03, 0xd0, 0x00, 0xb8, 
	0x00, 0x0f, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 
	0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x30, 
	0x31, 0x01, 0x33, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x11, 0x33, 0x27, 
	0x37, 0x17, 0x01, 0x26, 0xce, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x90, 0xfe, 0x0c, 0xdb, 
	0x1f, 0xa2, 0x45, 0x02, 0xbc, 0x64, 0xc8, 0x64, 0xc8, 0x64, 0x02, 0xbc, 0x1f, 0xa3, 0x45, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x10, 0x00, 0x13, 0x00, 0x4b, 
	0xba, 0x00, 0x0f, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 
	0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 
	0x10, 0xba, 0x00, 0x08, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xba, 0x00, 0x0c, 
	0x00, 0x0d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x02, 
	0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x11, 0x33, 0x27, 
	0x37, 0x17, 0x07, 0x33, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x03, 0x27, 0x07, 0x01, 
	0xf4, 0xfe, 0x0c, 0x7d, 0x26, 0xa3, 0xa2, 0x25, 0x7d, 0xfe, 0x70, 0x01, 0x2c, 0xfe, 0xd4, 0x01, 
	0x90, 0xbb, 0x3f, 0x3f, 0x02, 0xbc, 0x25, 0xa3, 0xa3, 0x25, 0x64, 0xc8, 0x64, 0xc8, 0x02, 0x58, 
	0x3e, 0x3e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 
	0x00, 0x17, 0x00, 0x23, 0x00, 0x5b, 0xba, 0x00, 0x22, 0x00, 0x19, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x22, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x22, 0x10, 0xb8, 0x00, 0x1d, 0xd0, 0x00, 0xba, 
	0x00, 0x23, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x23, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x1b, 0x10, 0xba, 0x00, 0x1f, 0x00, 0x20, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1f, 0x10, 0xb8, 
	0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 
	0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 
	0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x21, 0x11, 0x21, 0x15, 0x21, 0x15, 
	0x21, 0x15, 0x21, 0x15, 0x21, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 0xfe, 0x0c, 0x01, 0xf4, 0xfe, 0x70, 
	0x01, 0x2c, 0xfe, 0xd4, 0x01, 0x90, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfc, 0x99, 0x02, 0xbc, 0x64, 0xc8, 0x64, 0xc8, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x10, 0x00, 0x53, 0xba, 0x00, 
	0x08, 0x00, 0x0d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xba, 0x00, 0x00, 0x00, 0x0d, 0x00, 
	0x08, 0x11, 0x12, 0x39, 0xba, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x08, 0x11, 0x12, 0x39, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 
	0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 
	0x00, 0x09, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0x30, 
	0x31, 0x13, 0x27, 0x37, 0x17, 0x07, 0x33, 0x15, 0x23, 0x11, 0x33, 0x15, 0x21, 0x35, 0x33, 0x11, 
	0x23, 0x35, 0xd5, 0x84, 0x45, 0xa3, 0x26, 0xe1, 0xc8, 0xc8, 0xfe, 0x0c, 0xc8, 0xc8, 0x02, 0xbc, 
	0x83, 0x45, 0xa2, 0x26, 0x64, 0xfe, 0x0c, 0x64, 0x64, 0x01, 0xf4, 0x64, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x10, 0x00, 0x57, 0xba, 0x00, 0x04, 0x00, 0x09, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x00, 0x00, 0x09, 0x00, 0x04, 0x11, 0x12, 0x39, 
	0xba, 0x00, 0x0d, 0x00, 0x09, 0x00, 0x04, 0x11, 0x12, 0x39, 0x00, 0xb8, 0x00, 0x0f, 0x2f, 0xba, 
	0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 0x00, 0x01, 0x00, 0x02, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 
	0x00, 0x02, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x30, 
	0x31, 0x01, 0x33, 0x15, 0x23, 0x11, 0x33, 0x15, 0x21, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x27, 
	0x37, 0x17, 0x01, 0x20, 0xd4, 0xc8, 0xc8, 0xfe, 0x0c, 0xc8, 0xc8, 0xe1, 0x25, 0xa2, 0x45, 0x02, 
	0xbc, 0x64, 0xfe, 0x0c, 0x64, 0x64, 0x01, 0xf4, 0x64, 0x26, 0xa2, 0x45, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x11, 0x00, 0x15, 0x00, 0x4b, 0xba, 0x00, 0x10, 0x00, 
	0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 0x10, 0x00, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 0x00, 0x11, 
	0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xba, 0x00, 0x15, 0x00, 0x04, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0xb8, 0x00, 0x15, 
	0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x04, 
	0x10, 0xb8, 0x00, 0x0e, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x26, 
	0x27, 0x37, 0x17, 0x07, 0x33, 0x15, 0x23, 0x11, 0x33, 0x03, 0x26, 0x27, 0x07, 0x01, 0xf4, 0xfe, 
	0x0c, 0xc8, 0xc8, 0x7c, 0x09, 0x1c, 0xa3, 0xa2, 0x25, 0x7d, 0xc8, 0xc8, 0xbc, 0x10, 0x2e, 0x3f, 
	0x64, 0x01, 0xf4, 0x64, 0x0a, 0x1b, 0xa3, 0xa3, 0x25, 0x64, 0xfe, 0x0c, 0x02, 0x58, 0x11, 0x2d, 
	0x3e, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 
	0x00, 0x17, 0x00, 0x23, 0x00, 0xae, 0xba, 0x00, 0x06, 0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x06, 0x10, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x06, 0x00, 0xa6, 0x00, 0x06, 0x00, 0xb6, 0x00, 0x06, 
	0x00, 0xc6, 0x00, 0x06, 0x00, 0xd6, 0x00, 0x06, 0x00, 0xe6, 0x00, 0x06, 0x00, 0xf6, 0x00, 0x06, 
	0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x06, 0x00, 0x16, 0x00, 0x06, 0x00, 0x26, 0x00, 
	0x06, 0x00, 0x36, 0x00, 0x06, 0x00, 0x46, 0x00, 0x06, 0x00, 0x56, 0x00, 0x06, 0x00, 0x06, 0x71, 
	0x41, 0x05, 0x00, 0x65, 0x00, 0x06, 0x00, 0x75, 0x00, 0x06, 0x00, 0x02, 0x71, 0xb8, 0x00, 0x0c, 
	0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x21, 0xd0, 0x00, 0xba, 0x00, 
	0x23, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x23, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x1e, 0x00, 0x1d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x1e, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 
	0x15, 0xd0, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x1a, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 
	0x20, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x21, 0x35, 0x33, 
	0x11, 0x23, 0x35, 0x21, 0x15, 0x23, 0x11, 0x33, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 0xfe, 0x0c, 0xc8, 
	0xc8, 0x01, 0xf4, 0xc8, 0xc8, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfc, 0x99, 0x64, 0x01, 0xf4, 0x64, 0x64, 0xfe, 0x0c, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0d, 0x00, 0x1b, 0x00, 0x63, 
	0xb8, 0x00, 0x1c, 0x2f, 0xb8, 0x00, 0x1d, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x1c, 0x10, 
	0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x18, 0xdc, 0xb8, 0x00, 0x13, 0xd0, 
	0x00, 0xba, 0x00, 0x19, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x19, 0x10, 0xba, 0x00, 0x0a, 
	0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xba, 0x00, 0x08, 0x00, 0x05, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x16, 
	0xd0, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x32, 0x16, 
	0x15, 0x03, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x32, 0x36, 0x01, 
	0xf4, 0x76, 0x52, 0xc8, 0x64, 0x64, 0xc8, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x64, 0x64, 0x64, 
	0x29, 0x3b, 0xc8, 0x52, 0x76, 0x01, 0x2c, 0x64, 0x01, 0x2c, 0x76, 0x52, 0xfe, 0xd4, 0x01, 0x2c, 
	0x29, 0x3b, 0xc8, 0x64, 0xc8, 0x3b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x01, 0xf4, 
	0x03, 0x8e, 0x00, 0x19, 0x00, 0x24, 0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 
	0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 
	0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 0x32, 0x17, 
	0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x11, 0x23, 0x35, 0x01, 0x11, 0x23, 0x11, 0x33, 0x01, 
	0x11, 0x33, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 
	0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0x64, 0xfe, 0xd4, 0x64, 0x45, 0x01, 0x4b, 0x64, 0x03, 0x5c, 
	0x3e, 0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0xfc, 
	0x7c, 0xe7, 0x01, 0x2c, 0xfd, 0xed, 0x02, 0xb7, 0xfe, 0xba, 0x01, 0x46, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x14, 0x00, 0x24, 0x00, 0x63, 0xb8, 0x00, 0x25, 0x2f, 
	0xb8, 0x00, 0x26, 0x2f, 0xb8, 0x00, 0x25, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x0c, 0x2f, 
	0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x05, 0xdc, 0xba, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x05, 0x11, 
	0x12, 0x39, 0xba, 0x00, 0x11, 0x00, 0x0c, 0x00, 0x05, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x0c, 0x10, 
	0xb8, 0x00, 0x1a, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x21, 0xdc, 0x00, 0xb8, 0x00, 0x13, 
	0x2f, 0xba, 0x00, 0x1e, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xba, 0x00, 0x01, 
	0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x30, 0x31, 0x01, 
	0x33, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x3b, 
	0x01, 0x27, 0x37, 0x17, 0x07, 0x23, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 
	0x35, 0x11, 0x34, 0x26, 0x01, 0x13, 0x19, 0x53, 0x75, 0x75, 0x53, 0x64, 0x53, 0x75, 0x75, 0x53, 
	0x0d, 0x84, 0x45, 0xa3, 0x0d, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x02, 0xbc, 
	0x75, 0x53, 0xfe, 0xd4, 0x53, 0x75, 0x75, 0x53, 0x01, 0x2c, 0x53, 0x75, 0x83, 0x45, 0xa2, 0x8a, 
	0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0x2c, 0x29, 0x3b, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x14, 0x00, 0x24, 0x00, 0x63, 0xb8, 0x00, 0x25, 0x2f, 
	0xb8, 0x00, 0x26, 0x2f, 0xb8, 0x00, 0x25, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x0f, 0x2f, 
	0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x08, 0xdc, 0xba, 0x00, 0x03, 0x00, 0x0f, 0x00, 0x08, 0x11, 
	0x12, 0x39, 0xba, 0x00, 0x14, 0x00, 0x0f, 0x00, 0x08, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x0f, 0x10, 
	0xb8, 0x00, 0x1a, 0xdc, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x21, 0xdc, 0x00, 0xb8, 0x00, 0x01, 
	0x2f, 0xba, 0x00, 0x1e, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xba, 0x00, 0x04, 
	0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0x30, 0x31, 0x13, 
	0x37, 0x17, 0x07, 0x33, 0x32, 0x16, 0x15, 0x11, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 
	0x34, 0x36, 0x3b, 0x01, 0x17, 0x23, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 
	0x35, 0x11, 0x34, 0x26, 0xbc, 0xa2, 0x45, 0x83, 0x0c, 0x53, 0x75, 0x75, 0x53, 0x64, 0x53, 0x75, 
	0x75, 0x53, 0x19, 0x4b, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x02, 0xe2, 0xa2, 
	0x45, 0x83, 0x75, 0x53, 0xfe, 0xd4, 0x53, 0x75, 0x75, 0x53, 0x01, 0x2c, 0x53, 0x75, 0x64, 0x3b, 
	0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0x2c, 0x29, 0x3b, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x12, 0x00, 0x15, 0x00, 0x25, 0x00, 0x83, 0xb8, 0x00, 
	0x26, 0x2f, 0xb8, 0x00, 0x27, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x07, 0x00, 0x00, 0x11, 0x12, 0x39, 
	0xba, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x00, 0x11, 0x12, 0x39, 0xba, 0x00, 0x13, 0x00, 0x07, 0x00, 
	0x00, 0x11, 0x12, 0x39, 0xba, 0x00, 0x15, 0x00, 0x07, 0x00, 0x00, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x00, 0x10, 0xb8, 0x00, 0x16, 0xdc, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x1f, 0xdc, 0x00, 0xb8, 
	0x00, 0x0d, 0x2f, 0xba, 0x00, 0x23, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x23, 0x10, 0xba, 
	0x00, 0x13, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xba, 0x00, 0x0b, 0x00, 0x1a, 
	0x00, 0x13, 0x11, 0x12, 0x39, 0xba, 0x00, 0x0f, 0x00, 0x1a, 0x00, 0x13, 0x11, 0x12, 0x39, 0x30, 
	0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x37, 0x27, 0x37, 0x17, 
	0x07, 0x1e, 0x01, 0x15, 0x2f, 0x01, 0x07, 0x13, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 
	0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x4c, 0x3b, 
	0x30, 0xa3, 0xa2, 0x30, 0x3c, 0x4c, 0xbb, 0x3f, 0x3f, 0xd5, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x40, 0x68, 0x15, 0x30, 0xa3, 
	0xa3, 0x30, 0x14, 0x68, 0x41, 0xc8, 0x3e, 0x3e, 0xfe, 0x0c, 0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 
	0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x19, 0x00, 0x29, 0x00, 0x39, 0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 
	0xcc, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 
	0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x11, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x35, 0x11, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x03, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x22, 
	0x06, 0x15, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 
	0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0x76, 0x52, 0x64, 
	0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 
	0x29, 0x3b, 0x03, 0x52, 0x3e, 0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 
	0x1d, 0x15, 0x32, 0xfd, 0x44, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0xfe, 
	0xd4, 0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x27, 0x00, 0x37, 0x00, 0x5f, 
	0xb8, 0x00, 0x38, 0x2f, 0xb8, 0x00, 0x39, 0x2f, 0xb8, 0x00, 0x27, 0xdc, 0xb8, 0x00, 0x29, 0xdc, 
	0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 0xb8, 0x00, 0x1f, 0x2f, 
	0xb8, 0x00, 0x31, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0x00, 0xba, 0x00, 0x35, 0x00, 0x1b, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x35, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0xba, 0x00, 0x24, 0x00, 0x2c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x24, 0x10, 0xb8, 0x00, 0x03, 
	0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 
	0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 
	0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x03, 0x11, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 
	0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 
	0x3b, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0xfd, 0x61, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0xfe, 0xd4, 
	0x01, 0x2c, 0x29, 0x3b, 0x3b, 0x29, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x01, 0x00, 0x03, 
	0x00, 0x67, 0x01, 0xf1, 0x02, 0x55, 0x00, 0x0b, 0x00, 0x13, 0x00, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 
	0x00, 0x03, 0x2f, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0x30, 0x31, 0x25, 0x07, 0x27, 
	0x07, 0x27, 0x37, 0x27, 0x37, 0x17, 0x37, 0x17, 0x07, 0x01, 0xf1, 0x46, 0xb1, 0xb1, 0x46, 0xb1, 
	0xb1, 0x46, 0xb1, 0xb1, 0x46, 0xb1, 0xad, 0x46, 0xb1, 0xb1, 0x46, 0xb1, 0xb1, 0x46, 0xb1, 0xb1, 
	0x46, 0xb1, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0f, 
	0x00, 0x17, 0x00, 0x1f, 0x00, 0x3f, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 
	0x00, 0xdc, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 
	0x17, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x18, 0xdc, 0x00, 0xba, 0x00, 0x1d, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 
	0x3b, 0x01, 0x32, 0x16, 0x15, 0x27, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x05, 0x35, 0x01, 
	0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x73, 0x1e, 0x37, 0x64, 0x29, 0x3b, 0x01, 0x2c, 0xfe, 0xe5, 0x1e, 0x35, 0x64, 0x29, 0x3b, 
	0xc8, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x76, 0x52, 0x36, 0x2e, 0x3b, 0x29, 0xe7, 
	0x45, 0xe5, 0xfe, 0xe5, 0x2e, 0x3b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x03, 0x00, 0x17, 0x00, 0x37, 0xb8, 0x00, 0x18, 0x2f, 0xb8, 0x00, 0x19, 0x2f, 
	0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 
	0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x15, 0xdc, 0x00, 0xb8, 0x00, 0x03, 
	0x2f, 0xba, 0x00, 0x12, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0x30, 0x31, 0x01, 
	0x07, 0x27, 0x37, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 
	0x3b, 0x01, 0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 0x38, 0x44, 0xa3, 0x45, 0x01, 0x5e, 0x76, 0x52, 
	0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x02, 0xe1, 0x44, 0xa2, 0x45, 0xfd, 
	0x44, 0x53, 0x75, 0x75, 0x53, 0x01, 0xf4, 0xfe, 0x0c, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x00, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x03, 0x00, 0x17, 0x00, 0x37, 
	0xb8, 0x00, 0x18, 0x2f, 0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x18, 0x10, 
	0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x04, 0x10, 
	0xb8, 0x00, 0x15, 0xdc, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x12, 0x00, 0x07, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x12, 0x10, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x14, 0x06, 0x2b, 0x01, 
	0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 
	0xa3, 0xa3, 0x45, 0xa3, 0x96, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 
	0x64, 0x03, 0x3f, 0xa2, 0x44, 0xa3, 0xfd, 0x44, 0x53, 0x75, 0x75, 0x53, 0x01, 0xf4, 0xfe, 0x0c, 
	0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x05, 0x00, 0x19, 0x00, 0x37, 0xb8, 0x00, 0x1a, 0x2f, 0xb8, 0x00, 0x1b, 0x2f, 
	0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 
	0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x17, 0xdc, 0x00, 0xb8, 0x00, 0x05, 
	0x2f, 0xba, 0x00, 0x14, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0x30, 0x31, 0x01, 
	0x07, 0x27, 0x07, 0x27, 0x37, 0x13, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 
	0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 0x9c, 0x44, 0x5e, 0x5e, 0x45, 0xa3, 
	0xfa, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x02, 0xe1, 0x44, 
	0x5d, 0x5d, 0x44, 0xa3, 0xfd, 0x44, 0x53, 0x75, 0x75, 0x53, 0x01, 0xf4, 0xfe, 0x0c, 0x29, 0x3b, 
	0x3b, 0x29, 0x01, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 
	0x00, 0x17, 0x00, 0x2b, 0x00, 0x53, 0xb8, 0x00, 0x2c, 0x2f, 0xb8, 0x00, 0x2d, 0x2f, 0xb8, 0x00, 
	0x2b, 0xdc, 0xb8, 0x00, 0x2a, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 
	0x1f, 0xd0, 0xb8, 0x00, 0x1f, 0x2f, 0xb8, 0x00, 0x22, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0x00, 0xba, 
	0x00, 0x26, 0x00, 0x1b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x26, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 
	0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 
	0x16, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 
	0x32, 0x36, 0x35, 0x11, 0x33, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x53, 0x75, 0x75, 0x53, 0x01, 0xf4, 0xfe, 
	0x0c, 0x29, 0x3b, 0x3b, 0x29, 0x01, 0xf4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x03, 0x00, 0x10, 0x00, 0x71, 0xb8, 0x00, 0x11, 0x2f, 0xb8, 0x00, 0x09, 0xd0, 
	0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x07, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x07, 0x00, 0x01, 
	0x5d, 0x41, 0x03, 0x00, 0x90, 0x00, 0x07, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x07, 
	0x00, 0x01, 0x71, 0xb8, 0x00, 0x0e, 0xdc, 0x41, 0x03, 0x00, 0x90, 0x00, 0x0e, 0x00, 0x01, 0x5d, 
	0x41, 0x03, 0x00, 0x50, 0x00, 0x0e, 0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x0e, 0x00, 
	0x01, 0x5d, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 
	0x09, 0x10, 0xb8, 0x00, 0x0c, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x12, 0xdc, 0x00, 0xb8, 
	0x00, 0x03, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x07, 0x15, 
	0x23, 0x35, 0x27, 0x11, 0x33, 0x15, 0x17, 0x37, 0x35, 0x33, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x96, 
	0xc8, 0x64, 0xc8, 0x64, 0x96, 0x96, 0x64, 0x03, 0x3f, 0xa2, 0x44, 0xa3, 0xfe, 0x2b, 0xc8, 0xe7, 
	0xe7, 0xc8, 0x01, 0x0d, 0xe7, 0x96, 0x96, 0xe7, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0c, 0x00, 0x15, 0x00, 0x9e, 0xb8, 0x00, 0x16, 0x2f, 0xb8, 0x00, 0x17, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 
	0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x0d, 0xdc, 
	0x41, 0x05, 0x00, 0x6a, 0x00, 0x0d, 0x00, 0x7a, 0x00, 0x0d, 0x00, 0x02, 0x71, 0x41, 0x0f, 0x00, 
	0x99, 0x00, 0x0d, 0x00, 0xa9, 0x00, 0x0d, 0x00, 0xb9, 0x00, 0x0d, 0x00, 0xc9, 0x00, 0x0d, 0x00, 
	0xd9, 0x00, 0x0d, 0x00, 0xe9, 0x00, 0x0d, 0x00, 0xf9, 0x00, 0x0d, 0x00, 0x07, 0x5d, 0x41, 0x0d, 
	0x00, 0x09, 0x00, 0x0d, 0x00, 0x19, 0x00, 0x0d, 0x00, 0x29, 0x00, 0x0d, 0x00, 0x39, 0x00, 0x0d, 
	0x00, 0x49, 0x00, 0x0d, 0x00, 0x59, 0x00, 0x0d, 0x00, 0x06, 0x71, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x11, 0xd0, 0x00, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x0a, 0x00, 
	0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xba, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x13, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x15, 0x23, 0x11, 0x33, 0x15, 
	0x33, 0x32, 0x16, 0x07, 0x34, 0x26, 0x2b, 0x01, 0x15, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 
	0xc8, 0x64, 0x64, 0xc8, 0x53, 0x75, 0x64, 0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 0x01, 0x90, 0x52, 
	0x76, 0xc8, 0x02, 0xbc, 0x64, 0x75, 0x53, 0x29, 0x3b, 0xc8, 0x3b, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xff, 0x9d, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x2c, 0x00, 0x0b, 0x30, 0x31, 0x41, 0x03, 0x00, 0xc5, 
	0x00, 0x29, 0x00, 0x01, 0x5d, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x34, 
	0x26, 0x3d, 0x01, 0x34, 0x37, 0x36, 0x37, 0x36, 0x35, 0x34, 0x26, 0x23, 0x22, 0x0f, 0x01, 0x06, 
	0x15, 0x11, 0x23, 0x11, 0x34, 0x3f, 0x01, 0x33, 0x32, 0x16, 0x15, 0x14, 0x07, 0x06, 0x15, 0x14, 
	0x17, 0x16, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x64, 0x1a, 0x18, 0x18, 0x1a, 0x3b, 
	0x29, 0x17, 0x10, 0x85, 0x1c, 0x64, 0x29, 0xbe, 0x45, 0x53, 0x75, 0x50, 0x14, 0x12, 0x52, 0xc8, 
	0x53, 0x75, 0x64, 0x3b, 0x29, 0x3b, 0x3b, 0x39, 0x32, 0x29, 0x1a, 0x15, 0x15, 0x1a, 0x28, 0x29, 
	0x3b, 0x08, 0x84, 0x1c, 0x29, 0xfd, 0xb2, 0x02, 0x5d, 0x3f, 0x29, 0xbe, 0x75, 0x53, 0x64, 0x3c, 
	0x0f, 0x19, 0x18, 0x0e, 0x40, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x03, 0x00, 0x11, 0x00, 0x1d, 0x00, 0x4f, 0xb8, 0x00, 0x1e, 0x2f, 0xb8, 0x00, 
	0x1f, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 
	0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x16, 0xdc, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 
	0x1c, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x19, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x19, 0x10, 0xba, 0x00, 0x11, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xb8, 
	0x00, 0x0a, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x11, 0x23, 
	0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 
	0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x01, 0x9c, 0x44, 0xa3, 0x45, 0xfa, 0x64, 0x3e, 0x4b, 
	0x3f, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x02, 0x90, 0x44, 0xa2, 
	0x45, 0xfe, 0xc1, 0xfe, 0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 
	0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x03, 0x00, 0x11, 0x00, 0x1d, 0x00, 0x4f, 0xb8, 0x00, 0x1e, 0x2f, 0xb8, 0x00, 
	0x1f, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 
	0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x16, 0xdc, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 
	0x1c, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x19, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x19, 0x10, 0xba, 0x00, 0x11, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xb8, 
	0x00, 0x0a, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x11, 0x23, 
	0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 
	0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x96, 0x64, 0x3e, 0x4b, 
	0x3f, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x02, 0xee, 0xa2, 0x44, 
	0xa3, 0xfe, 0xc1, 0xfe, 0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 
	0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x05, 0x00, 0x13, 0x00, 0x1f, 0x00, 0x4f, 0xb8, 0x00, 0x20, 0x2f, 0xb8, 0x00, 
	0x21, 0x2f, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 
	0x0f, 0xd0, 0xb8, 0x00, 0x0f, 0x2f, 0xb8, 0x00, 0x18, 0xdc, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x1e, 0xd0, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x1b, 0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x1b, 0x10, 0xba, 0x00, 0x13, 0x00, 0x14, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xb8, 
	0x00, 0x0c, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x37, 0x13, 
	0x11, 0x23, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 
	0x1d, 0x01, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x01, 0x9c, 0x44, 0x5e, 0x5e, 0x45, 0xa3, 
	0xfa, 0x64, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x32, 0x32, 0x64, 
	0x02, 0x90, 0x44, 0x5d, 0x5d, 0x44, 0xa3, 0xfe, 0xc1, 0xfe, 0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 
	0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x19, 0x00, 0x27, 0x00, 0x33, 0x00, 0x15, 0x30, 0x31, 
	0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 
	0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 
	0x35, 0x34, 0x36, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x19, 0x01, 0x23, 
	0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 
	0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 0x26, 0x15, 
	0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0x64, 0x3e, 0x4b, 0x3f, 0x53, 
	0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x02, 0xee, 0x3e, 0x58, 0x26, 0x3e, 
	0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0xfe, 0xd4, 0xfe, 0x0c, 0x8a, 
	0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x25, 
	0x00, 0x31, 0x00, 0x79, 0xb8, 0x00, 0x32, 0x2f, 0xb8, 0x00, 0x33, 0x2f, 0xb8, 0x00, 0x18, 0xdc, 
	0xb8, 0x00, 0x31, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x32, 0x10, 0xb8, 0x00, 0x21, 0xd0, 
	0xb8, 0x00, 0x21, 0x2f, 0xb8, 0x00, 0x2a, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x31, 0x10, 
	0xb8, 0x00, 0x1a, 0xd0, 0xba, 0x00, 0x1b, 0x00, 0x21, 0x00, 0x18, 0x11, 0x12, 0x39, 0x00, 0xba, 
	0x00, 0x2d, 0x00, 0x1e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x2d, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x25, 0x00, 0x26, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x25, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x15, 0xd0, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x19, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 
	0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x36, 0x33, 0x32, 0x16, 0x05, 0x11, 0x23, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 
	0x34, 0x36, 0x33, 0x15, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x01, 
	0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0x01, 0x2c, 0x64, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 
	0x32, 0x32, 0x64, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 
	0x15, 0x15, 0x1d, 0x1d, 0xab, 0xfe, 0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x20, 0x00, 0x1a, 0x00, 0x26, 0x00, 0x32, 0x00, 0x27, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 
	0xcc, 0x00, 0x02, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x04, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0xc4, 0x00, 0x08, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x0a, 0x00, 0x01, 
	0x5d, 0x13, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x15, 0x14, 0x06, 0x23, 0x33, 0x11, 
	0x23, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x33, 0x35, 0x14, 0x16, 0x33, 
	0x32, 0x36, 0x35, 0x34, 0x26, 0x23, 0x22, 0x06, 0x11, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 
	0x32, 0x3f, 0x01, 0x35, 0xfa, 0x3e, 0x58, 0x58, 0x3e, 0x3e, 0x58, 0x58, 0x3e, 0xfa, 0x64, 0x3e, 
	0x4b, 0x3f, 0x53, 0x75, 0x75, 0x53, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x29, 0x3b, 
	0x3b, 0x29, 0x32, 0x32, 0x64, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x58, 0x58, 0x3e, 0x3e, 0x58, 0xfe, 
	0x0c, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x64, 0x53, 0x75, 0x96, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0xfe, 0xf1, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x32, 0x64, 0x96, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x10, 0x00, 0x15, 0x00, 0x1d, 0x00, 0x87, 0xb8, 0x00, 
	0x1e, 0x2f, 0xb8, 0x00, 0x1f, 0x2f, 0xb8, 0x00, 0x0f, 0xdc, 0xb8, 0x00, 0x16, 0xdc, 0xb8, 0x00, 
	0x01, 0xd0, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 
	0x16, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 
	0x0f, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x1b, 0xdc, 0x00, 0xba, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 0x10, 0xba, 0x00, 0x09, 0x00, 0x14, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x05, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x11, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 
	0x00, 0x17, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 
	0x16, 0x1d, 0x01, 0x23, 0x15, 0x33, 0x27, 0x34, 0x26, 0x23, 0x15, 0x07, 0x11, 0x22, 0x06, 0x1d, 
	0x01, 0x14, 0x16, 0x01, 0xf4, 0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0xc8, 0xc8, 
	0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 
	0xc8, 0x29, 0x3b, 0x64, 0xc8, 0x01, 0x2c, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x00, 0x02, 0x00, 0x00, 
	0xff, 0x39, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x1e, 0x00, 0x20, 0x00, 0x3b, 0xba, 0x00, 0x1a, 0x00, 
	0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1a, 0x10, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x0e, 
	0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0xba, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x00, 
	0x10, 0xb8, 0x00, 0x1f, 0xd0, 0x30, 0x31, 0x21, 0x23, 0x17, 0x07, 0x27, 0x37, 0x23, 0x22, 0x26, 
	0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 
	0x1d, 0x01, 0x14, 0x16, 0x33, 0x21, 0x07, 0x23, 0x01, 0xf4, 0xdb, 0x26, 0xa3, 0x45, 0x84, 0x13, 
	0x53, 0x75, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x01, 
	0x2c, 0xdb, 0x3e, 0x24, 0xa3, 0x45, 0x82, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x29, 0x3b, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x64, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x03, 0x00, 0x16, 0x00, 0x1e, 0x00, 0x4b, 0xba, 0x00, 0x12, 0x00, 0x08, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 
	0x00, 0x16, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x16, 0x10, 0xba, 0x00, 0x09, 0x00, 0x08, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0d, 0x10, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x17, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x01, 0x21, 0x22, 0x26, 0x3d, 0x01, 0x34, 
	0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 0x01, 0x21, 0x14, 0x16, 0x33, 0x21, 0x27, 0x34, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x15, 0x01, 0x38, 0x44, 0xa3, 0x45, 0x01, 0x5e, 0xfe, 0xd4, 0x52, 0x76, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0xfe, 0x70, 0x3b, 0x29, 0x01, 0x2c, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 
	0x02, 0x90, 0x44, 0xa2, 0x45, 0xfc, 0xcd, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x29, 
	0x3b, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x03, 0x00, 0x16, 0x00, 0x1e, 0x00, 0x4b, 0xba, 0x00, 0x12, 0x00, 0x08, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 
	0x00, 0x16, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x16, 0x10, 0xba, 0x00, 0x09, 0x00, 0x08, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0d, 0x10, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x17, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x21, 0x22, 0x26, 0x3d, 0x01, 0x34, 
	0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 0x01, 0x21, 0x14, 0x16, 0x33, 0x21, 0x27, 0x34, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x15, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x96, 0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 
	0x64, 0x52, 0x76, 0xfe, 0x70, 0x3b, 0x29, 0x01, 0x2c, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 
	0xee, 0xa2, 0x44, 0xa3, 0xfc, 0xcd, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x29, 0x3b, 
	0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x05, 0x00, 0x18, 0x00, 0x20, 0x00, 0x4b, 0xba, 0x00, 0x14, 0x00, 0x0a, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x20, 0xd0, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 
	0x00, 0x18, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 0x0b, 0x00, 0x0a, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xba, 0x00, 0x0f, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x0f, 0x10, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 
	0x00, 0x19, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x37, 0x13, 0x21, 0x22, 0x26, 0x3d, 
	0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 0x01, 0x21, 0x14, 0x16, 0x33, 0x21, 0x27, 0x34, 
	0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x01, 0x9c, 0x44, 0x5e, 0x5e, 0x45, 0xa3, 0xfa, 0xfe, 0xd4, 
	0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0xfe, 0x70, 0x3b, 0x29, 0x01, 0x2c, 0x64, 0x3b, 0x29, 
	0x64, 0x29, 0x3b, 0x02, 0x90, 0x44, 0x5d, 0x5d, 0x44, 0xa3, 0xfc, 0xcd, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x76, 0x52, 0x64, 0x29, 0x3b, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x2a, 0x00, 0x32, 0x00, 0x6b, 
	0xba, 0x00, 0x26, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x12, 0xd0, 
	0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x32, 0xd0, 0x00, 0xba, 0x00, 0x2a, 0x00, 0x18, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x2a, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0xba, 0x00, 0x1d, 0x00, 0x1c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x21, 
	0x00, 0x2e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x21, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 
	0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 0x25, 
	0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x2b, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x01, 0x21, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x1d, 
	0x01, 0x21, 0x14, 0x16, 0x33, 0x21, 0x27, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x01, 0x90, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x01, 0x2c, 0xfe, 0xd4, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0xfe, 0x70, 0x3b, 0x29, 
	0x01, 0x2c, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0x76, 0x52, 0x64, 0x29, 0x3b, 0xc8, 0x29, 0x3b, 0x3b, 0x29, 0x00, 0x00, 0x00, 0x02, 0x00, 0x51, 
	0x00, 0x00, 0x01, 0x90, 0x03, 0x33, 0x00, 0x03, 0x00, 0x0d, 0x00, 0x3f, 0xba, 0x00, 0x0c, 0x00, 
	0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x06, 0x10, 
	0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x0d, 0x00, 0x04, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 
	0x10, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 
	0x21, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x01, 0x38, 0x44, 0xa3, 0x45, 0xfa, 0xfe, 
	0xd4, 0x64, 0x64, 0xc8, 0x64, 0x02, 0x90, 0x44, 0xa2, 0x45, 0xfc, 0xcd, 0x64, 0x01, 0x2c, 0x64, 
	0xfe, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x64, 0x00, 0x00, 0x01, 0xa3, 0x03, 0x33, 0x00, 0x03, 
	0x00, 0x0d, 0x00, 0x3f, 0xba, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 
	0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x03, 
	0x2f, 0xba, 0x00, 0x0d, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 0x00, 0x0a, 
	0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x06, 
	0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x21, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x11, 
	0x33, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x32, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 0x02, 0xee, 0xa2, 
	0x44, 0xa3, 0xfc, 0xcd, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x57, 
	0x00, 0x00, 0x01, 0x9c, 0x03, 0x33, 0x00, 0x05, 0x00, 0x0f, 0x00, 0x3f, 0xba, 0x00, 0x0e, 0x00, 
	0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x09, 0xdc, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x0b, 0xd0, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x0f, 0x00, 0x06, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 
	0x10, 0xb8, 0x00, 0x0f, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 
	0x37, 0x13, 0x21, 0x35, 0x33, 0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x01, 0x9c, 0x44, 0x5e, 0x5e, 
	0x45, 0xa3, 0x96, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 0x02, 0x90, 0x44, 0x5d, 0x5d, 0x44, 0xa3, 
	0xfc, 0xcd, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0x70, 0x00, 0x03, 0x00, 0x64, 0x00, 0x00, 0x01, 0x90, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x21, 0x00, 0xba, 0xba, 0x00, 0x06, 0x00, 0x12, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x06, 0x00, 0xa6, 0x00, 0x06, 
	0x00, 0xb6, 0x00, 0x06, 0x00, 0xc6, 0x00, 0x06, 0x00, 0xd6, 0x00, 0x06, 0x00, 0xe6, 0x00, 0x06, 
	0x00, 0xf6, 0x00, 0x06, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x06, 0x00, 0x16, 0x00, 
	0x06, 0x00, 0x26, 0x00, 0x06, 0x00, 0x36, 0x00, 0x06, 0x00, 0x46, 0x00, 0x06, 0x00, 0x56, 0x00, 
	0x06, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x06, 0x00, 0x75, 0x00, 0x06, 0x00, 0x02, 
	0x71, 0xb8, 0x00, 0x0c, 0xdc, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x19, 0xd0, 0xb8, 0x00, 0x0c, 
	0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x1d, 0xd0, 0xb8, 0x00, 0x06, 
	0x10, 0xb8, 0x00, 0x1f, 0xd0, 0x00, 0xba, 0x00, 0x21, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x21, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 
	0x1e, 0x00, 0x1d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 
	0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 0x00, 0x21, 0x10, 0xb8, 0x00, 
	0x1a, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x13, 0x21, 0x35, 0x33, 
	0x11, 0x23, 0x35, 0x33, 0x11, 0x33, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 
	0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0xfd, 0x61, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0x70, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x41, 0x00, 0x1b, 0x00, 0x2b, 0x00, 0x5d, 0xb8, 0x00, 0x2c, 0x2f, 
	0xb8, 0x00, 0x2d, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 0x07, 0xd0, 
	0xb8, 0x00, 0x07, 0x2f, 0xba, 0x00, 0x0e, 0x00, 0x07, 0x00, 0x00, 0x11, 0x12, 0x39, 0xb8, 0x00, 
	0x00, 0x10, 0xb8, 0x00, 0x1c, 0xdc, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x25, 0xdc, 0x00, 0xb8, 
	0x00, 0x14, 0x2f, 0xb8, 0x00, 0x16, 0x2f, 0xba, 0x00, 0x29, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x29, 0x10, 0xba, 0x00, 0x0c, 0x00, 0x20, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 
	0x00, 0x0e, 0xd0, 0xb8, 0x00, 0x0e, 0x2f, 0x30, 0x31, 0x25, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 
	0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x17, 0x27, 0x07, 0x27, 0x37, 0x27, 0x37, 0x17, 0x37, 
	0x17, 0x07, 0x17, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 
	0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0xf4, 0x75, 0x53, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x0f, 
	0x11, 0x84, 0x3e, 0x47, 0x3e, 0x3e, 0x47, 0x3e, 0x3e, 0x47, 0x3e, 0xac, 0x39, 0x64, 0x3b, 0x29, 
	0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0xc8, 0x53, 0x75, 0x76, 0x52, 0x64, 0x52, 0x76, 
	0x03, 0x84, 0x3e, 0x47, 0x3e, 0x3e, 0x47, 0x3e, 0x3e, 0x47, 0x3e, 0xad, 0x39, 0x52, 0xbc, 0x64, 
	0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x20, 0x00, 0x19, 0x00, 0x2d, 0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 
	0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 
	0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 0x32, 0x17, 
	0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x01, 0x15, 0x37, 0x36, 0x33, 0x32, 0x16, 0x15, 0x11, 
	0x23, 0x11, 0x34, 0x26, 0x23, 0x22, 0x0f, 0x01, 0x15, 0x23, 0x11, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 
	0x26, 0x3e, 0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0xfe, 
	0x70, 0x3f, 0x4b, 0x3e, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 0x02, 0xee, 0x3e, 
	0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0xfe, 0xd4, 
	0x89, 0x3e, 0x4b, 0x75, 0x53, 0xfe, 0xd4, 0x01, 0x2c, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0x01, 0xf4, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x33, 0x00, 0x03, 0x00, 0x13, 0x00, 0x23, 
	0x00, 0x47, 0xb8, 0x00, 0x24, 0x2f, 0xb8, 0x00, 0x25, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 
	0x24, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 
	0x14, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x1d, 0xdc, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 
	0x00, 0x21, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x21, 0x10, 0xba, 0x00, 0x10, 0x00, 0x18, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 0x10, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x01, 0x14, 0x06, 
	0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 
	0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0x38, 0x44, 
	0xa3, 0x45, 0x01, 0x5e, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 0x90, 0x44, 0xa2, 0x45, 0xfd, 0x95, 
	0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 
	0x29, 0x3b, 0x3b, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x33, 0x00, 0x03, 
	0x00, 0x13, 0x00, 0x23, 0x00, 0x47, 0xb8, 0x00, 0x24, 0x2f, 0xb8, 0x00, 0x25, 0x2f, 0xb8, 0x00, 
	0x04, 0xdc, 0xb8, 0x00, 0x24, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 
	0x04, 0x10, 0xb8, 0x00, 0x14, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x1d, 0xdc, 0x00, 0xb8, 
	0x00, 0x03, 0x2f, 0xba, 0x00, 0x21, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x21, 0x10, 0xba, 
	0x00, 0x10, 0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 0x10, 0x30, 0x31, 0x01, 0x07, 0x27, 
	0x37, 0x13, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 
	0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 
	0x36, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x96, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 
	0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 0xee, 0xa2, 0x44, 
	0xa3, 0xfd, 0x95, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x05, 0x00, 0x15, 0x00, 0x25, 0x00, 0x47, 0xb8, 0x00, 0x26, 0x2f, 0xb8, 0x00, 
	0x27, 0x2f, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x26, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 
	0x0d, 0x2f, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x16, 0xdc, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 
	0x1f, 0xdc, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x23, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x23, 0x10, 0xba, 0x00, 0x12, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x12, 0x10, 0x30, 
	0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x37, 0x13, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 
	0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 
	0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0x9c, 0x44, 0x5e, 0x5e, 0x45, 0xa3, 0xfa, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x29, 0x64, 0x29, 0x3b, 0x02, 0x90, 0x44, 0x5d, 0x5d, 0x44, 0xa3, 0xfd, 0x95, 0x52, 0x76, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x19, 0x00, 0x29, 0x00, 0x39, 
	0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 
	0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 
	0x33, 0x11, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 
	0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 
	0x36, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 
	0x3f, 0x25, 0x15, 0x1d, 0x64, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 0xee, 0x3e, 0x58, 0x26, 0x3e, 
	0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0xfd, 0xa8, 0x52, 0x76, 0x76, 
	0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 
	0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x27, 
	0x00, 0x37, 0x00, 0x5f, 0xb8, 0x00, 0x38, 0x2f, 0xb8, 0x00, 0x39, 0x2f, 0xb8, 0x00, 0x27, 0xdc, 
	0xb8, 0x00, 0x29, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 
	0xb8, 0x00, 0x1f, 0x2f, 0xb8, 0x00, 0x31, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0x00, 0xba, 0x00, 0x35, 
	0x00, 0x1b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x35, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x24, 0x00, 0x2c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x24, 
	0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 
	0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 
	0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0x14, 0x06, 0x2b, 0x01, 
	0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x01, 0x90, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 
	0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 
	0x3b, 0x29, 0x64, 0x29, 0x3b, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfe, 0x29, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 
	0x52, 0x64, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x64, 0x01, 0xf4, 0x02, 0x58, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x1b, 0x00, 0x76, 0xba, 0x00, 
	0x00, 0x00, 0x06, 0x00, 0x03, 0x2b, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x00, 0x00, 0xa6, 0x00, 0x00, 
	0x00, 0xb6, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 0x00, 0xe6, 0x00, 0x00, 
	0x00, 0xf6, 0x00, 0x00, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 
	0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x56, 0x00, 
	0x00, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x02, 
	0x71, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0x00, 0xb8, 0x00, 
	0x13, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0xba, 0x00, 0x0f, 0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x0f, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x13, 0x21, 0x35, 0x21, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x01, 0x2c, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0xfe, 0x0c, 0x01, 0xf4, 0xc8, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x02, 0x26, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0xfe, 0xf1, 0x64, 0xfa, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x0f, 0x00, 0x19, 0x00, 0x23, 0x00, 0x4f, 0xb8, 0x00, 
	0x24, 0x2f, 0xb8, 0x00, 0x25, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x24, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 0x19, 0xd0, 0xb8, 0x00, 
	0x19, 0x2f, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x1a, 0xdc, 0xb8, 0x00, 0x1d, 0xd0, 0xb8, 0x00, 
	0x1d, 0x2f, 0x00, 0xba, 0x00, 0x21, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x21, 0x10, 0xba, 
	0x00, 0x0c, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0c, 0x10, 0x30, 0x31, 0x25, 0x14, 0x06, 
	0x2b, 0x01, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x27, 0x26, 0x2b, 
	0x01, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x17, 0x25, 0x35, 0x34, 0x27, 0x07, 0x16, 0x3b, 0x01, 0x32, 
	0x36, 0x01, 0xf4, 0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x64, 0x52, 0x76, 0xae, 0x10, 0x0a, 
	0x64, 0x29, 0x3b, 0x05, 0x01, 0x27, 0x03, 0xde, 0x10, 0x09, 0x64, 0x29, 0x3b, 0xc8, 0x52, 0x76, 
	0x76, 0x52, 0x64, 0x52, 0x76, 0x76, 0x52, 0x60, 0x04, 0x3b, 0x29, 0x64, 0x04, 0x14, 0x18, 0x64, 
	0x0d, 0x0d, 0xde, 0x04, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x33, 0x00, 0x03, 0x00, 0x17, 0x00, 0x43, 0xb8, 0x00, 0x18, 0x2f, 0xb8, 0x00, 0x19, 0x2f, 
	0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 
	0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x14, 0xd0, 
	0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x11, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 
	0x10, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 
	0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 
	0x35, 0x33, 0x11, 0x01, 0x38, 0x44, 0xa3, 0x45, 0xfa, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 0x64, 0x3b, 
	0x29, 0x32, 0x32, 0x64, 0x64, 0x02, 0x90, 0x44, 0xa2, 0x45, 0xfc, 0xcd, 0x8a, 0x3f, 0x4b, 0x75, 
	0x53, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0xfe, 0x0c, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x33, 0x00, 0x03, 0x00, 0x17, 0x00, 0x43, 0xb8, 0x00, 0x18, 0x2f, 
	0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x17, 0xdc, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x18, 0x10, 
	0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x04, 0x10, 
	0xb8, 0x00, 0x14, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x11, 0x00, 0x08, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x01, 
	0x07, 0x27, 0x37, 0x13, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 
	0x33, 0x32, 0x3f, 0x01, 0x35, 0x33, 0x11, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x32, 0x3e, 0x4b, 0x3f, 
	0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 0x02, 0xee, 0xa2, 0x44, 0xa3, 0xfc, 0xcd, 
	0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0xfe, 0x0c, 
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x2d, 0x00, 0x05, 0x00, 0x19, 0x00, 0x43, 
	0xb8, 0x00, 0x1a, 0x2f, 0xb8, 0x00, 0x1b, 0x2f, 0xb8, 0x00, 0x19, 0xdc, 0xb8, 0x00, 0x06, 0xdc, 
	0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x10, 0xdc, 
	0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x13, 
	0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x06, 
	0xd0, 0x30, 0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x37, 0x13, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 
	0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x33, 0x32, 0x3f, 0x01, 0x35, 0x33, 0x11, 0x01, 0x9c, 0x44, 
	0x5e, 0x5e, 0x45, 0xa3, 0x96, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 
	0x64, 0x02, 0x8a, 0x45, 0x5e, 0x5e, 0x45, 0xa3, 0xfc, 0xd3, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x01, 
	0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0xfe, 0x0c, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x2b, 0x00, 0x6d, 0xb8, 0x00, 
	0x2c, 0x2f, 0xb8, 0x00, 0x2d, 0x2f, 0xb8, 0x00, 0x2a, 0xdc, 0xb8, 0x00, 0x29, 0xdc, 0xb8, 0x00, 
	0x00, 0xd0, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 0x1f, 0xd0, 0xb8, 0x00, 0x1f, 0x2f, 0xb8, 0x00, 
	0x22, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x29, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xba, 0x00, 
	0x19, 0x00, 0x1f, 0x00, 0x2a, 0x11, 0x12, 0x39, 0x00, 0xba, 0x00, 0x25, 0x00, 0x1c, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x25, 0x10, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 
	0xd0, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 
	0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x13, 0x35, 0x07, 0x06, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 
	0x33, 0x32, 0x3f, 0x01, 0x35, 0x33, 0x11, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x3e, 0x4b, 0x3f, 0x53, 0x75, 
	0x64, 0x3b, 0x29, 0x32, 0x32, 0x64, 0x64, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 
	0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x8a, 0x3f, 0x4b, 0x75, 0x53, 0x01, 
	0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x32, 0x64, 0xfa, 0xfe, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0xff, 0x39, 0x01, 0xf4, 0x03, 0x33, 0x00, 0x03, 0x00, 0x1a, 0x00, 0x4b, 0xb8, 0x00, 0x1b, 0x2f, 
	0xb8, 0x00, 0x1c, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x1b, 0x10, 0xb8, 0x00, 0x11, 0xd0, 
	0xb8, 0x00, 0x11, 0x2f, 0xb8, 0x00, 0x14, 0xdc, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x04, 0x10, 
	0xb8, 0x00, 0x0d, 0xdc, 0xb8, 0x00, 0x18, 0xd0, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xba, 0x00, 0x0a, 
	0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0xba, 0x00, 0x18, 0x00, 0x0d, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x18, 0x10, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x13, 0x14, 0x06, 0x2b, 0x01, 
	0x35, 0x33, 0x32, 0x36, 0x35, 0x23, 0x22, 0x26, 0x35, 0x11, 0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 
	0x11, 0x33, 0x01, 0xa3, 0xa3, 0x45, 0xa3, 0x96, 0x76, 0x52, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 
	0x76, 0x64, 0x3b, 0x29, 0xc8, 0x64, 0x02, 0xee, 0xa2, 0x44, 0xa3, 0xfc, 0xcd, 0x52, 0x75, 0x64, 
	0x3b, 0x28, 0x76, 0x52, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x01, 0x90, 0x00, 0x02, 0x00, 0x00, 
	0xff, 0x39, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x0d, 0x00, 0x17, 0x00, 0x53, 0xb8, 0x00, 0x18, 0x2f, 
	0xb8, 0x00, 0x19, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x06, 0xd0, 
	0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0x00, 0xb8, 0x00, 0x07, 
	0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x15, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x15, 
	0x10, 0xba, 0x00, 0x0a, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0x30, 0x31, 0x25, 
	0x14, 0x06, 0x2b, 0x01, 0x15, 0x23, 0x11, 0x33, 0x15, 0x33, 0x32, 0x16, 0x15, 0x07, 0x35, 0x34, 
	0x26, 0x2b, 0x01, 0x11, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x76, 0x52, 0xc8, 0x64, 0x64, 0xc8, 0x52, 
	0x76, 0x64, 0x3b, 0x29, 0xc8, 0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0xc7, 0x03, 0x83, 0xc8, 0x76, 
	0x52, 0x64, 0x64, 0x29, 0x3b, 0xfe, 0xd4, 0x3b, 0x00, 0x03, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 
	0x02, 0xbc, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x2e, 0x00, 0x6f, 0xb8, 0x00, 0x2f, 0x2f, 0xb8, 0x00, 
	0x30, 0x2f, 0xb8, 0x00, 0x2e, 0xdc, 0xb8, 0x00, 0x2d, 0xdc, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 
	0x2f, 0x10, 0xb8, 0x00, 0x25, 0xd0, 0xb8, 0x00, 0x25, 0x2f, 0xb8, 0x00, 0x28, 0xdc, 0xb8, 0x00, 
	0x12, 0xd0, 0xb8, 0x00, 0x28, 0x10, 0xb8, 0x00, 0x1c, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 
	0x21, 0xd0, 0x00, 0xba, 0x00, 0x1e, 0x00, 0x1b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xba, 
	0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x2c, 0x00, 0x21, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 
	0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 
	0x16, 0x01, 0x14, 0x06, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x23, 0x22, 0x26, 0x35, 0x11, 
	0x33, 0x11, 0x14, 0x16, 0x3b, 0x01, 0x11, 0x33, 0x01, 0x90, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 0x2c, 0x76, 0x52, 0xc8, 
	0xc8, 0x29, 0x3b, 0xc8, 0x52, 0x76, 0x64, 0x3b, 0x29, 0xc8, 0x64, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 
	0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfd, 0x61, 0x52, 0x75, 
	0x64, 0x3b, 0x28, 0x76, 0x52, 0x01, 0x2c, 0xfe, 0xd4, 0x29, 0x3b, 0x01, 0x90, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x64, 0x00, 0x00, 0x01, 0x90, 0x01, 0xf4, 0x00, 0x09, 0x00, 0x3b, 0xba, 0x00, 
	0x08, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 
	0x02, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xba, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x09, 0x10, 0xba, 0x00, 0x06, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xb8, 
	0x00, 0x09, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0x30, 0x31, 0x29, 0x01, 0x35, 0x33, 0x11, 0x23, 0x35, 
	0x33, 0x11, 0x33, 0x01, 0x90, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 0x2c, 0x64, 0xfe, 
	0x70, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x11, 
	0x00, 0x19, 0x00, 0x6f, 0xb8, 0x00, 0x1a, 0x2f, 0xb8, 0x00, 0x1b, 0x2f, 0xb8, 0x00, 0x10, 0xdc, 
	0xb8, 0x00, 0x12, 0xdc, 0xb8, 0x00, 0x01, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x04, 0xd0, 
	0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x10, 0x10, 
	0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x17, 0xdc, 0x00, 0xba, 0x00, 0x11, 
	0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 
	0x10, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x13, 
	0xd0, 0x30, 0x31, 0x29, 0x01, 0x22, 0x26, 0x35, 0x11, 0x34, 0x36, 0x33, 0x21, 0x15, 0x23, 0x15, 
	0x33, 0x15, 0x23, 0x15, 0x33, 0x21, 0x11, 0x22, 0x06, 0x15, 0x11, 0x14, 0x16, 0x01, 0xf4, 0xfe, 
	0xd4, 0x52, 0x76, 0x76, 0x52, 0x01, 0x2c, 0xc8, 0x64, 0x64, 0xc8, 0xfe, 0xd4, 0x29, 0x3b, 0x3b, 
	0x76, 0x52, 0x01, 0x2c, 0x52, 0x76, 0x64, 0xc8, 0x64, 0xc8, 0x01, 0xf4, 0x3b, 0x29, 0xfe, 0xd4, 
	0x29, 0x3b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x01, 0xf4, 0x00, 0x1c, 
	0x00, 0x28, 0x00, 0x36, 0x00, 0x1e, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x07, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0a, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc4, 0x00, 
	0x12, 0x00, 0x01, 0x5d, 0x21, 0x23, 0x22, 0x27, 0x06, 0x23, 0x22, 0x26, 0x3d, 0x01, 0x34, 0x36, 
	0x33, 0x32, 0x17, 0x36, 0x33, 0x32, 0x16, 0x1d, 0x01, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x3b, 
	0x01, 0x27, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x07, 0x35, 0x34, 
	0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x14, 0x16, 0x33, 0x32, 0x36, 0x01, 0xf4, 0x96, 0x37, 0x2b, 
	0x2a, 0x3c, 0x3e, 0x58, 0x58, 0x3e, 0x3b, 0x2c, 0x2b, 0x36, 0x3e, 0x58, 0x96, 0x15, 0x1d, 0x1d, 
	0x15, 0x96, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x28, 0x28, 0x58, 0x3e, 0xc8, 0x3e, 0x58, 0x29, 0x29, 0x58, 0x3e, 0x96, 
	0x1d, 0x15, 0x15, 0x1d, 0xfa, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xb3, 0xc8, 0x15, 0x1d, 
	0x1d, 0x15, 0xc8, 0x15, 0x1d, 0x1d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x84, 0x00, 0x33, 0x00, 0x8f, 0xb8, 0x00, 0x34, 0x2f, 0xb8, 0x00, 0x35, 0x2f, 0xb8, 0x00, 
	0x34, 0x10, 0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x22, 0x2f, 0xb8, 0x00, 0x35, 0x10, 0xb8, 0x00, 
	0x0c, 0xdc, 0xba, 0x00, 0x01, 0x00, 0x22, 0x00, 0x0c, 0x11, 0x12, 0x39, 0xba, 0x00, 0x08, 0x00, 
	0x22, 0x00, 0x0c, 0x11, 0x12, 0x39, 0xb8, 0x00, 0x0d, 0xdc, 0xb8, 0x00, 0x22, 0x10, 0xb8, 0x00, 
	0x23, 0xdc, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 
	0x0d, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0xb8, 0x00, 0x22, 0x10, 0xb8, 0x00, 0x31, 0xd0, 0x00, 0xb8, 
	0x00, 0x04, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x27, 0x00, 0x1e, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x27, 0x10, 0xba, 0x00, 0x09, 0x00, 0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 
	0x00, 0x18, 0x00, 0x2d, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x00, 0xd0, 0x30, 0x31, 0x13, 0x33, 0x26, 0x27, 0x37, 0x17, 0x37, 0x17, 0x07, 0x33, 0x32, 
	0x16, 0x15, 0x23, 0x34, 0x26, 0x2b, 0x01, 0x22, 0x06, 0x15, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x16, 
	0x15, 0x14, 0x06, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x33, 0x14, 0x16, 0x3b, 0x01, 0x32, 0x36, 0x35, 
	0x34, 0x26, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x34, 0x36, 0xc8, 0x13, 0x24, 0x5f, 0x44, 0x5e, 0x5e, 
	0x45, 0x84, 0x13, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x53, 0x75, 
	0x75, 0x53, 0x64, 0x53, 0x75, 0x64, 0x3b, 0x29, 0x64, 0x29, 0x3b, 0x3b, 0x29, 0x64, 0x53, 0x75, 
	0x75, 0x02, 0xbc, 0x24, 0x5f, 0x45, 0x5e, 0x5e, 0x45, 0x83, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 
	0x29, 0x3b, 0x75, 0x53, 0x53, 0x75, 0x75, 0x53, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x75, 0x53, 
	0x53, 0x75, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x33, 0x00, 0x05, 
	0x00, 0x25, 0x00, 0x2f, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xba, 0x00, 0x18, 
	0x00, 0x15, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x18, 0x10, 0xba, 0x00, 0x0f, 0x00, 0x1e, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 0x00, 0x06, 0x00, 0x07, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 
	0x10, 0x30, 0x31, 0x01, 0x07, 0x27, 0x37, 0x17, 0x37, 0x13, 0x15, 0x21, 0x22, 0x06, 0x15, 0x14, 
	0x16, 0x3b, 0x01, 0x32, 0x16, 0x15, 0x14, 0x06, 0x23, 0x21, 0x35, 0x21, 0x32, 0x36, 0x35, 0x34, 
	0x26, 0x2b, 0x01, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x01, 0x9a, 0xa2, 0xa3, 0x45, 0x5e, 0x5e, 
	0x9e, 0xfe, 0xfa, 0x34, 0x49, 0x49, 0x34, 0x19, 0x5d, 0x84, 0x84, 0x5d, 0xfe, 0xf9, 0x01, 0x07, 
	0x33, 0x4a, 0x4a, 0x33, 0x19, 0x5e, 0x83, 0x83, 0x5e, 0x02, 0xef, 0xa3, 0xa3, 0x44, 0x5d, 0x5d, 
	0xfe, 0xc1, 0x64, 0x1d, 0x15, 0x15, 0x1d, 0x58, 0x3e, 0x3e, 0x58, 0x64, 0x1d, 0x15, 0x15, 0x1d, 
	0x58, 0x3e, 0x3e, 0x58, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x0b, 
	0x00, 0x17, 0x00, 0x24, 0x00, 0xa1, 0xb8, 0x00, 0x25, 0x2f, 0xb8, 0x00, 0x1d, 0xd0, 0xb8, 0x00, 
	0x1d, 0x2f, 0xb8, 0x00, 0x0c, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x0c, 0x00, 0x01, 0x5d, 0x41, 
	0x03, 0x00, 0x90, 0x00, 0x0c, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x0c, 0x00, 0x01, 
	0x71, 0xb8, 0x00, 0x23, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x23, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0x90, 0x00, 0x23, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x23, 0x00, 0x01, 0x71, 
	0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x20, 0xdc, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x19, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x23, 0x10, 0xb8, 0x00, 0x24, 0xdc, 
	0xb8, 0x00, 0x26, 0xdc, 0x00, 0xb8, 0x00, 0x1a, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 
	0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 
	0x07, 0x15, 0x23, 0x35, 0x27, 0x11, 0x33, 0x15, 0x17, 0x37, 0x35, 0x33, 0x01, 0x90, 0x1d, 0x15, 
	0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x01, 
	0x2c, 0xc8, 0x64, 0xc8, 0x64, 0x96, 0x96, 0x64, 0x03, 0x52, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0xfe, 0x48, 0xc8, 0xe7, 0xe7, 0xc8, 0x01, 
	0x0d, 0xe7, 0x96, 0x96, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 
	0x03, 0x7f, 0x00, 0x0b, 0x00, 0x12, 0x00, 0x27, 0x00, 0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x0e, 
	0x2f, 0xba, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x05, 
	0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x30, 0x31, 0x25, 
	0x21, 0x35, 0x01, 0x35, 0x21, 0x15, 0x21, 0x15, 0x01, 0x15, 0x21, 0x01, 0x17, 0x37, 0x17, 0x07, 
	0x23, 0x27, 0x01, 0xf4, 0xfe, 0x70, 0x01, 0x90, 0xfe, 0x0c, 0x01, 0x90, 0xfe, 0x70, 0x01, 0xf4, 
	0xfe, 0xa7, 0x5e, 0x5e, 0x44, 0x7d, 0x4a, 0x7e, 0x64, 0x26, 0x01, 0x90, 0xa2, 0x64, 0x16, 0xfe, 
	0x71, 0xb3, 0x03, 0x7f, 0x5e, 0x5e, 0x45, 0x7e, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xf4, 0x03, 0x2e, 0x00, 0x09, 0x00, 0x0f, 0x00, 0x23, 0x00, 0xb8, 0x00, 0x0b, 
	0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0xba, 0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x30, 0x31, 0x29, 
	0x01, 0x35, 0x01, 0x21, 0x35, 0x21, 0x15, 0x01, 0x21, 0x01, 0x37, 0x17, 0x37, 0x17, 0x07, 0x01, 
	0xf4, 0xfe, 0x0c, 0x01, 0x4b, 0xfe, 0xb5, 0x01, 0xf4, 0xfe, 0xb5, 0x01, 0x4b, 0xfe, 0x66, 0x44, 
	0x5e, 0x5e, 0x45, 0xa3, 0x45, 0x01, 0x4b, 0x64, 0x45, 0xfe, 0xb5, 0x02, 0x86, 0x44, 0x5d, 0x5d, 
	0x44, 0xa3, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xff, 0x39, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x1b, 
	0x00, 0x37, 0x00, 0xba, 0x00, 0x0f, 0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 
	0x00, 0x1b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1b, 0x10, 0xba, 0x00, 0x06, 0x00, 0x07, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0xb8, 
	0x00, 0x06, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x33, 
	0x15, 0x23, 0x11, 0x14, 0x06, 0x2b, 0x01, 0x35, 0x33, 0x32, 0x36, 0x35, 0x11, 0x23, 0x35, 0x33, 
	0x35, 0x34, 0x36, 0x3b, 0x01, 0x01, 0xf4, 0x64, 0x29, 0x3b, 0x64, 0x64, 0x76, 0x52, 0x64, 0x64, 
	0x29, 0x3b, 0x64, 0x64, 0x76, 0x52, 0x64, 0x03, 0x20, 0x3b, 0x29, 0xc8, 0x64, 0xfe, 0x70, 0x51, 
	0x76, 0x64, 0x3b, 0x28, 0x01, 0x90, 0x64, 0xc8, 0x52, 0x76, 0x00, 0x00, 0x00, 0x01, 0x00, 0x57, 
	0x02, 0x4c, 0x01, 0x9c, 0x03, 0x33, 0x00, 0x05, 0x00, 0x0f, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 
	0x00, 0x01, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x27, 0x07, 0x27, 0x37, 0x01, 
	0x9c, 0x44, 0x5e, 0x5e, 0x45, 0xa3, 0x02, 0x90, 0x44, 0x5d, 0x5d, 0x44, 0xa3, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x55, 0x02, 0x4c, 0x01, 0x9a, 0x03, 0x33, 0x00, 0x05, 0x00, 0x0f, 0x00, 0xb8, 
	0x00, 0x03, 0x2f, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x27, 
	0x37, 0x17, 0x37, 0x01, 0x9a, 0xa2, 0xa3, 0x45, 0x5e, 0x5e, 0x02, 0xef, 0xa3, 0xa3, 0x44, 0x5d, 
	0x5d, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69, 0x02, 0x58, 0x01, 0xf9, 0x03, 0x20, 0x00, 0x0e, 
	0x00, 0x1b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xba, 
	0x00, 0x0a, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0a, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 
	0x23, 0x22, 0x26, 0x35, 0x33, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x33, 0x01, 0xf9, 0x76, 0x52, 
	0x53, 0x75, 0x64, 0x3b, 0x29, 0x29, 0x3b, 0x64, 0x03, 0x20, 0x52, 0x76, 0x75, 0x53, 0x29, 0x3b, 
	0x3b, 0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0xcd, 0x01, 0xf4, 0x01, 0x95, 0x02, 0xbc, 0x00, 0x0b, 
	0x00, 0x62, 0xba, 0x00, 0x00, 0x00, 0x06, 0x00, 0x03, 0x2b, 0x41, 0x0f, 0x00, 0x96, 0x00, 0x00, 
	0x00, 0xa6, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x00, 0xd6, 0x00, 0x00, 
	0x00, 0xe6, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x00, 0x00, 0x07, 0x5d, 0x41, 0x0d, 0x00, 0x06, 0x00, 
	0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x46, 0x00, 
	0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x06, 0x71, 0x41, 0x05, 0x00, 0x65, 0x00, 0x00, 0x00, 0x75, 
	0x00, 0x00, 0x00, 0x02, 0x71, 0x00, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x09, 0x10, 0x30, 0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 
	0x01, 0x95, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x02, 0x58, 0x29, 0x3b, 0x3b, 0x29, 
	0x29, 0x3b, 0x3b, 0x00, 0x00, 0x02, 0x00, 0x69, 0x01, 0xf4, 0x01, 0x95, 0x03, 0x20, 0x00, 0x0b, 
	0x00, 0x17, 0x00, 0x27, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xcc, 0x00, 0x0d, 0x00, 0x01, 0x5d, 
	0x41, 0x03, 0x00, 0xcc, 0x00, 0x11, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x13, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x17, 0x00, 0x01, 0x5d, 0x01, 0x34, 0x26, 0x23, 0x22, 
	0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x37, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 
	0x33, 0x32, 0x16, 0x01, 0x31, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x64, 0x58, 0x3e, 
	0x3e, 0x58, 0x58, 0x3e, 0x3e, 0x58, 0x02, 0x8a, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 
	0x3e, 0x58, 0x58, 0x3e, 0x3e, 0x58, 0x58, 0x00, 0x00, 0x01, 0x00, 0x64, 0xff, 0x39, 0x01, 0x38, 
	0x00, 0x64, 0x00, 0x07, 0x00, 0x1f, 0xba, 0x00, 0x05, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x05, 0x10, 0x00, 0xb8, 0x00, 0x01, 0x2f, 0xba, 0x00, 0x04, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x04, 0x10, 0x30, 0x31, 0x05, 0x07, 0x27, 0x35, 0x33, 0x15, 0x23, 0x15, 0x01, 0x38, 0x44, 
	0x90, 0xc8, 0x64, 0x82, 0x45, 0x90, 0x9b, 0x64, 0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x02, 0x58, 0x01, 0xf4, 0x03, 0x20, 0x00, 0x19, 0x00, 0x15, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 
	0xcb, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc3, 0x00, 0x0e, 0x00, 0x01, 0x5d, 0x01, 
	0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x36, 0x33, 
	0x32, 0x17, 0x16, 0x33, 0x32, 0x36, 0x3d, 0x01, 0x33, 0x01, 0xf4, 0x58, 0x3e, 0x3e, 0x26, 0x3e, 
	0x26, 0x15, 0x1d, 0x64, 0x58, 0x3e, 0x3f, 0x25, 0x3f, 0x25, 0x15, 0x1d, 0x64, 0x02, 0xee, 0x3e, 
	0x58, 0x26, 0x3e, 0x1d, 0x15, 0x32, 0x32, 0x3e, 0x58, 0x25, 0x3f, 0x1d, 0x15, 0x32, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x05, 0x02, 0x4c, 0x02, 0x0c, 0x03, 0x33, 0x00, 0x03, 0x00, 0x07, 0x00, 0x13, 
	0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 
	0x2f, 0x30, 0x31, 0x13, 0x27, 0x37, 0x1f, 0x01, 0x27, 0x37, 0x17, 0x4a, 0x45, 0xa2, 0x45, 0x7d, 
	0x45, 0xa3, 0x45, 0x02, 0x4c, 0x44, 0xa3, 0x45, 0xa2, 0x44, 0xa3, 0x45, 0x00, 0x01, 0x00, 0x64, 
	0x01, 0x2c, 0x01, 0x90, 0x01, 0x90, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 0x21, 0x01, 0x90, 0xfe, 
	0xd4, 0x01, 0x2c, 0x01, 0x2c, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x02, 0x58, 
	0x01, 0x90, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x21, 0x35, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0x01, 
	0x2c, 0x64, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x00, 0x00, 0x00, 0x03, 
	0x00, 0x07, 0x00, 0x1b, 0x00, 0xba, 0x00, 0x07, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 
	0x10, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x05, 
	0x21, 0x35, 0x21, 0x11, 0x21, 0x35, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0xfd, 0xa8, 0x02, 
	0x58, 0x64, 0x64, 0xfe, 0xd4, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 0x01, 0x90, 0x01, 0x87, 
	0x02, 0xdd, 0x00, 0x09, 0x00, 0x17, 0xba, 0x00, 0x04, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x04, 0x10, 0x00, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x06, 
	0x1d, 0x01, 0x23, 0x35, 0x34, 0x3f, 0x01, 0x01, 0x87, 0x3d, 0x1e, 0x64, 0x3b, 0x3e, 0x02, 0x96, 
	0x3e, 0x1e, 0x26, 0x84, 0x85, 0x4f, 0x3b, 0x3e, 0x00, 0x01, 0x00, 0xd1, 0x01, 0x6f, 0x01, 0x90, 
	0x02, 0xbc, 0x00, 0x09, 0x00, 0x13, 0xba, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03, 0x2b, 0x00, 0xb8, 
	0x00, 0x08, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0x30, 0x31, 0x01, 0x14, 0x0f, 0x01, 0x27, 0x37, 0x36, 
	0x3d, 0x01, 0x33, 0x01, 0x90, 0x3b, 0x3e, 0x46, 0x3d, 0x1e, 0x64, 0x02, 0x37, 0x4f, 0x3b, 0x3e, 
	0x47, 0x3e, 0x1e, 0x26, 0x84, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x09, 0xff, 0x7c, 0x00, 0xc8, 
	0x00, 0xc8, 0x00, 0x09, 0x00, 0x13, 0xba, 0x00, 0x00, 0x00, 0x07, 0x00, 0x03, 0x2b, 0x00, 0xb8, 
	0x00, 0x03, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0x30, 0x31, 0x37, 0x14, 0x0f, 0x01, 0x27, 0x37, 0x36, 
	0x3d, 0x01, 0x33, 0xc8, 0x3b, 0x3e, 0x46, 0x3d, 0x1e, 0x64, 0x43, 0x4e, 0x3b, 0x3e, 0x47, 0x3d, 
	0x1e, 0x26, 0x84, 0x00, 0x00, 0x02, 0x00, 0x64, 0x01, 0x90, 0x01, 0xeb, 0x02, 0xdd, 0x00, 0x09, 
	0x00, 0x13, 0x00, 0x33, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 
	0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x0f, 0x2f, 
	0xb8, 0x00, 0x0e, 0xdc, 0x00, 0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x13, 0x2f, 0xb8, 0x00, 0x04, 
	0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0x30, 0x31, 0x01, 0x07, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x3f, 
	0x01, 0x0f, 0x01, 0x06, 0x1d, 0x01, 0x23, 0x35, 0x34, 0x3f, 0x01, 0x01, 0xeb, 0x3d, 0x1e, 0x64, 
	0x3b, 0x3e, 0x82, 0x3d, 0x1e, 0x64, 0x3b, 0x3e, 0x02, 0x96, 0x3e, 0x1e, 0x26, 0x84, 0x85, 0x4f, 
	0x3b, 0x3e, 0x47, 0x3e, 0x1e, 0x26, 0x84, 0x85, 0x4f, 0x3b, 0x3e, 0x00, 0x00, 0x02, 0x00, 0x6d, 
	0x01, 0x6f, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x09, 0x00, 0x13, 0x00, 0x33, 0xb8, 0x00, 0x14, 0x2f, 
	0xb8, 0x00, 0x15, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x14, 0x10, 
	0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x11, 0x2f, 0xb8, 0x00, 0x0a, 0xdc, 0x00, 0xb8, 0x00, 0x08, 
	0x2f, 0xb8, 0x00, 0x12, 0x2f, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0x30, 0x31, 0x01, 
	0x14, 0x0f, 0x01, 0x27, 0x37, 0x36, 0x3d, 0x01, 0x33, 0x07, 0x14, 0x0f, 0x01, 0x27, 0x37, 0x36, 
	0x3d, 0x01, 0x33, 0x01, 0xf4, 0x3b, 0x3e, 0x46, 0x3d, 0x1e, 0x64, 0xc8, 0x3b, 0x3e, 0x46, 0x3d, 
	0x1e, 0x64, 0x02, 0x37, 0x4f, 0x3b, 0x3e, 0x47, 0x3e, 0x1e, 0x26, 0x84, 0x85, 0x4f, 0x3b, 0x3e, 
	0x47, 0x3e, 0x1e, 0x26, 0x84, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x09, 0xff, 0x7c, 0x01, 0x90, 
	0x00, 0xc8, 0x00, 0x09, 0x00, 0x13, 0x00, 0x33, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 0x15, 0x2f, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x07, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x11, 0xd0, 
	0xb8, 0x00, 0x11, 0x2f, 0xb8, 0x00, 0x0a, 0xdc, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x0d, 
	0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x12, 0x2f, 0x30, 0x31, 0x25, 0x14, 0x0f, 0x01, 0x27, 
	0x37, 0x36, 0x3d, 0x01, 0x33, 0x07, 0x14, 0x0f, 0x01, 0x27, 0x37, 0x36, 0x3d, 0x01, 0x33, 0x01, 
	0x90, 0x3b, 0x3e, 0x46, 0x3d, 0x1e, 0x64, 0xc8, 0x3b, 0x3e, 0x46, 0x3d, 0x1e, 0x64, 0x43, 0x4e, 
	0x3b, 0x3e, 0x47, 0x3d, 0x1e, 0x26, 0x84, 0x85, 0x4e, 0x3b, 0x3e, 0x47, 0x3d, 0x1e, 0x26, 0x84, 
	0x00, 0x01, 0x00, 0x64, 0x00, 0xc8, 0x01, 0x90, 0x02, 0xbc, 0x00, 0x0b, 0x00, 0x43, 0xba, 0x00, 
	0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 
	0x00, 0x02, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 
	0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0x30, 
	0x31, 0x01, 0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x01, 0x90, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x01, 0xf4, 0xfe, 0xd4, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x64, 0x00, 0xc8, 0x01, 0x90, 0x02, 0xbc, 0x00, 0x13, 0x00, 0x6f, 0xba, 0x00, 
	0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 
	0x0d, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 
	0x00, 0x0c, 0x2f, 0xba, 0x00, 0x13, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 0x10, 0xba, 
	0x00, 0x0b, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 
	0x00, 0x04, 0xd0, 0xb8, 0x00, 0x13, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 
	0x00, 0x0e, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x15, 
	0x23, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 
	0x33, 0x01, 0x90, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x01, 0x2c, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64, 0x01, 0xf4, 
	0x02, 0x58, 0x00, 0x0b, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x09, 0x2f, 0x30, 
	0x31, 0x01, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0xf4, 0x92, 
	0x68, 0x68, 0x92, 0x93, 0x67, 0x68, 0x92, 0x01, 0x5e, 0x68, 0x92, 0x92, 0x68, 0x68, 0x92, 0x92, 
	0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x64, 0x00, 0x0b, 0x00, 0x17, 0x00, 0x23, 
	0x00, 0x2f, 0x00, 0xba, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x03, 0x10, 0xb8, 0x00, 0x0f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 
	0x00, 0x03, 0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x21, 0xd0, 0x30, 
	0x31, 0x25, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 
	0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x07, 0x14, 0x06, 0x23, 0x22, 0x26, 0x35, 
	0x34, 0x36, 0x33, 0x32, 0x16, 0x01, 0xf4, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x32, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 
	0x00, 0x00, 0x02, 0x5d, 0x03, 0x20, 0x00, 0x1e, 0x00, 0x24, 0x00, 0x30, 0x00, 0x3c, 0x00, 0x48, 
	0x00, 0x1e, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 0xce, 0x00, 0x01, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0xc2, 0x00, 0x13, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0xc2, 0x00, 0x1e, 0x00, 0x01, 0x5d, 
	0x25, 0x14, 0x06, 0x23, 0x22, 0x27, 0x06, 0x23, 0x22, 0x26, 0x35, 0x34, 0x37, 0x07, 0x35, 0x37, 
	0x2e, 0x01, 0x35, 0x34, 0x36, 0x33, 0x21, 0x15, 0x01, 0x16, 0x17, 0x36, 0x33, 0x32, 0x16, 0x03, 
	0x23, 0x16, 0x15, 0x14, 0x07, 0x27, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 
	0x36, 0x01, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x27, 0x34, 0x26, 
	0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x02, 0x5d, 0x58, 0x3e, 0x38, 0x2c, 0x2b, 
	0x39, 0x3e, 0x58, 0x02, 0x66, 0x83, 0x37, 0x4c, 0x58, 0x3e, 0x01, 0xc2, 0xfe, 0xb5, 0x2e, 0x23, 
	0x2b, 0x39, 0x3e, 0x58, 0xab, 0x95, 0x14, 0x02, 0x62, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 
	0x1d, 0x01, 0x2c, 0x1d, 0x15, 0x15, 0x1d, 0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x1d, 0x15, 0x15, 0x1d, 
	0x1d, 0x15, 0x15, 0x1d, 0xc8, 0x53, 0x75, 0x33, 0x33, 0x75, 0x53, 0x15, 0x0a, 0x66, 0x8e, 0x83, 
	0x0a, 0x70, 0x4c, 0x53, 0x75, 0x47, 0xfe, 0xb5, 0x07, 0x2a, 0x33, 0x75, 0x01, 0xa1, 0x2d, 0x37, 
	0x0b, 0x14, 0x1f, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0xfe, 0x99, 0x29, 0x3b, 0x3b, 0x29, 
	0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x29, 0x29, 0x3b, 0x3b, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xff, 0xe3, 0x00, 0xbe, 0x01, 0xae, 0x00, 0x05, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 
	0x00, 0x01, 0x2f, 0x30, 0x31, 0x37, 0x07, 0x27, 0x37, 0x17, 0x07, 0xbe, 0x5c, 0x62, 0x62, 0x5c, 
	0x54, 0x09, 0x26, 0xe5, 0xe6, 0x27, 0xbf, 0x00, 0x00, 0x01, 0x00, 0x0a, 0xff, 0xe3, 0x00, 0xc8, 
	0x01, 0xae, 0x00, 0x05, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x05, 0x2f, 0xb8, 0x00, 0x01, 0x2f, 0x30, 
	0x31, 0x37, 0x07, 0x27, 0x37, 0x27, 0x37, 0xc8, 0x62, 0x5c, 0x54, 0x54, 0x5c, 0xc8, 0xe5, 0x26, 
	0xbf, 0xbf, 0x27, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x02, 0xbc, 0x00, 0x2b, 
	0x00, 0xb3, 0xb8, 0x00, 0x2c, 0x2f, 0xb8, 0x00, 0x2d, 0x2f, 0xb8, 0x00, 0x2c, 0x10, 0xb8, 0x00, 
	0x01, 0xd0, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 
	0x0d, 0xdc, 0xb8, 0x00, 0x0e, 0xdc, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x18, 0xdc, 0xb8, 0x00, 
	0x14, 0xd0, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 
	0x21, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 
	0x2a, 0xd0, 0x00, 0xba, 0x00, 0x1e, 0x00, 0x26, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1e, 0x10, 0xba, 
	0x00, 0x09, 0x00, 0x11, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x19, 0x00, 0x1a, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x19, 0x10, 0xba, 0x00, 0x05, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x19, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x0d, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x14, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 
	0x00, 0x16, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x21, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 
	0x00, 0x2a, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x35, 0x23, 0x35, 0x33, 0x34, 0x37, 0x36, 0x33, 0x32, 
	0x17, 0x16, 0x15, 0x23, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 
	0x23, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x33, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27, 0x26, 0x35, 
	0x23, 0x64, 0x64, 0x64, 0x3b, 0x3b, 0x52, 0x52, 0x3b, 0x3b, 0x64, 0x3a, 0x2a, 0x2a, 0x3a, 0x64, 
	0x64, 0x64, 0x64, 0x3a, 0x2a, 0x2a, 0x3a, 0x64, 0x3b, 0x3b, 0x52, 0x52, 0x3b, 0x3b, 0x64, 0x01, 
	0x2c, 0x64, 0x64, 0x52, 0x3b, 0x3b, 0x3b, 0x3b, 0x52, 0x2a, 0x3a, 0x3a, 0x2a, 0x64, 0x64, 0x64, 
	0x2a, 0x3a, 0x3a, 0x2a, 0x52, 0x3b, 0x3b, 0x3b, 0x3b, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x01, 0x90, 0x02, 0x58, 0x02, 0xbc, 0x00, 0x11, 0x00, 0x0c, 0x30, 0x31, 0x00, 0x41, 0x03, 0x00, 
	0xcc, 0x00, 0x03, 0x00, 0x01, 0x5d, 0x01, 0x23, 0x35, 0x07, 0x27, 0x15, 0x23, 0x35, 0x23, 0x15, 
	0x23, 0x35, 0x23, 0x35, 0x21, 0x17, 0x37, 0x33, 0x02, 0x58, 0x64, 0x32, 0x32, 0x64, 0x64, 0x64, 
	0x64, 0x01, 0x90, 0x32, 0x32, 0x64, 0x01, 0x90, 0x96, 0x64, 0x64, 0x96, 0xc8, 0xc8, 0xc8, 0x64, 
	0x64, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64, 0x01, 0xf4, 0x01, 0x90, 0x00, 0x05, 
	0x00, 0x1f, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x00, 0xb8, 
	0x00, 0x04, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0x30, 
	0x31, 0x11, 0x21, 0x15, 0x21, 0x15, 0x23, 0x01, 0xf4, 0xfe, 0x70, 0x64, 0x01, 0x90, 0x64, 0xc8, 
	0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x02, 0x58, 0x01, 0x90, 0x00, 0x03, 0x00, 0x0f, 0x00, 0xba, 
	0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0x30, 0x31, 0x11, 0x21, 0x15, 
	0x21, 0x02, 0x58, 0xfd, 0xa8, 0x01, 0x90, 0x64, 0x00, 0x01, 0x00, 0xc8, 0xfe, 0xd4, 0x01, 0x2c, 
	0x03, 0x84, 0x00, 0x03, 0x00, 0x17, 0xba, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x01, 0x10, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0x30, 0x31, 0x13, 0x33, 0x11, 
	0x23, 0xc8, 0x64, 0x64, 0x03, 0x84, 0xfb, 0x50, 0x00, 0x01, 0x00, 0xc8, 0xfe, 0xd4, 0x02, 0x58, 
	0x01, 0x90, 0x00, 0x05, 0x00, 0x1b, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 0x00, 0xb8, 
	0x00, 0x00, 0x2f, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 
	0x31, 0x01, 0x23, 0x11, 0x21, 0x15, 0x21, 0x01, 0x2c, 0x64, 0x01, 0x90, 0xfe, 0xd4, 0xfe, 0xd4, 
	0x02, 0xbc, 0x64, 0x00, 0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x2c, 0x01, 0x90, 0x00, 0x05, 
	0x00, 0x1f, 0xba, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x02, 0x10, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0x30, 
	0x31, 0x11, 0x21, 0x11, 0x23, 0x11, 0x23, 0x01, 0x2c, 0x64, 0xc8, 0x01, 0x90, 0xfd, 0x44, 0x02, 
	0x58, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 0x01, 0x2c, 0x02, 0x58, 0x03, 0x84, 0x00, 0x05, 
	0x00, 0x1f, 0xba, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0x00, 0xb8, 
	0x00, 0x00, 0x2f, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 
	0x31, 0x13, 0x33, 0x11, 0x21, 0x15, 0x21, 0xc8, 0x64, 0x01, 0x2c, 0xfe, 0x70, 0x03, 0x84, 0xfe, 
	0x0c, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x2c, 0x03, 0x84, 0x00, 0x05, 
	0x00, 0x1f, 0xba, 0x00, 0x04, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0x30, 
	0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x21, 0xc8, 0x64, 0xfe, 0xd4, 0x01, 0x90, 0x01, 0xf4, 0xfd, 
	0xa8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x07, 
	0x00, 0x23, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0xd0, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xb8, 0x00, 0x00, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x05, 0x10, 0x30, 0x31, 0x01, 0x23, 0x11, 0x33, 0x11, 0x21, 0x15, 0x21, 0x01, 0x2c, 0x64, 
	0x64, 0x01, 0x2c, 0xfe, 0xd4, 0xfe, 0xd4, 0x04, 0xb0, 0xfe, 0x0c, 0x64, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xd4, 0x01, 0x2c, 0x03, 0x84, 0x00, 0x07, 0x00, 0x2b, 0xba, 0x00, 0x03, 0x00, 0x02, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xb8, 
	0x00, 0x04, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x23, 0x11, 0x23, 0xc8, 0x64, 0x64, 
	0xc8, 0x01, 0x90, 0x01, 0xf4, 0xfb, 0x50, 0x02, 0x58, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x01, 0x90, 0x00, 0x07, 0x00, 0x27, 0xba, 0x00, 0x04, 0x00, 0x05, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0x00, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x02, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0x30, 
	0x31, 0x11, 0x21, 0x15, 0x21, 0x11, 0x23, 0x11, 0x23, 0x02, 0x58, 0xfe, 0xd4, 0x64, 0xc8, 0x01, 
	0x90, 0x64, 0xfd, 0xa8, 0x02, 0x58, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x07, 0x00, 0x23, 0xba, 0x00, 0x04, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x04, 0x10, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x05, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x21, 0x15, 
	0x21, 0xc8, 0x64, 0x01, 0x2c, 0xfd, 0xa8, 0x01, 0x90, 0x01, 0xf4, 0xfe, 0x0c, 0x64, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x0b, 0x00, 0x3b, 0xba, 0x00, 
	0x04, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 
	0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 
	0x00, 0x06, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x21, 0x15, 
	0x21, 0x11, 0x23, 0x11, 0x23, 0xc8, 0x64, 0x01, 0x2c, 0xfe, 0xd4, 0x64, 0xc8, 0x01, 0x90, 0x01, 
	0xf4, 0xfe, 0x0c, 0x64, 0xfd, 0xa8, 0x02, 0x58, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc8, 0x02, 0x58, 
	0x01, 0xf4, 0x00, 0x03, 0x00, 0x07, 0x00, 0x1b, 0x00, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 
	0x10, 0x30, 0x31, 0x11, 0x21, 0x15, 0x21, 0x11, 0x21, 0x15, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0x02, 
	0x58, 0xfd, 0xa8, 0x01, 0x2c, 0x64, 0x01, 0x2c, 0x64, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x64, 
	0xfe, 0xd4, 0x01, 0x90, 0x03, 0x84, 0x00, 0x03, 0x00, 0x07, 0x00, 0x37, 0xb8, 0x00, 0x08, 0x2f, 
	0xb8, 0x00, 0x09, 0x2f, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x00, 0x2f, 
	0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x04, 0xdc, 
	0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x06, 
	0x2f, 0x30, 0x31, 0x13, 0x33, 0x11, 0x23, 0x13, 0x33, 0x11, 0x23, 0x64, 0x64, 0x64, 0xc8, 0x64, 
	0x64, 0x03, 0x84, 0xfb, 0x50, 0x04, 0xb0, 0xfb, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 
	0xfe, 0xd4, 0x02, 0x58, 0x01, 0xf4, 0x00, 0x09, 0x00, 0x2b, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xba, 0x00, 0x03, 0x00, 0x04, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0xba, 0x00, 0x07, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x07, 0x10, 0x30, 0x31, 0x01, 0x23, 0x11, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x01, 
	0x2c, 0x64, 0x01, 0x90, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd4, 0xfe, 0xd4, 0x03, 0x20, 0x64, 0x64, 
	0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x64, 0xfe, 0xd4, 0x02, 0x58, 0x01, 0x90, 0x00, 0x09, 
	0x00, 0x43, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 
	0x01, 0xd0, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 
	0x06, 0xdc, 0xb8, 0x00, 0x07, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 
	0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 
	0x00, 0x08, 0xd0, 0x30, 0x31, 0x13, 0x23, 0x11, 0x21, 0x15, 0x23, 0x11, 0x23, 0x11, 0x23, 0xc8, 
	0x64, 0x01, 0xf4, 0xc8, 0x64, 0x64, 0xfe, 0xd4, 0x02, 0xbc, 0x64, 0xfd, 0xa8, 0x02, 0x58, 0x00, 
	0x00, 0x02, 0x00, 0x64, 0xfe, 0xd4, 0x02, 0x58, 0x01, 0xf4, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x43, 
	0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 0x00, 0xdc, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x06, 0xdc, 
	0x00, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 
	0x10, 0x30, 0x31, 0x01, 0x21, 0x15, 0x23, 0x11, 0x2b, 0x02, 0x11, 0x21, 0x15, 0x21, 0x01, 0x2c, 
	0x01, 0x2c, 0xc8, 0x64, 0x64, 0x64, 0x01, 0xf4, 0xfe, 0x70, 0x01, 0x2c, 0x64, 0xfe, 0x0c, 0x03, 
	0x20, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x2c, 0x01, 0xf4, 0x00, 0x09, 
	0x00, 0x33, 0xba, 0x00, 0x05, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 
	0x02, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x02, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 0x00, 0x01, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0x30, 0x31, 0x11, 0x33, 0x35, 0x23, 0x35, 0x21, 0x11, 0x23, 0x11, 0x23, 0xc8, 
	0xc8, 0x01, 0x2c, 0x64, 0xc8, 0x01, 0x2c, 0x64, 0x64, 0xfc, 0xe0, 0x01, 0xf4, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x90, 0x01, 0x90, 0x00, 0x09, 0x00, 0x3f, 0xb8, 0x00, 
	0x0a, 0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 
	0x0a, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x07, 0x2f, 0xb8, 0x00, 0x06, 0xdc, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0x30, 0x31, 0x11, 0x21, 0x11, 
	0x23, 0x11, 0x23, 0x11, 0x23, 0x11, 0x23, 0x01, 0x90, 0x64, 0x64, 0x64, 0x64, 0x01, 0x90, 0xfd, 
	0x44, 0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0x00, 0x00, 0x02, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x90, 
	0x01, 0xf4, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x4b, 0xba, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x08, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x03, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x06, 0xd0, 
	0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xba, 0x00, 0x07, 0x00, 0x0a, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x00, 
	0x10, 0x30, 0x31, 0x11, 0x33, 0x11, 0x23, 0x11, 0x23, 0x11, 0x21, 0x11, 0x23, 0x11, 0x21, 0xc8, 
	0x64, 0x64, 0x01, 0x90, 0x64, 0xfe, 0xd4, 0x01, 0x2c, 0xfd, 0xa8, 0x01, 0xf4, 0x01, 0x2c, 0xfc, 
	0xe0, 0x02, 0xbc, 0x00, 0x00, 0x01, 0x00, 0xc8, 0x00, 0xc8, 0x02, 0x58, 0x03, 0x84, 0x00, 0x09, 
	0x00, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 
	0x05, 0xd0, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xba, 0x00, 0x07, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x07, 0x10, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 
	0x31, 0x13, 0x33, 0x11, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0xc8, 0x64, 0x01, 0x2c, 0xfe, 
	0xd4, 0x01, 0x2c, 0xfe, 0x70, 0x03, 0x84, 0xfe, 0x70, 0x64, 0x64, 0x64, 0x00, 0x01, 0x00, 0x64, 
	0x01, 0x2c, 0x02, 0x58, 0x03, 0x84, 0x00, 0x09, 0x00, 0x3f, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 
	0x0b, 0x2f, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 
	0x01, 0xdc, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x03, 0xdc, 0x00, 0xb8, 
	0x00, 0x00, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x07, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x07, 0x10, 0xb8, 0x00, 0x02, 0xd0, 0x30, 0x31, 0x13, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 
	0x33, 0x15, 0x21, 0x64, 0x64, 0x64, 0x64, 0xc8, 0xfe, 0x0c, 0x03, 0x84, 0xfe, 0x0c, 0x01, 0xf4, 
	0xfe, 0x0c, 0x64, 0x00, 0x00, 0x02, 0x00, 0x64, 0x00, 0xc8, 0x02, 0x58, 0x03, 0x84, 0x00, 0x05, 
	0x00, 0x0b, 0x00, 0x43, 0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x01, 0xdc, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x06, 0x2f, 
	0xb8, 0x00, 0x07, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x09, 
	0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x03, 0x00, 0x04, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x03, 0x10, 0x30, 0x31, 0x01, 0x33, 0x11, 0x33, 0x15, 0x21, 0x03, 0x33, 0x11, 
	0x21, 0x15, 0x21, 0x01, 0x2c, 0x64, 0xc8, 0xfe, 0xd4, 0xc8, 0x64, 0x01, 0x90, 0xfe, 0x0c, 0x03, 
	0x84, 0xfe, 0x70, 0x64, 0x01, 0xf4, 0xfd, 0xa8, 0x64, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0xc8, 0x01, 0x2c, 0x03, 0x84, 0x00, 0x09, 0x00, 0x33, 0xba, 0x00, 0x08, 0x00, 0x01, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0x00, 0xb8, 
	0x00, 0x06, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 
	0x00, 0x05, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0x30, 0x31, 0x11, 0x33, 0x35, 
	0x23, 0x35, 0x33, 0x11, 0x33, 0x11, 0x21, 0xc8, 0xc8, 0xc8, 0x64, 0xfe, 0xd4, 0x01, 0x2c, 0x64, 
	0x64, 0x01, 0x90, 0xfd, 0x44, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x90, 
	0x03, 0x84, 0x00, 0x09, 0x00, 0x3b, 0xb8, 0x00, 0x0a, 0x2f, 0xb8, 0x00, 0x0b, 0x2f, 0xb8, 0x00, 
	0x01, 0xdc, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 
	0x05, 0x2f, 0xb8, 0x00, 0x08, 0xdc, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 
	0x00, 0x09, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 
	0x31, 0x01, 0x33, 0x11, 0x21, 0x35, 0x33, 0x11, 0x33, 0x11, 0x33, 0x01, 0x2c, 0x64, 0xfe, 0x70, 
	0x64, 0x64, 0x64, 0x03, 0x84, 0xfd, 0xa8, 0x64, 0x01, 0xf4, 0xfe, 0x0c, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0xc8, 0x01, 0x90, 0x03, 0x84, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x4b, 0xba, 0x00, 0x04, 0x00, 
	0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x0a, 0x00, 0x07, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x05, 0x10, 
	0xb8, 0x00, 0x06, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xba, 0x00, 0x07, 
	0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x01, 0x10, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x23, 0x15, 0x21, 0x11, 
	0x33, 0x11, 0x21, 0x64, 0x64, 0xc8, 0x01, 0x2c, 0x64, 0xfe, 0x70, 0x01, 0xf4, 0x01, 0x90, 0xfe, 
	0x0c, 0x64, 0x02, 0x58, 0xfd, 0x44, 0x00, 0x00, 0x00, 0x01, 0x00, 0xc8, 0xfe, 0xd4, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x0b, 0x00, 0x37, 0xba, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x03, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 
	0x00, 0x00, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 
	0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x01, 0x23, 0x11, 
	0x33, 0x11, 0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x01, 0x2c, 0x64, 0x64, 0x01, 0x2c, 0xfe, 
	0xd4, 0x01, 0x2c, 0xfe, 0xd4, 0xfe, 0xd4, 0x04, 0xb0, 0xfe, 0x70, 0x64, 0x64, 0x64, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x64, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x4b, 
	0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x00, 0xd0, 
	0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x04, 0xdc, 
	0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0x00, 0xb8, 0x00, 0x00, 
	0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x04, 0x2f, 0xba, 0x00, 0x09, 
	0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0x30, 0x31, 0x13, 0x33, 0x11, 0x23, 0x21, 
	0x23, 0x11, 0x33, 0x11, 0x33, 0x15, 0x23, 0x64, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x64, 0xc8, 0xc8, 
	0x03, 0x84, 0xfb, 0x50, 0x04, 0xb0, 0xfe, 0x0c, 0x64, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x64, 
	0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x03, 0x00, 0x07, 0x00, 0x0d, 0x00, 0x11, 0x00, 0x67, 
	0xb8, 0x00, 0x12, 0x2f, 0xb8, 0x00, 0x13, 0x2f, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x03, 0xdc, 
	0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x05, 0x10, 
	0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0xb8, 0x00, 0x0e, 0x2f, 
	0xb8, 0x00, 0x0f, 0xdc, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x10, 0x2f, 0xb8, 0x00, 0x08, 
	0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 
	0x10, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x02, 
	0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x01, 0x21, 0x15, 0x21, 0x31, 0x33, 0x11, 0x23, 0x11, 
	0x33, 0x11, 0x33, 0x15, 0x21, 0x03, 0x33, 0x11, 0x23, 0x01, 0x2c, 0x01, 0x2c, 0xfe, 0xd4, 0x64, 
	0x64, 0x64, 0xc8, 0xfe, 0xd4, 0xc8, 0x64, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0x0c, 0x04, 0xb0, 0xfe, 
	0x70, 0x64, 0x01, 0xf4, 0xfb, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x2c, 
	0x03, 0x84, 0x00, 0x0b, 0x00, 0x3f, 0xba, 0x00, 0x07, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x07, 0x10, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x01, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 
	0x09, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x02, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0x30, 0x31, 0x11, 0x33, 0x35, 0x23, 0x35, 0x33, 0x11, 0x33, 0x11, 0x23, 0x11, 
	0x23, 0xc8, 0xc8, 0xc8, 0x64, 0x64, 0xc8, 0x01, 0x2c, 0x64, 0x64, 0x01, 0x90, 0xfb, 0x50, 0x01, 
	0xf4, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xfe, 0xd4, 0x01, 0x90, 0x03, 0x84, 0x00, 0x03, 
	0x00, 0x0b, 0x00, 0x43, 0xba, 0x00, 0x07, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 
	0xba, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x07, 0x10, 
	0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x08, 
	0x2f, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x05, 0x10, 0x30, 0x31, 0x01, 0x33, 0x11, 0x23, 0x01, 0x33, 0x11, 0x33, 0x11, 
	0x23, 0x11, 0x23, 0x01, 0x2c, 0x64, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0x64, 0x64, 0x03, 0x84, 0xfb, 
	0x50, 0x02, 0xbc, 0x01, 0xf4, 0xfb, 0x50, 0x02, 0x58, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0xfe, 0xd4, 0x01, 0x90, 0x03, 0x84, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x63, 0xba, 0x00, 
	0x04, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x0c, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 
	0x05, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0xb8, 
	0x00, 0x02, 0x2f, 0xb8, 0x00, 0x0c, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0xba, 0x00, 0x06, 0x00, 0x0b, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x06, 0x10, 0x30, 
	0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x23, 0x15, 0x33, 0x11, 0x23, 0x11, 0x23, 0x01, 0x33, 0x11, 
	0x23, 0x64, 0x64, 0xc8, 0xc8, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x64, 0x01, 0xf4, 0x01, 0x90, 0xfe, 
	0x0c, 0x64, 0xfd, 0xa8, 0x01, 0xf4, 0x02, 0xbc, 0xfb, 0x50, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x01, 0xf4, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x33, 0xba, 0x00, 0x08, 0x00, 
	0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x08, 0x10, 0x00, 0xb8, 0x00, 0x08, 0x2f, 0xba, 0x00, 0x01, 
	0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0x30, 0x31, 0x11, 
	0x21, 0x15, 0x21, 0x15, 0x21, 0x15, 0x21, 0x11, 0x23, 0x11, 0x23, 0x02, 0x58, 0xfd, 0xa8, 0x02, 
	0x58, 0xfe, 0xd4, 0x64, 0xc8, 0x01, 0xf4, 0x64, 0x64, 0x64, 0xfe, 0x0c, 0x01, 0xf4, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x01, 0x90, 0x00, 0x0b, 0x00, 0x47, 0xb8, 0x00, 
	0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x09, 0xdc, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 
	0x0c, 0x10, 0xb8, 0x00, 0x03, 0xd0, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0x00, 0xb8, 
	0x00, 0x02, 0x2f, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 0x00, 0x06, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x06, 0x10, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x08, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 0x21, 0x15, 0x23, 0x11, 
	0x23, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x02, 0x58, 0xc8, 0x64, 0x01, 0x2c, 0xfd, 0xa8, 0x02, 0x58, 
	0x64, 0x64, 0xfd, 0xa8, 0x00, 0x03, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x01, 0xf4, 0x00, 0x03, 
	0x00, 0x09, 0x00, 0x0f, 0x00, 0x57, 0xba, 0x00, 0x05, 0x00, 0x04, 0x00, 0x03, 0x2b, 0xb8, 0x00, 
	0x05, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 
	0x04, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x07, 0xdc, 0x00, 0xb8, 
	0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x01, 0x10, 0xba, 0x00, 0x04, 0x00, 0x09, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 
	0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0x30, 0x31, 0x11, 0x21, 0x15, 
	0x21, 0x15, 0x33, 0x11, 0x23, 0x11, 0x23, 0x25, 0x21, 0x15, 0x23, 0x11, 0x23, 0x02, 0x58, 0xfd, 
	0xa8, 0xc8, 0x64, 0x64, 0x01, 0x2c, 0x01, 0x2c, 0xc8, 0x64, 0x01, 0xf4, 0x64, 0x64, 0xfd, 0xa8, 
	0x01, 0xf4, 0x64, 0x64, 0xfe, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc8, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x2f, 0xba, 0x00, 0x08, 0x00, 0x05, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x08, 0x10, 0x00, 0xb8, 0x00, 0x06, 0x2f, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 
	0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x11, 0x21, 0x15, 0x21, 0x11, 0x33, 0x11, 0x33, 0x11, 
	0x21, 0x15, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0xc8, 0x64, 0x01, 0x2c, 0xfd, 0xa8, 0x01, 0x2c, 0x64, 
	0x01, 0x2c, 0x01, 0x90, 0xfe, 0x70, 0x64, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x0b, 0x00, 0x47, 0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 
	0x0c, 0x10, 0xb8, 0x00, 0x01, 0xd0, 0xb8, 0x00, 0x01, 0x2f, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 
	0x0d, 0x10, 0xb8, 0x00, 0x08, 0xdc, 0xb8, 0x00, 0x05, 0xdc, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 
	0x00, 0x06, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 
	0x00, 0x00, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x11, 
	0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x15, 0x21, 0x64, 0x64, 0x64, 0x64, 0xc8, 0xfd, 0xa8, 
	0x01, 0x90, 0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0xfe, 0x0c, 0x64, 0x00, 0x00, 0x03, 0x00, 0x00, 
	0x00, 0xc8, 0x02, 0x58, 0x03, 0x84, 0x00, 0x05, 0x00, 0x09, 0x00, 0x0f, 0x00, 0x57, 0xba, 0x00, 
	0x04, 0x00, 0x05, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xba, 0x00, 0x0b, 0x00, 0x0a, 0x00, 
	0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 
	0x05, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 0x00, 0x0a, 0x2f, 0xba, 
	0x00, 0x07, 0x00, 0x08, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x01, 0x00, 0x04, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 
	0x00, 0x0e, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x23, 0x15, 0x21, 0x15, 0x21, 0x01, 
	0x33, 0x11, 0x33, 0x15, 0x21, 0x64, 0x64, 0xc8, 0x02, 0x58, 0xfd, 0xa8, 0x01, 0x2c, 0x64, 0xc8, 
	0xfe, 0xd4, 0x01, 0xf4, 0x01, 0x90, 0xfe, 0x0c, 0x64, 0x64, 0x02, 0xbc, 0xfe, 0x70, 0x64, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x13, 0x00, 0x6b, 0xba, 0x00, 
	0x04, 0x00, 0x01, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 
	0x04, 0x10, 0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0xb8, 0x00, 
	0x01, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0x00, 0xb8, 0x00, 0x0c, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0xba, 
	0x00, 0x05, 0x00, 0x06, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 0x00, 0x09, 0x00, 0x0a, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x00, 0xd0, 0xb8, 
	0x00, 0x0a, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 
	0x00, 0x06, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0x30, 0x31, 0x11, 0x33, 0x11, 0x33, 0x11, 0x21, 0x15, 
	0x21, 0x15, 0x21, 0x15, 0x21, 0x11, 0x23, 0x11, 0x23, 0x35, 0x33, 0x35, 0x23, 0xc8, 0x64, 0x01, 
	0x2c, 0xfe, 0xd4, 0x01, 0x2c, 0xfe, 0xd4, 0x64, 0xc8, 0xc8, 0xc8, 0x01, 0xf4, 0x01, 0x90, 0xfe, 
	0x70, 0x64, 0x64, 0x64, 0xfe, 0x0c, 0x01, 0xf4, 0x64, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x13, 0x00, 0x7f, 0xb8, 0x00, 0x14, 0x2f, 0xb8, 0x00, 
	0x15, 0x2f, 0xb8, 0x00, 0x11, 0xdc, 0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 
	0x03, 0xd0, 0xb8, 0x00, 0x03, 0x2f, 0xb8, 0x00, 0x02, 0xdc, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 
	0x07, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x09, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x0b, 0xd0, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x0d, 0xd0, 0x00, 0xb8, 0x00, 0x02, 0x2f, 0xb8, 
	0x00, 0x12, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x0c, 0x2f, 0xba, 0x00, 0x0b, 0x00, 0x00, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x04, 0xd0, 0xb8, 
	0x00, 0x0b, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x0e, 0xd0, 0xb8, 
	0x00, 0x00, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x11, 0x23, 0x11, 0x23, 0x35, 
	0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x11, 0x33, 0x15, 0x23, 0x11, 0x23, 0x01, 0x2c, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0xc8, 0xc8, 0x64, 0x01, 0x2c, 0xfd, 0xa8, 0x02, 0x58, 0x64, 
	0x01, 0xf4, 0xfe, 0x0c, 0x01, 0xf4, 0xfe, 0x0c, 0x64, 0xfd, 0xa8, 0x00, 0x00, 0x04, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x11, 0x00, 0x17, 0x00, 0x93, 
	0xba, 0x00, 0x10, 0x00, 0x11, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x10, 0x10, 0xba, 0x00, 0x03, 0x00, 
	0x00, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x06, 0xd0, 
	0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x07, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x0d, 0xdc, 
	0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x13, 0xd0, 
	0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0x00, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x14, 
	0x2f, 0xb8, 0x00, 0x06, 0x2f, 0xb8, 0x00, 0x0e, 0x2f, 0xba, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x09, 0x10, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 
	0x10, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x0c, 0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x10, 
	0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x12, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x16, 
	0xd0, 0x30, 0x31, 0x01, 0x21, 0x15, 0x23, 0x11, 0x23, 0x11, 0x33, 0x11, 0x33, 0x15, 0x21, 0x25, 
	0x33, 0x11, 0x33, 0x11, 0x23, 0x15, 0x33, 0x11, 0x23, 0x11, 0x23, 0x01, 0x2c, 0x01, 0x2c, 0xc8, 
	0x64, 0x64, 0xc8, 0xfe, 0xd4, 0xfe, 0xd4, 0x64, 0x64, 0xc8, 0xc8, 0x64, 0x64, 0x01, 0x2c, 0x64, 
	0xfe, 0x0c, 0x04, 0xb0, 0xfe, 0x70, 0x64, 0x64, 0x01, 0x90, 0xfe, 0x0c, 0x64, 0xfd, 0xa8, 0x01, 
	0xf4, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x2c, 0x02, 0x58, 0x03, 0x84, 0x00, 0x03, 
	0x00, 0x0b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0x30, 0x31, 0x11, 0x21, 0x11, 
	0x21, 0x02, 0x58, 0xfd, 0xa8, 0x03, 0x84, 0xfd, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x01, 0x2c, 0x00, 0x03, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 
	0x00, 0x02, 0x2f, 0x30, 0x31, 0x11, 0x21, 0x11, 0x21, 0x02, 0x58, 0xfd, 0xa8, 0x01, 0x2c, 0xfd, 
	0xa8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x03, 
	0x00, 0x0b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0x30, 0x31, 0x11, 0x21, 0x11, 
	0x21, 0x02, 0x58, 0xfd, 0xa8, 0x03, 0x84, 0xfb, 0x50, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xd4, 0x01, 0x2c, 0x03, 0x84, 0x00, 0x03, 0x00, 0x0b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 
	0x00, 0x02, 0x2f, 0x30, 0x31, 0x11, 0x21, 0x11, 0x21, 0x01, 0x2c, 0xfe, 0xd4, 0x03, 0x84, 0xfb, 
	0x50, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x2c, 0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x03, 
	0x00, 0x0b, 0x00, 0xb8, 0x00, 0x00, 0x2f, 0xb8, 0x00, 0x02, 0x2f, 0x30, 0x31, 0x01, 0x21, 0x11, 
	0x21, 0x01, 0x2c, 0x01, 0x2c, 0xfe, 0xd4, 0x03, 0x84, 0xfb, 0x50, 0x00, 0x00, 0x12, 0x00, 0x00, 
	0xff, 0x38, 0x01, 0xf4, 0x03, 0x84, 0x00, 0x03, 0x00, 0x07, 0x00, 0x0b, 0x00, 0x0f, 0x00, 0x13, 
	0x00, 0x17, 0x00, 0x1b, 0x00, 0x1f, 0x00, 0x23, 0x00, 0x27, 0x00, 0x2b, 0x00, 0x2f, 0x00, 0x33, 
	0x00, 0x37, 0x00, 0x3b, 0x00, 0x3f, 0x00, 0x43, 0x00, 0x47, 0x02, 0x41, 0xb8, 0x00, 0x48, 0x2f, 
	0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x00, 0xdc, 0x41, 0x03, 0x00, 0xf0, 
	0x00, 0x00, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 0x00, 0x00, 0x00, 0x01, 0x5d, 0x41, 0x03, 
	0x00, 0x50, 0x00, 0x00, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x01, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 
	0x00, 0x04, 0xdc, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 
	0x00, 0x04, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 0x04, 0x00, 0x01, 0x71, 0xb8, 0x00, 
	0x05, 0xdc, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x09, 0xdc, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x0c, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x10, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x14, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x18, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x1c, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x20, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x21, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x24, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x25, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 
	0x28, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x29, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x2c, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x2d, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x30, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x31, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 
	0x34, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x35, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 
	0x38, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x39, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x3c, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x3d, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 
	0x40, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x41, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 
	0x44, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x45, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 
	0x49, 0xdc, 0x00, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 
	0x00, 0x1d, 0x00, 0x1e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1d, 0x10, 0xba, 0x00, 0x05, 0x00, 0x06, 
	0x00, 0x03, 0x2b, 0xb8, 0x00, 0x05, 0x10, 0xba, 0x00, 0x19, 0x00, 0x1a, 0x00, 0x03, 0x2b, 0xb8, 
	0x00, 0x19, 0x10, 0xba, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 
	0x00, 0x11, 0x00, 0x12, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x11, 0x10, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x08, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x11, 0x10, 0xb8, 
	0x00, 0x14, 0xd0, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x16, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 
	0x00, 0x20, 0xd0, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x19, 0x10, 0xb8, 
	0x00, 0x24, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x26, 0xd0, 0xb8, 0x00, 0x19, 0x10, 0xb8, 
	0x00, 0x28, 0xd0, 0xb8, 0x00, 0x1a, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0xb8, 0x00, 0x11, 0x10, 0xb8, 
	0x00, 0x2c, 0xd0, 0xb8, 0x00, 0x12, 0x10, 0xb8, 0x00, 0x2e, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 
	0x00, 0x30, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x32, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 
	0x00, 0x34, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x36, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 
	0x00, 0x38, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x3a, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 
	0x00, 0x3c, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x3e, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 
	0x00, 0x40, 0xd0, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x42, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 
	0x00, 0x44, 0xd0, 0xb8, 0x00, 0x1e, 0x10, 0xb8, 0x00, 0x46, 0xd0, 0x30, 0x31, 0x17, 0x33, 0x15, 
	0x23, 0x13, 0x33, 0x15, 0x23, 0x25, 0x33, 0x15, 0x23, 0x13, 0x33, 0x15, 0x23, 0x13, 0x33, 0x15, 
	0x23, 0x25, 0x33, 0x15, 0x23, 0x13, 0x33, 0x15, 0x23, 0x13, 0x33, 0x15, 0x23, 0x27, 0x33, 0x15, 
	0x23, 0x07, 0x33, 0x15, 0x23, 0x25, 0x33, 0x15, 0x23, 0x07, 0x33, 0x15, 0x23, 0x07, 0x33, 0x15, 
	0x23, 0x25, 0x33, 0x15, 0x23, 0x07, 0x33, 0x15, 0x23, 0x07, 0x33, 0x15, 0x23, 0x25, 0x33, 0x15, 
	0x23, 0x01, 0x33, 0x15, 0x23, 0xc8, 0x64, 0x64, 0xc8, 0x64, 0x64, 0xfe, 0x70, 0x64, 0x64, 0xc8, 
	0x64, 0x64, 0xc8, 0x64, 0x64, 0xfe, 0x70, 0x64, 0x64, 0xc8, 0x64, 0x64, 0xc8, 0x64, 0x64, 0xc8, 
	0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 0x90, 0x64, 0x64, 0xc8, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 
	0x90, 0x64, 0x64, 0xc8, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x01, 0x90, 0x64, 0x64, 0xfe, 0x70, 0x64, 
	0x64, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x01, 0x2c, 0x64, 0x64, 0x64, 
	0x01, 0x2c, 0x64, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x04, 0x4c, 0x64, 0x00, 0x00, 0x08, 0x00, 0x00, 
	0xfe, 0xd4, 0x02, 0x58, 0x03, 0x84, 0x00, 0x07, 0x00, 0x0f, 0x00, 0x1f, 0x00, 0x2f, 0x00, 0x47, 
	0x00, 0x5f, 0x00, 0x77, 0x00, 0x8f, 0x06, 0x43, 0xba, 0x00, 0x08, 0x00, 0x09, 0x00, 0x03, 0x2b, 
	0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x0d, 0xdc, 0xb8, 0x00, 0x10, 0xdc, 0xb8, 0x00, 0x1d, 0xdc, 
	0xb8, 0x00, 0x00, 0xdc, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x01, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x03, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x05, 0xdc, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x0b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x13, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x15, 0xd0, 0xb8, 0x00, 0x08, 0x10, 
	0xb8, 0x00, 0x17, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x19, 0xd0, 0xb8, 0x00, 0x10, 0x10, 
	0xb8, 0x00, 0x1b, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x20, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x21, 0xd0, 0xb8, 0x00, 0x01, 0x10, 
	0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x23, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x25, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x27, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x29, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x2b, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x2d, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x30, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x31, 0xd0, 0xb8, 0x00, 0x01, 0x10, 
	0xb8, 0x00, 0x32, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x33, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x35, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x37, 0xd0, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x39, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x3b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x3d, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x3f, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x41, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x42, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x43, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x45, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x48, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x49, 0xd0, 0xb8, 0x00, 0x01, 0x10, 
	0xb8, 0x00, 0x4a, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x4b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x4d, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x4f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x51, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x53, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x55, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x57, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x59, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x5a, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x5b, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x5d, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x60, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x61, 0xd0, 0xb8, 0x00, 0x01, 0x10, 
	0xb8, 0x00, 0x62, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x63, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x65, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x67, 0xd0, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x69, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x6b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x6d, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x6f, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x71, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x72, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x73, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x75, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x78, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 0xb8, 0x00, 0x79, 0xd0, 0xb8, 0x00, 0x01, 0x10, 
	0xb8, 0x00, 0x7a, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x7b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x7d, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x7f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 
	0xb8, 0x00, 0x81, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x83, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 
	0xb8, 0x00, 0x85, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x87, 0xd0, 0xb8, 0x00, 0x1d, 0x10, 
	0xb8, 0x00, 0x89, 0xd0, 0xb8, 0x00, 0x01, 0x10, 0xb8, 0x00, 0x8a, 0xd0, 0xb8, 0x00, 0x00, 0x10, 
	0xb8, 0x00, 0x8b, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x8d, 0xd0, 0x00, 0xba, 0x00, 0x0d, 
	0x00, 0x0e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0d, 0x10, 0xba, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x03, 0x10, 0xba, 0x00, 0x15, 0x00, 0x0a, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x15, 
	0x10, 0xba, 0x00, 0x07, 0x00, 0x20, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x07, 0x10, 0xba, 0x00, 0x2d, 
	0x00, 0x2e, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x2d, 0x10, 0xba, 0x00, 0x51, 0x00, 0x16, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x51, 0x10, 0xba, 0x00, 0x3b, 0x00, 0x38, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x3b, 
	0x10, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x05, 0xd0, 0xb8, 0x00, 0x06, 0xdc, 0xb8, 0x00, 0x0d, 
	0x10, 0xb8, 0x00, 0x08, 0xd0, 0xb8, 0x00, 0x0b, 0xdc, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x10, 
	0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x11, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x12, 
	0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x13, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x17, 
	0xdc, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x18, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x19, 
	0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x1a, 0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x1b, 
	0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x1c, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x1d, 
	0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x1e, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x22, 
	0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x23, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x24, 
	0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x25, 0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x26, 
	0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x28, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x29, 
	0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x2b, 
	0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x2c, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x30, 
	0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x31, 0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x32, 
	0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x33, 0xd0, 0xb8, 0x00, 0x51, 0x10, 0xb8, 0x00, 0x34, 
	0xd0, 0xb8, 0x00, 0x3f, 0xdc, 0xb8, 0x00, 0x36, 0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x3a, 
	0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x3d, 0xd0, 0xb8, 0x00, 0x51, 0x10, 0xb8, 0x00, 0x40, 
	0xd0, 0xb8, 0x00, 0x34, 0x10, 0xb8, 0x00, 0x41, 0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x42, 
	0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x43, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x44, 
	0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x45, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x46, 
	0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x47, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x48, 
	0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x49, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x4a, 
	0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x4b, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x4c, 
	0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x4d, 0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x4e, 
	0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x4f, 0xd0, 0xb8, 0x00, 0x3f, 0x10, 0xb8, 0x00, 0x52, 
	0xd0, 0xb8, 0x00, 0x36, 0x10, 0xb8, 0x00, 0x53, 0xd0, 0xb8, 0x00, 0x51, 0x10, 0xb8, 0x00, 0x54, 
	0xd0, 0xb8, 0x00, 0x34, 0x10, 0xb8, 0x00, 0x55, 0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x56, 
	0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x57, 0xd0, 0xb8, 0x00, 0x15, 0x10, 0xb8, 0x00, 0x58, 
	0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x59, 0xd0, 0xb8, 0x00, 0x0b, 0x10, 0xb8, 0x00, 0x5a, 
	0xd0, 0xb8, 0x00, 0x0a, 0x10, 0xb8, 0x00, 0x5b, 0xd0, 0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x5c, 
	0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x5d, 0xd0, 0xb8, 0x00, 0x0e, 0x10, 0xb8, 0x00, 0x5e, 
	0xd0, 0xb8, 0x00, 0x51, 0x10, 0xb8, 0x00, 0x60, 0xd0, 0xb8, 0x00, 0x34, 0x10, 0xb8, 0x00, 0x61, 
	0xd0, 0xb8, 0x00, 0x3f, 0x10, 0xb8, 0x00, 0x62, 0xd0, 0xb8, 0x00, 0x36, 0x10, 0xb8, 0x00, 0x63, 
	0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x64, 0xd0, 0xb8, 0x00, 0x3d, 0x10, 0xb8, 0x00, 0x65, 
	0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x66, 0xd0, 0xb8, 0x00, 0x3b, 0x10, 0xb8, 0x00, 0x67, 
	0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x68, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 0x69, 
	0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x6a, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x6b, 
	0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x6c, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 0x6d, 
	0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x6e, 0xd0, 0xb8, 0x00, 0x3b, 0x10, 0xb8, 0x00, 0x6f, 
	0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x70, 0xd0, 0xb8, 0x00, 0x3d, 0x10, 0xb8, 0x00, 0x71, 
	0xd0, 0xb8, 0x00, 0x3f, 0x10, 0xb8, 0x00, 0x72, 0xd0, 0xb8, 0x00, 0x36, 0x10, 0xb8, 0x00, 0x73, 
	0xd0, 0xb8, 0x00, 0x51, 0x10, 0xb8, 0x00, 0x74, 0xd0, 0xb8, 0x00, 0x34, 0x10, 0xb8, 0x00, 0x75, 
	0xd0, 0xb8, 0x00, 0x17, 0x10, 0xb8, 0x00, 0x76, 0xd0, 0xb8, 0x00, 0x16, 0x10, 0xb8, 0x00, 0x77, 
	0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x78, 0xd0, 0xb8, 0x00, 0x3d, 0x10, 0xb8, 0x00, 0x79, 
	0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x7a, 0xd0, 0xb8, 0x00, 0x3b, 0x10, 0xb8, 0x00, 0x7b, 
	0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x7c, 0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 0x7d, 
	0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x7e, 0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x7f, 
	0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x80, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x81, 
	0xd0, 0xb8, 0x00, 0x03, 0x10, 0xb8, 0x00, 0x82, 0xd0, 0xb8, 0x00, 0x00, 0x10, 0xb8, 0x00, 0x84, 
	0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x85, 0xd0, 0xb8, 0x00, 0x06, 0x10, 0xb8, 0x00, 0x86, 
	0xd0, 0xb8, 0x00, 0x07, 0x10, 0xb8, 0x00, 0x87, 0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x88, 
	0xd0, 0xb8, 0x00, 0x2d, 0x10, 0xb8, 0x00, 0x89, 0xd0, 0xb8, 0x00, 0x2e, 0x10, 0xb8, 0x00, 0x8a, 
	0xd0, 0xb8, 0x00, 0x3b, 0x10, 0xb8, 0x00, 0x8b, 0xd0, 0xb8, 0x00, 0x38, 0x10, 0xb8, 0x00, 0x8c, 
	0xd0, 0xb8, 0x00, 0x3d, 0x10, 0xb8, 0x00, 0x8d, 0xd0, 0xb8, 0x00, 0x3f, 0x10, 0xb8, 0x00, 0x8e, 
	0xd0, 0xb8, 0x00, 0x36, 0x10, 0xb8, 0x00, 0x8f, 0xd0, 0x30, 0x31, 0x01, 0x23, 0x35, 0x33, 0x15, 
	0x33, 0x15, 0x23, 0x01, 0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x23, 0x37, 0x23, 0x35, 0x23, 0x35, 
	0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x13, 0x23, 0x35, 0x23, 0x35, 
	0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x11, 0x23, 0x35, 0x23, 0x35, 
	0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 
	0x33, 0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 
	0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x11, 0x23, 0x35, 0x23, 0x35, 
	0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 
	0x33, 0x15, 0x23, 0x11, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x23, 0x35, 0x33, 0x15, 
	0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x33, 0x15, 0x23, 0x01, 0xf4, 0x64, 0x64, 0x64, 
	0x64, 0xfe, 0x70, 0x64, 0x64, 0x64, 0x64, 0xc8, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0xc8, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x03, 0x20, 0x64, 0x64, 0x64, 0xfc, 0x7c, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x03, 0x84, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0xfe, 0x0c, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x01, 0xf4, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x01, 0x2c, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x00, 0x00, 0x0b, 0x00, 0x00, 0xfe, 0xd4, 0x02, 0x58, 
	0x03, 0x84, 0x00, 0x21, 0x00, 0x25, 0x00, 0x29, 0x00, 0x2d, 0x00, 0x31, 0x00, 0x35, 0x00, 0x39, 
	0x00, 0x3d, 0x00, 0x41, 0x00, 0x45, 0x00, 0x49, 0x02, 0x0d, 0xb8, 0x00, 0x4a, 0x2f, 0xb8, 0x00, 
	0x0d, 0xd0, 0xb8, 0x00, 0x0d, 0x2f, 0xb8, 0x00, 0x09, 0xdc, 0x41, 0x03, 0x00, 0x50, 0x00, 0x09, 
	0x00, 0x01, 0x71, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x09, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x90, 
	0x00, 0x09, 0x00, 0x01, 0x5d, 0xb8, 0x00, 0x05, 0xdc, 0x41, 0x03, 0x00, 0x90, 0x00, 0x05, 0x00, 
	0x01, 0x5d, 0x41, 0x03, 0x00, 0xf0, 0x00, 0x05, 0x00, 0x01, 0x5d, 0x41, 0x03, 0x00, 0x50, 0x00, 
	0x05, 0x00, 0x01, 0x71, 0xb8, 0x00, 0x04, 0xdc, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x08, 0xdc, 
	0xb8, 0x00, 0x0d, 0x10, 0xb8, 0x00, 0x0c, 0xdc, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x22, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x23, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x26, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x27, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x2b, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x2e, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x2f, 0xd0, 0xb8, 0x00, 0x09, 0x10, 0xb8, 0x00, 0x32, 0xd0, 
	0xb8, 0x00, 0x0c, 0x10, 0xb8, 0x00, 0x33, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x36, 0xd0, 
	0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x38, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x3a, 0xd0, 
	0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x3b, 0xd0, 0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x3e, 0xd0, 
	0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x40, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x42, 0xd0, 
	0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x43, 0xd0, 0xb8, 0x00, 0x05, 0x10, 0xb8, 0x00, 0x46, 0xd0, 
	0xb8, 0x00, 0x08, 0x10, 0xb8, 0x00, 0x47, 0xd0, 0xb8, 0x00, 0x04, 0x10, 0xb8, 0x00, 0x4b, 0xdc, 
	0x00, 0xb8, 0x00, 0x04, 0x2f, 0xb8, 0x00, 0x08, 0x2f, 0xb8, 0x00, 0x0c, 0x2f, 0xba, 0x00, 0x0f, 
	0x00, 0x10, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x0f, 0x10, 0xba, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x01, 0x10, 0xba, 0x00, 0x13, 0x00, 0x14, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x13, 
	0x10, 0xba, 0x00, 0x1f, 0x00, 0x20, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x1f, 0x10, 0xba, 0x00, 0x17, 
	0x00, 0x18, 0x00, 0x03, 0x2b, 0xb8, 0x00, 0x17, 0x10, 0xba, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x03, 
	0x2b, 0xb8, 0x00, 0x1b, 0x10, 0xb8, 0x00, 0x02, 0x10, 0xb8, 0x00, 0x06, 0xd0, 0xb8, 0x00, 0x02, 
	0x10, 0xb8, 0x00, 0x0a, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x22, 0xd0, 0xb8, 0x00, 0x13, 
	0x10, 0xb8, 0x00, 0x24, 0xd0, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x26, 0xd0, 0xb8, 0x00, 0x1b, 
	0x10, 0xb8, 0x00, 0x28, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x2a, 0xd0, 0xb8, 0x00, 0x17, 
	0x10, 0xb8, 0x00, 0x2c, 0xd0, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 0x2e, 0xd0, 0xb8, 0x00, 0x1f, 
	0x10, 0xb8, 0x00, 0x30, 0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x32, 0xd0, 0xb8, 0x00, 0x01, 
	0x10, 0xb8, 0x00, 0x34, 0xd0, 0xb8, 0x00, 0x18, 0x10, 0xb8, 0x00, 0x36, 0xd0, 0xb8, 0x00, 0x1b, 
	0x10, 0xb8, 0x00, 0x37, 0xd0, 0xb8, 0x00, 0x14, 0x10, 0xb8, 0x00, 0x3a, 0xd0, 0xb8, 0x00, 0x17, 
	0x10, 0xb8, 0x00, 0x3c, 0xd0, 0xb8, 0x00, 0x10, 0x10, 0xb8, 0x00, 0x3e, 0xd0, 0xb8, 0x00, 0x13, 
	0x10, 0xb8, 0x00, 0x3f, 0xd0, 0xb8, 0x00, 0x20, 0x10, 0xb8, 0x00, 0x42, 0xd0, 0xb8, 0x00, 0x01, 
	0x10, 0xb8, 0x00, 0x44, 0xd0, 0xb8, 0x00, 0x1c, 0x10, 0xb8, 0x00, 0x46, 0xd0, 0xb8, 0x00, 0x1f, 
	0x10, 0xb8, 0x00, 0x48, 0xd0, 0x30, 0x31, 0x05, 0x33, 0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x15, 
	0x23, 0x35, 0x23, 0x15, 0x23, 0x11, 0x21, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 
	0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x01, 0x23, 0x15, 0x33, 0x11, 0x23, 0x15, 
	0x33, 0x11, 0x23, 0x15, 0x33, 0x11, 0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x13, 0x15, 0x33, 
	0x3d, 0x01, 0x23, 0x15, 0x33, 0x03, 0x15, 0x33, 0x35, 0x11, 0x23, 0x15, 0x33, 0x11, 0x23, 0x15, 
	0x33, 0x01, 0xf4, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x02, 0x58, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 
	0x64, 0x64, 0x04, 0xb0, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x03, 0x20, 0x64, 
	0xfe, 0xd4, 0x64, 0x01, 0x2c, 0x64, 0xfe, 0xd4, 0x64, 0x64, 0x64, 0x01, 0xf4, 0x64, 0x64, 0xc8, 
	0x64, 0x01, 0x2c, 0x64, 0x64, 0xfc, 0xe0, 0x64, 0x01, 0x2c, 0x64, 0x00, 0x00, 0x02, 0x00, 0x55, 
	0xfe, 0xf2, 0x02, 0x6a, 0x03, 0xa7, 0x00, 0x18, 0x00, 0x1c, 0x00, 0x00, 0x13, 0x23, 0x35, 0x34, 
	0x37, 0x36, 0x3f, 0x01, 0x3e, 0x01, 0x3d, 0x01, 0x23, 0x37, 0x17, 0x23, 0x15, 0x14, 0x06, 0x0f, 
	0x01, 0x06, 0x07, 0x06, 0x15, 0x11, 0x07, 0x11, 0x33, 0xf1, 0x9c, 0x2d, 0x1f, 0x40, 0x56, 0x33, 
	0x2c, 0x76, 0xa5, 0xa5, 0x76, 0x3d, 0x3c, 0x2b, 0x35, 0x13, 0x17, 0x9c, 0x9c, 0xfe, 0xf2, 0xfb, 
	0x5d, 0x3b, 0x29, 0x27, 0x33, 0x1f, 0x53, 0x43, 0xac, 0xb2, 0xb2, 0xc9, 0x64, 0x6a, 0x25, 0x1a, 
	0x20, 0x20, 0x25, 0x41, 0x01, 0x6d, 0x5c, 0x02, 0xa9, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x6e, 
	0xff, 0x62, 0x01, 0xea, 0x03, 0x35, 0x00, 0x05, 0x00, 0x11, 0x00, 0x00, 0x01, 0x15, 0x21, 0x11, 
	0x33, 0x11, 0x17, 0x33, 0x11, 0x23, 0x03, 0x17, 0x15, 0x23, 0x11, 0x33, 0x13, 0x27, 0x01, 0x8c, 
	0xfe, 0xe2, 0x58, 0xca, 0x5a, 0x5f, 0x8b, 0x0b, 0x59, 0x5e, 0x8c, 0x0c, 0x01, 0xa5, 0x45, 0x01, 
	0xd5, 0xfe, 0x70, 0x6f, 0xfe, 0x2c, 0x01, 0x30, 0xcb, 0x65, 0x01, 0xd4, 0xfe, 0xcf, 0xdf, 0x00, 
	0x00, 0x03, 0x00, 0x46, 0xff, 0xb0, 0x02, 0x12, 0x02, 0xf1, 0x00, 0x14, 0x00, 0x1d, 0x00, 0x2a, 
	0x00, 0x00, 0x17, 0x22, 0x35, 0x11, 0x34, 0x17, 0x35, 0x34, 0x37, 0x36, 0x33, 0x32, 0x17, 0x16, 
	0x07, 0x15, 0x32, 0x17, 0x11, 0x14, 0x23, 0x03, 0x22, 0x06, 0x1d, 0x01, 0x33, 0x35, 0x34, 0x26, 
	0x03, 0x35, 0x36, 0x35, 0x34, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x17, 0x15, 0x96, 0x50, 0x45, 
	0x2f, 0x2e, 0x44, 0x44, 0x2e, 0x30, 0x01, 0x44, 0x01, 0x50, 0x96, 0x26, 0x2e, 0xa8, 0x2e, 0x06, 
	0x26, 0x29, 0x1d, 0x1d, 0x29, 0x26, 0x50, 0x49, 0x01, 0x67, 0x4f, 0x01, 0x9f, 0x47, 0x30, 0x2d, 
	0x2d, 0x2f, 0x48, 0x9f, 0x4e, 0xfe, 0x99, 0x49, 0x02, 0xfe, 0x34, 0x2d, 0x9f, 0x9f, 0x2c, 0x35, 
	0xfd, 0x7d, 0xa8, 0x12, 0x27, 0x1b, 0x26, 0x26, 0x1b, 0x28, 0x11, 0xa8, 0x00, 0x01, 0x00, 0x00, 
	0xfe, 0xed, 0x02, 0x58, 0x03, 0xa7, 0x00, 0x02, 0x00, 0x00, 0x11, 0x09, 0x01, 0x02, 0x58, 0xfd, 
	0xa8, 0x03, 0xa7, 0xfd, 0xa3, 0xfd, 0xa3, 0x00, 0x00, 0x01, 0xff, 0xe0, 0xff, 0x03, 0x02, 0x58, 
	0x03, 0x90, 0x00, 0x05, 0x00, 0x00, 0x03, 0x37, 0x09, 0x01, 0x27, 0x01, 0x20, 0x36, 0x02, 0x42, 
	0xfd, 0xbe, 0x36, 0x02, 0x0f, 0x03, 0x5f, 0x31, 0xfd, 0xba, 0xfd, 0xb9, 0x32, 0x02, 0x15, 0x00, 
	0x00, 0x01, 0x00, 0x00, 0xfe, 0xed, 0x02, 0x58, 0x03, 0xa7, 0x00, 0x02, 0x00, 0x00, 0x09, 0x02, 
	0x02, 0x58, 0xfd, 0xa8, 0x02, 0x58, 0xfe, 0xed, 0x02, 0x5d, 0x02, 0x5d, 0x00, 0x01, 0x00, 0x00, 
	0xff, 0x03, 0x02, 0x78, 0x03, 0x90, 0x00, 0x05, 0x00, 0x00, 0x13, 0x01, 0x07, 0x09, 0x01, 0x17, 
	0x69, 0x02, 0x0f, 0x36, 0xfd, 0xbe, 0x02, 0x42, 0x36, 0x01, 0x4a, 0xfd, 0xeb, 0x32, 0x02, 0x47, 
	0x02, 0x46, 0x31, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0xde, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 
	0x00, 0x2f, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x07, 0x00, 0x55, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x75, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x00, 0x15, 0x00, 0xad, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x0b, 
	0x00, 0xdb, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x13, 0x01, 0x0f, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x15, 0x01, 0x4f, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x12, 0x00, 0x15, 0x01, 0x91, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x01, 0x00, 0x2a, 0x00, 0x03, 0x00, 0x03, 
	0x00, 0x01, 0x04, 0x09, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x45, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 
	0x00, 0x03, 0x00, 0x16, 0x00, 0x5d, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x04, 0x00, 0x2a, 
	0x00, 0x81, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x05, 0x00, 0x16, 0x00, 0xc3, 0x00, 0x03, 
	0x00, 0x01, 0x04, 0x09, 0x00, 0x06, 0x00, 0x26, 0x00, 0xe7, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 
	0x00, 0x10, 0x00, 0x2a, 0x01, 0x23, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x12, 0x00, 0x2a, 
	0x01, 0x65, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 0x6f, 0x00, 
	0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x20, 0x00, 0x50, 0x00, 
	0x6f, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x65, 0x00, 
	0x00, 0x50, 0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x50, 0x6f, 0x77, 
	0x65, 0x72, 0x6c, 0x69, 0x6e, 0x65, 0x00, 0x00, 0x52, 0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 
	0x6c, 0x00, 0x61, 0x00, 0x72, 0x00, 0x00, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x00, 0x00, 
	0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 
	0x32, 0x00, 0x2e, 0x00, 0x33, 0x00, 0x00, 0x50, 0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x32, 
	0x2e, 0x33, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x6e, 0x00, 
	0x74, 0x00, 0x20, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x20, 0x00, 0x50, 0x00, 0x6f, 0x00, 
	0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x65, 0x00, 0x00, 0x50, 
	0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x50, 0x6f, 0x77, 0x65, 0x72, 
	0x6c, 0x69, 0x6e, 0x65, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 0x6f, 0x00, 
	0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x32, 0x00, 0x2e, 0x00, 0x33, 0x00, 0x00, 0x50, 0x72, 0x6f, 
	0x46, 0x6f, 0x6e, 0x74, 0x20, 0x32, 0x2e, 0x33, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 
	0x46, 0x00, 0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x50, 0x00, 
	0x6f, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x65, 0x00, 
	0x00, 0x50, 0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x46, 0x6f, 0x72, 0x50, 0x6f, 0x77, 0x65, 0x72, 
	0x6c, 0x69, 0x6e, 0x65, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 0x6f, 0x00, 
	0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x20, 0x00, 0x50, 0x00, 
	0x6f, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x65, 0x00, 
	0x00, 0x50, 0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x50, 0x6f, 0x77, 
	0x65, 0x72, 0x6c, 0x69, 0x6e, 0x65, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x46, 0x00, 
	0x6f, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x20, 0x00, 
	0x50, 0x00, 0x6f, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x6c, 0x00, 0x69, 0x00, 0x6e, 0x00, 
	0x65, 0x00, 0x00, 0x50, 0x72, 0x6f, 0x46, 0x6f, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x50, 
	0x6f, 0x77, 0x65, 0x72, 0x6c, 0x69, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0x6a, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1d, 0x00, 0x00, 
	0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 
	0x00, 0x09, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x10, 
	0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00, 0x18, 
	0x00, 0x19, 0x00, 0x1a, 0x00, 0x1b, 0x00, 0x1c, 0x00, 0x1d, 0x00, 0x1e, 0x00, 0x1f, 0x00, 0x20, 
	0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00, 0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00, 0x28, 
	0x00, 0x29, 0x00, 0x2a, 0x00, 0x2b, 0x00, 0x2c, 0x00, 0x2d, 0x00, 0x2e, 0x00, 0x2f, 0x00, 0x30, 
	0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 
	0x00, 0x39, 0x00, 0x3a, 0x00, 0x3b, 0x00, 0x3c, 0x00, 0x3d, 0x00, 0x3e, 0x00, 0x3f, 0x00, 0x40, 
	0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 
	0x00, 0x49, 0x00, 0x4a, 0x00, 0x4b, 0x00, 0x4c, 0x00, 0x4d, 0x00, 0x4e, 0x00, 0x4f, 0x00, 0x50, 
	0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00, 0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00, 0x58, 
	0x00, 0x59, 0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d, 0x00, 0x5e, 0x00, 0x5f, 0x00, 0x60, 
	0x00, 0x61, 0x01, 0x02, 0x00, 0xa3, 0x00, 0x84, 0x00, 0x85, 0x00, 0xbd, 0x00, 0x96, 0x00, 0xe8, 
	0x00, 0x86, 0x00, 0x8e, 0x00, 0x8b, 0x00, 0x9d, 0x00, 0xa9, 0x00, 0xa4, 0x00, 0xef, 0x00, 0x8a, 
	0x00, 0xda, 0x00, 0x83, 0x00, 0x93, 0x00, 0xf2, 0x00, 0xf3, 0x00, 0x8d, 0x00, 0x97, 0x00, 0x88, 
	0x00, 0xc3, 0x00, 0xde, 0x00, 0xf1, 0x00, 0x9e, 0x00, 0xaa, 0x00, 0xf5, 0x00, 0xf4, 0x00, 0xf6, 
	0x00, 0xa2, 0x00, 0xad, 0x00, 0xc9, 0x00, 0xc7, 0x00, 0xae, 0x00, 0x62, 0x00, 0x63, 0x00, 0x90, 
	0x00, 0x64, 0x00, 0xcb, 0x00, 0x65, 0x00, 0xc8, 0x00, 0xca, 0x00, 0xcf, 0x00, 0xcc, 0x00, 0xcd, 
	0x00, 0xce, 0x00, 0xe9, 0x00, 0x66, 0x00, 0xd3, 0x00, 0xd0, 0x00, 0xd1, 0x00, 0xaf, 0x00, 0x67, 
	0x00, 0xf0, 0x00, 0x91, 0x00, 0xd6, 0x00, 0xd4, 0x00, 0xd5, 0x00, 0x68, 0x00, 0xeb, 0x00, 0xed, 
	0x00, 0x89, 0x00, 0x6a, 0x00, 0x69, 0x00, 0x6b, 0x00, 0x6d, 0x00, 0x6c, 0x00, 0x6e, 0x00, 0xa0, 
	0x00, 0x6f, 0x00, 0x71, 0x00, 0x70, 0x00, 0x72, 0x00, 0x73, 0x00, 0x75, 0x00, 0x74, 0x00, 0x76, 
	0x00, 0x77, 0x00, 0xea, 0x00, 0x78, 0x00, 0x7a, 0x00, 0x79, 0x00, 0x7b, 0x00, 0x7d, 0x00, 0x7c, 
	0x00, 0xb8, 0x00, 0xa1, 0x00, 0x7f, 0x00, 0x7e, 0x00, 0x80, 0x00, 0x81, 0x00, 0xec, 0x00, 0xee, 
	0x00, 0xba, 0x00, 0xd7, 0x00, 0xb0, 0x00, 0xb1, 0x00, 0xe4, 0x00, 0xe5, 0x00, 0xbb, 0x00, 0xe6, 
	0x00, 0xe7, 0x00, 0xa6, 0x00, 0xd8, 0x00, 0xe1, 0x00, 0xdb, 0x00, 0xdc, 0x00, 0xdd, 0x00, 0xe0, 
	0x00, 0xd9, 0x00, 0xdf, 0x00, 0xb2, 0x00, 0xb3, 0x01, 0x03, 0x00, 0xb6, 0x00, 0xb7, 0x00, 0xc4, 
	0x00, 0xb4, 0x00, 0xb5, 0x00, 0xc5, 0x00, 0x82, 0x00, 0xc2, 0x00, 0x87, 0x00, 0xab, 0x00, 0xc6, 
	0x00, 0xbe, 0x00, 0xbf, 0x01, 0x04, 0x00, 0x8c, 0x01, 0x05, 0x01, 0x06, 0x01, 0x07, 0x01, 0x08, 
	0x01, 0x09, 0x01, 0x0a, 0x01, 0x0b, 0x01, 0x0c, 0x01, 0x0d, 0x01, 0x0e, 0x01, 0x0f, 0x01, 0x10, 
	0x01, 0x11, 0x01, 0x12, 0x01, 0x13, 0x01, 0x14, 0x01, 0x15, 0x01, 0x16, 0x01, 0x17, 0x01, 0x18, 
	0x01, 0x19, 0x01, 0x1a, 0x01, 0x1b, 0x01, 0x1c, 0x01, 0x1d, 0x01, 0x1e, 0x01, 0x1f, 0x01, 0x20, 
	0x01, 0x21, 0x01, 0x22, 0x01, 0x23, 0x01, 0x24, 0x01, 0x25, 0x01, 0x26, 0x01, 0x27, 0x01, 0x28, 
	0x01, 0x29, 0x01, 0x2a, 0x01, 0x2b, 0x01, 0x2c, 0x01, 0x2d, 0x01, 0x2e, 0x01, 0x2f, 0x01, 0x30, 
	0x01, 0x31, 0x01, 0x32, 0x01, 0x33, 0x01, 0x34, 0x01, 0x35, 0x01, 0x36, 0x01, 0x37, 0x01, 0x38, 
	0x01, 0x39, 0x01, 0x3a, 0x01, 0x3b, 0x01, 0x3c, 0x07, 0x75, 0x6e, 0x69, 0x30, 0x30, 0x41, 0x30, 
	0x0d, 0x75, 0x6e, 0x64, 0x65, 0x72, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x64, 0x62, 0x6c, 0x07, 0x75, 
	0x6e, 0x69, 0x32, 0x30, 0x41, 0x43, 0x0d, 0x72, 0x65, 0x76, 0x6c, 0x6f, 0x67, 0x69, 0x63, 0x61, 
	0x6c, 0x6e, 0x6f, 0x74, 0x08, 0x53, 0x46, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 
	0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x08, 
	0x53, 0x46, 0x30, 0x33, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 0x32, 0x30, 0x30, 0x30, 
	0x30, 0x08, 0x53, 0x46, 0x30, 0x34, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 0x38, 0x30, 
	0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 0x39, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 
	0x36, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x30, 0x37, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 
	0x46, 0x30, 0x35, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x33, 0x30, 0x30, 0x30, 0x30, 
	0x08, 0x53, 0x46, 0x32, 0x34, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x35, 0x31, 0x30, 0x30, 
	0x30, 0x30, 0x08, 0x53, 0x46, 0x35, 0x32, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x33, 0x39, 
	0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x32, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 
	0x32, 0x31, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x35, 0x30, 0x30, 0x30, 0x30, 0x08, 
	0x53, 0x46, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x39, 0x30, 0x30, 0x30, 
	0x30, 0x08, 0x53, 0x46, 0x33, 0x38, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x38, 0x30, 
	0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x37, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 
	0x36, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x33, 0x36, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 
	0x46, 0x33, 0x37, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x32, 0x30, 0x30, 0x30, 0x30, 
	0x08, 0x53, 0x46, 0x31, 0x39, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x30, 0x30, 0x30, 
	0x30, 0x30, 0x08, 0x53, 0x46, 0x32, 0x33, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x37, 
	0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x38, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 
	0x34, 0x31, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x35, 0x30, 0x30, 0x30, 0x30, 0x08, 
	0x53, 0x46, 0x34, 0x36, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x30, 0x30, 0x30, 0x30, 
	0x30, 0x08, 0x53, 0x46, 0x35, 0x34, 0x30, 0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x35, 0x33, 0x30, 
	0x30, 0x30, 0x30, 0x08, 0x53, 0x46, 0x34, 0x34, 0x30, 0x30, 0x30, 0x30, 0x07, 0x75, 0x70, 0x62, 
	0x6c, 0x6f, 0x63, 0x6b, 0x07, 0x64, 0x6e, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x05, 0x62, 0x6c, 0x6f, 
	0x63, 0x6b, 0x07, 0x6c, 0x66, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x07, 0x72, 0x74, 0x62, 0x6c, 0x6f, 
	0x63, 0x6b, 0x07, 0x6c, 0x74, 0x73, 0x68, 0x61, 0x64, 0x65, 0x05, 0x73, 0x68, 0x61, 0x64, 0x65, 
	0x07, 0x64, 0x6b, 0x73, 0x68, 0x61, 0x64, 0x65, 0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x41, 0x30, 
	0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x41, 0x31, 0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x41, 0x32, 
	0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x42, 0x30, 0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x42, 0x31, 
	0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x42, 0x32, 0x07, 0x75, 0x6e, 0x69, 0x45, 0x30, 0x42, 0x33, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x0b, 0x00, 0x03, 0x00, 0x11, 0x00, 0x00, 0xff, 0xff, 0x00, 0x03, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x16, 0x00, 0x1e, 0x00, 0x02, 0x00, 0x01, 
	0x00, 0x01, 0x01, 0x1c, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0xd4, 0x24, 0x99, 0x26, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x1e, 0xe1, 0x31, 0x00, 0x00, 0x00, 0x00, 
	0xd5, 0x15, 0x03, 0xf7  
	};
#else
extern unsigned char font_buffer_profont[46628];
#endif

#ifdef __cplusplus
}
#endif

/* EOF */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
XColor BLACK_B=  {0  , 43 , 54 };
XColor GREEN_B   = {88 , 110, 117};
XColor RED_B     = {203, 75 , 22 };
XColor BLUE_B    = {131, 148, 150};
XColor YELLOW_B  = {101, 148, 150};
XColor CYAN_B    = {147, 161, 161};
XColor MAGENTA_B = {108, 113, 196};
XColor ORANGE_B  = {255, 127, 80};
XColor WHITE_B   = {253, 246, 227};
XColor VIOLET_B  = {199, 21 , 133};
*/
XColor BLACK    = {7  , 54 , 66 };
XColor GREEN     = {133, 153, 0  };
XColor RED       = {211, 1  , 2  };
XColor BLUE      = {38 , 139, 210};
XColor YELLOW    = {181, 137, 0  };
XColor CYAN      = {42 , 161, 152};
XColor MAGENTA   = {211, 54 , 130};
XColor ORANGE    = {255, 160, 122};
XColor WHITE     = {238, 232, 213};
XColor VIOLET    = {108, 113, 196};


/* Definicoes das funcoes da biblioteca */
typedef struct{
    uchar* image;
    unsigned width;
    unsigned height;
} XBitmap;

typedef struct{
    uchar * buffer;
    struct stbtt_fontinfo info;
    float scale;
    int ascent;
    int descent;
    int lineGap;
} XFont;


static XColor   __palette[256];
static XBitmap* __bitmap;
static XFont*   __font;
static XFont*   __font_default;
static int      __font_size;
static bool     __using_default_font;
static uchar    __color[3];

static int __x_step_jump = 1;
static char __x_log_directory[100];
static int __x_initialized = 0;


XBitmap * __x_bitmap_create(unsigned width, unsigned height, const uchar *color);
void      __x_bitmap_destroy(XBitmap *bitmap);

/* se quiser trocar a font default, passe o nome do arquivo e crie um buffer */
uchar * __x_buffer_create(const char *filename);
uchar * __x_get_pixel_pos(int x, int y);

uchar * __x_get_pixel_pos(int x, int y){
    return __bitmap->image + 3 * (__bitmap->width * y + x);
}

XBitmap * __x_bitmap_create(unsigned width, unsigned height, const uchar *color){
    XBitmap * bitmap = (XBitmap*) malloc(sizeof(XBitmap));
    bitmap->height = height;
    bitmap->width = width;
    bitmap->image = (uchar*) malloc(width * height * 3);
    unsigned y = 0, x = 0;
    for(y = 0; y < height; y++)
        for(x = 0; x < width; x++)
            memcpy(bitmap->image + 3 * (width * y + x), color, 3);
    return bitmap;
}

void __x_bitmap_destroy(XBitmap *bitmap){
    free(bitmap->image);
    free(bitmap);
}

void x_open(unsigned int width, unsigned int height){
    if(__x_initialized){
        fprintf(stderr, "fail: bitmat already initialized\n");
        return;
    }
    __x_initialized = 1;
    /* inicializando a cor de fundo */
    uchar cinza[] = {30, 30, 30};
    __bitmap = __x_bitmap_create(width, height, cinza);
    /* inicializando a cor de desenho e escrita */
    xs_color(make_xcolor(200, 200, 200));

    __font_default = (XFont*) malloc(sizeof(XFont));
    __font_default->buffer = font_buffer_profont;
    stbtt_InitFont(&__font_default->info, __font_default->buffer, 0);

    /* setando a font default como fonte do sistema */
    __font = __font_default;
    __using_default_font = true;
    xs_font_size(20);

    __palette['r'] = RED;
    __palette['g'] = GREEN;
    __palette['b'] = BLUE;
    __palette['y'] = YELLOW;
    __palette['m'] = MAGENTA;
    __palette['c'] = CYAN;
    __palette['k'] = BLACK;
    __palette['w'] = WHITE;
    __palette['o'] = ORANGE;
    __palette['v'] = VIOLET;

/*
    __palette['R'] = RED_B;
    __palette['G'] = GREEN_B;
    __palette['B'] = BLUE_B;
    __palette['Y'] = YELLOW_B;
    __palette['M'] = MAGENTA_B;
    __palette['C'] = CYAN_B;
    __palette['K'] = BLACK_B;
    __palette['W'] = WHITE_B;
    __palette['O'] = ORANGE_B;
    __palette['V'] = VIOLET_B;
*/

    /*https://htmlcolorcodes.com/color-names/*/

    __palette[' '] = make_xcolor(230, 230, 250); /*khaki*/
    __palette['.'] = make_xcolor(240, 230, 140); /*lavender*/
    __palette['#'] = make_xcolor(25, 25, 112); /*midnight blue*/
    __palette['x'] = make_xcolor(255, 99, 71); /*tomato*/

    srand(time(NULL));
}

void x_close(){
    if(__x_initialized == 0){
        fprintf(stderr, "fail: x_open(weight, width) missing!");
        exit(1);
    }
    __x_initialized = 0;
    __x_bitmap_destroy(__bitmap);
    if(__using_default_font == false){
        free(__font->buffer);
        free(__font);
    }
}

void x_clear(XColor color){
    unsigned x, y;
    for(x = 0; x < __bitmap->width; x++){
        for(y = 0; y < __bitmap->height; y++){
            uchar * pixel = __x_get_pixel_pos(x, y);
            pixel[0] = color.r;
            pixel[1] = color.g;
            pixel[2] = color.b;
        }
    }
}

void xs_color(XColor color){
    __color[0] = color.r;
    __color[1] = color.g;
    __color[2] = color.b;
}

XColor xg_color(){
    XColor color = {__color[0], __color[1], __color[2]};
    return color;
}

XColor xg_pixel(int x, int y){
    uchar * pixel = __x_get_pixel_pos(x, y);
    XColor color = {pixel[0], pixel[1], pixel[2]};
    return color;
}

uchar * __x_buffer_create(const char *filename){
    long size;
    uchar * font_buffer;
    FILE* font_file = fopen(filename, "rb");
    if(font_file == NULL){
        fprintf(stderr, "fail: file not found\n");
        exit(1);
    }
    fseek(font_file, 0, SEEK_END);
    size = ftell(font_file); /* how long is the file ? */
    fseek(font_file, 0, SEEK_SET); /* reset */
    font_buffer = (uchar *) malloc(size);
    fread(font_buffer, size, 1, font_file);
    fclose(font_file);
    return font_buffer;
}

void xs_font(const char* filename){
    if(filename == NULL){
        if(__using_default_font == false){
            __using_default_font = true;
            free(__font->buffer);
            free(__font);
            __font = __font_default;
        }
    }else{
        XFont * font = (XFont*) malloc(sizeof(XFont));
        font->buffer = __x_buffer_create(filename);
        unsigned error = stbtt_InitFont(&font->info, font->buffer, 0);
        if(error == 0){
            fprintf(stderr, "fail: font load failure\n");
            free(font->buffer);
            free(font);
        }else{
            __font = font;
            __using_default_font = false;
        }
    }
    xs_font_size(__font_size);
}

void xs_font_size(int size){
    __font_size = size;
    __font->scale = stbtt_ScaleForPixelHeight(&__font->info, size);
    stbtt_GetFontVMetrics(&__font->info, &__font->ascent, &__font->descent, &__font->lineGap);
    __font->ascent *= __font->scale;
    __font->descent *= __font->scale;
}

int x_write(int x, int y, const char * format, ...){
    char text[1000];
    va_list args;
    va_start( args, format );
    vsprintf(text, format, args);
    va_end( args );

    int i;
    unsigned _x = x;

    /* setando a cor */
    __font->info.userdata = (void *) __color;

    for (i = 0; i < (int) strlen(text); ++i) {
        if(text[i] == '\n'){
            y += __font_size;
            _x = x;
            continue;
        }

        /* how wide is this character */
        int ax;
        stbtt_GetCodepointHMetrics(&__font->info, text[i], &ax, 0);
        ax = ax * __font->scale;

        if(_x + ax > __bitmap->width){
            y += __font_size;
            _x = 10;
        }

        if((unsigned) y + __font_size > __bitmap->height){
            return _x;
        }

        /* get bounding box for character (may be offset to account for chars that dip above or below the line */
        int c_x1, c_y1, c_x2, c_y2;
        stbtt_GetCodepointBitmapBox(&__font->info, text[i], __font->scale, __font->scale, &c_x1, &c_y1, &c_x2, &c_y2);

        /* compute y (different characters have different heights */
        int _y = y + __font->ascent + c_y1;

        /* render character (stride and offset is important here) */
        int byteOffset = _x + (_y  * __bitmap->width);
        stbtt_MakeCodepointBitmap(&__font->info, __bitmap->image + 3 * byteOffset, c_x2 - c_x1, c_y2 - c_y1,
                                  __bitmap->width, __font->scale, __font->scale, text[i]);

        _x += ax; /* desloca x para proximo caractere */

        /* add kerning */
        int kern;
        kern = stbtt_GetCodepointKernAdvance(&__font->info, text[i], text[i + 1]);
        _x += kern * __font->scale;
    }
    return _x;
}

void x_save(const char *filename){
    char * dest = (char*) malloc(strlen(filename + 10));
    strcpy(dest, filename);
    strcat(dest, ".png");
    unsigned error = lodepng_encode_file(dest, __bitmap->image, __bitmap->width, __bitmap->height, LCT_RGB, 8);
    if(error)
        printf("error %u: %s\n", error, lodepng_error_text(error));
    free(dest);
}

void xs_log(const char *directory){
    strcpy(__x_log_directory, directory);
}


/*salva o a imagem no diretorio de log */
void __x_log(int index){
    char * name = (char *) malloc((strlen(__x_log_directory) + 10) * sizeof(char));
    sprintf(name, "%s%05d", __x_log_directory, index);

    x_save(name);
    free(name);
}

void xs_jump(int value){
    __x_step_jump = value;
}

int x_step(const char *filename){
    static int rounds = 0; /* each save reset the round */
    static int state = 0; /* each save generate a new state */
    if(strcmp(__x_log_directory, "") != 0){
        __x_log(state);
    }
    char line[200];
    rounds += 1;
    state += 1;
    if((__x_step_jump != 0) && (rounds >= __x_step_jump)){
        x_save(filename);
        printf("(state: %i, jump: %i) press{enter/jump value/0 to skip}:", state, __x_step_jump);
        fgets(line, sizeof(line), stdin);
        char * ptr = line;
        int value = (int) strtol(line, &ptr, 10);
        if(ptr != line)
            __x_step_jump = value;
        rounds = 0;
    }
    return state;
}

void x_plot(int x, int y){
    if(__x_initialized == 0){
        fprintf(stderr, "fail: x_open(weight, width) missing\n");
        exit(1);
    }
    if((x >= 0) && (x < (int) __bitmap->width) && (y >= 0) && (y <  (int) __bitmap->height))
        memcpy(__x_get_pixel_pos(x, y), &__color, sizeof(__color));
}

XColor make_xcolor(uchar r, uchar g, uchar b){
    XColor x = {r, g, b};
    return x;
}

void xs_palette(char c, XColor color){
    __palette[(int)c] = color;
}

XColor xg_palette(char c){
    return __palette[(int)c];
}



int xg_height(){
    if(__bitmap == NULL)
        fprintf(stderr, "fail: x_open(weight, width) missing\n");
    return __bitmap->height;
}

int xg_width(){
    if(__bitmap == NULL)
        fprintf(stderr, "fail: x_open(weight, width) missing\n");
    return __bitmap->width;
}

#ifdef __cplusplus
}
#endif



#include <stdlib.h>/*abs*/
#include <assert.h>
#include <stdio.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#define X_SWAP(x, y, T) do { T X_SWAP = x; x = y; y = X_SWAP; } while (0)

void xd_line(int x0, int y0, int x1, int y1){
    /* Bresenham's Line Algorithm */
    int dx = (x0 > x1) ? x0 - x1 : x1 - x0;
    int dy = (y0 > y1) ? y0 - y1 : y1 - y0;
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;

    while (1) {
        x_plot(x0, y0);
        if (x0 == x1 && y0 == y1) break;
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

void __x_fill_bottom_flat_triangle(float v1x, float v1y, float v2x, float v2y, float v3x, float v3y)
{
    float invslope1 = ((int)v2x - (int)v1x) / (float)((int)v2y - (int)v1y);
    float invslope2 = ((int)v3x - (int)v1x) / (float)((int)v3y - (int)v1y);

    float curx1 = v1x;
    float curx2 = v1x;
    int scanlineY;

    for (scanlineY = v1y; scanlineY <= (int)v2y; scanlineY++){
        xd_line(curx1, scanlineY, curx2, scanlineY);
        curx1 += invslope1;
        curx2 += invslope2;
    }
}

void __x_fill_top_flat_triangle(float v1x, float v1y, float v2x, float v2y, float v3x, float v3y)
{
    float invslope1 = ((int)v3x - (int)v1x) / (float)((int)v3y - (int)v1y);
    float invslope2 = ((int)v3x - (int)v2x) / (float)((int)v3y - (int)v2y);

    float curx1 = v3x;
    float curx2 = v3x;

    int scanlineY;
    
    for (scanlineY = v3y; scanlineY >= v1y; scanlineY--)
    {
        xd_line(curx1, scanlineY, curx2, scanlineY);
        curx1 -= invslope1;
        curx2 -= invslope2;
    }
}

void xd_filled_triangle(float v1x, float v1y, float v2x, float v2y, float v3x, float v3y)
{
    XY v1 = {v1x, v1y};
    XY v2 = {v2x, v2y};
    XY v3 = {v3x, v3y};
    /* at first sort the three vertices by y-coordinate ascending so v1 is the topmost vertice */
    if((v2.y <= v1.y) && (v2.y <= v3.y))
        X_SWAP(v1, v2, XY);
    if((v3.y <= v1.y) && (v3.y <= v2.y))
        X_SWAP(v1, v3, XY);
    if(v3.y < v2.y)
        X_SWAP(v2, v3, XY);

    /* here we know that v1.y <= v2.y <= v3.y */
    /* check for trivial case of bottom-flat triangle */
    if (v2.y == v3.y)
        __x_fill_bottom_flat_triangle(v1.x, v1.y, v2.x, v2.y, v3.x, v3.y);
    else if (v1.y == v2.y)
        __x_fill_top_flat_triangle(v1.x, v1.y, v2.x, v2.y, v3.x, v3.y);
    else
    {
        /* general case - split the triangle in a topflat and bottom-flat one */
        XY v4 = {0.f, 0.f};
        v4.x = (v1.x + ((float)(v2.y - v1.y) / (float)(v3.y - v1.y)) * (v3.x - v1.x));
        v4.y = v2.y;
        __x_fill_bottom_flat_triangle(v1.x, v1.y, v2.x, v2.y, v4.x, v4.y);
        __x_fill_top_flat_triangle(v2.x, v2.y, v4.x, v4.y, v3.x, v3.y);
    }
}

void xd_thick_line(float x0, float y0, float x1, float y1, int thickness){
    XY a = {x0, y0};
    XY b = {x1, y1};
    if(thickness == 1){
        xd_line(a.x, a.y, b.x, b.y);
        return;
    }
    XY _offset = make_xy(b.x - a.x, b.y - a.y);
    _offset = xy_dot(xy_ortho(xy_normalize(_offset)), (thickness/2.f));

    XY p1 = xy_sub(a, _offset);
    XY p2 = xy_sub(b, _offset);
    XY p3 = xy_sum(a, _offset);
    XY p4 = xy_sum(b, _offset);

    xd_filled_triangle(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    xd_filled_triangle(p3.x, p3.y, p2.x, p2.y, p4.x, p4.y);
}

void xd_filled_rect(int x0, int y0, int x1, int y1){
    int i;
    for(i = x0; i <= x1; i++)
        xd_line(i, y0, i, y1);
}

/* https://en.wikipedia.org/wiki/Midpoint_circle_algorithm */
void xd_circle(int centerx, int centery, int radius){
    int x = radius - 1;
    int y = 0;
    int dx = 1;
    int dy = 1;
    int err = dx - (radius << 1);
    while(x >= y){
        x_plot(centerx + x, centery + y);
        x_plot(centerx - x, centery + y);
        x_plot(centerx + x, centery - y);
        x_plot(centerx - x, centery - y);
        x_plot(centerx + y, centery + x);
        x_plot(centerx - y, centery + x);
        x_plot(centerx - y, centery - x);
        x_plot(centerx + y, centery - x);

        if(err <= 0){
            y++;
            err += dy;
            dy += 2;
        }else{
            x--;
            dx += 2;
            err += dx - (radius << 1);
        }
    }
}

void xd_filled_circle(int centerx, int centery, int radius){
    int x = radius - 1;
    int y = 0;
    int dx = 1;
    int dy = 1;
    int err = dx - (radius << 1);
    while(x >= y){
        xd_line(centerx + x, centery + y, centerx - x, centery + y);
        xd_line(centerx + x, centery - y, centerx - x, centery - y);
        xd_line(centerx + y, centery + x, centerx - y, centery + x);
        xd_line(centerx - y, centery - x, centerx + y, centery - x);
        if(err <= 0){
            y++;
            err += dy;
            dy += 2;
        }else{
            x--;
            dx += 2;
            err += dx - (radius << 1);
        }
    }
}

void xd_ellipse(int x0, int y0, int x1, int y1)
{
    int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
    long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
    long err = dx+dy+b1*a*a, e2; /* error of 1.step */

    if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
    if (y0 > y1) y0 = y1; /* .. exchange them */
    y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
    a *= 8*a; b1 = 8*b*b;

    do {
        x_plot(x1, y0); /*   I. Quadrant */
        x_plot(x0, y0); /*  II. Quadrant */
        x_plot(x0, y1); /* III. Quadrant */
        x_plot(x1, y1); /*  IV. Quadrant */
        e2 = 2*err;
        if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */
        if (e2 >= dx || 2*err > dy) { x0++; x1--; err += dx += b1; } /* x step */
    } while (x0 <= x1);

    while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
        x_plot(x0-1, y0); /* -> finish tip of ellipse */
        x_plot(x1+1, y0++);
        x_plot(x0-1, y1);
        x_plot(x1+1, y1--);
    }
}

void xd_filled_ellipse(int x0, int y0, int x1, int y1)
{
    int a = abs(x1-x0), b = abs(y1-y0), b1 = b&1; /* values of diameter */
    long dx = 4*(1-a)*b*b, dy = 4*(b1+1)*a*a; /* error increment */
    long err = dx+dy+b1*a*a, e2; /* error of 1.step */

    if (x0 > x1) { x0 = x1; x1 += a; } /* if called with swapped points */
    if (y0 > y1) y0 = y1; /* .. exchange them */
    y0 += (b+1)/2; y1 = y0-b1;   /* starting pixel */
    a *= 8*a; b1 = 8*b*b;

    do {
        xd_line(x1, y0, x0, y0); /*   I. Quadrant */
        xd_line(x0, y1, x1, y1); /* III. Quadrant */
        e2 = 2*err;
        if (e2 <= dy) { y0++; y1--; err += dy += a; }  /* y step */
        if (e2 >= dx || 2*err > dy) { x0++; x1--; err += dx += b1; } /* x step */
    } while (x0 <= x1);

    while (y0-y1 < b) {  /* too early stop of flat ellipses a=1 */
        x_plot(x0-1, y0); /* -> finish tip of ellipse */
        x_plot(x1+1, y0++);
        x_plot(x0-1, y1);
        x_plot(x1+1, y1--);
    }
}

void __x_plot_quad_bezier_seg(int x0, int y0, int x1, int y1, int x2, int y2)
{
    int sx = x2-x1, sy = y2-y1;
    long xx = x0-x1, yy = y0-y1, xy;         /* relative values for checks */
    double dx, dy, err, cur = xx*sy-yy*sx;                    /* curvature */

    assert(xx*sx <= 0 && yy*sy <= 0);  /* sign of gradient must not change */

    if (sx*(long)sx+sy*(long)sy > xx*xx+yy*yy) { /* begin with longer part */
        x2 = x0; x0 = sx+x1; y2 = y0; y0 = sy+y1; cur = -cur;  /* swap P0 P2 */
    }
    if (cur != 0) {                                    /* no straight line */
        xx += sx; xx *= sx = x0 < x2 ? 1 : -1;           /* x step direction */
        yy += sy; yy *= sy = y0 < y2 ? 1 : -1;           /* y step direction */
        xy = 2*xx*yy; xx *= xx; yy *= yy;          /* differences 2nd degree */
        if (cur*sx*sy < 0) {                           /* negated curvature? */
            xx = -xx; yy = -yy; xy = -xy; cur = -cur;
        }
        dx = 4.0*sy*cur*(x1-x0)+xx-xy;             /* differences 1st degree */
        dy = 4.0*sx*cur*(y0-y1)+yy-xy;
        xx += xx; yy += yy; err = dx+dy+xy;                /* error 1st step */
        do {
            x_plot(x0,y0);                                     /* plot curve */
            if (x0 == x2 && y0 == y2) return;  /* last pixel -> curve finished */
            y1 = 2*err < dx;                  /* save value for test of y step */
            if (2*err > dy) { x0 += sx; dx -= xy; err += dy += yy; } /* x step */
            if (    y1    ) { y0 += sy; dy -= xy; err += dx += xx; } /* y step */
        } while (dy < dx );           /* gradient negates -> algorithm fails */
    }
    xd_line(x0,y0, x2,y2);                  /* plot remaining part to end */
}
void xd_bezier(int x0, int y0, int x1, int y1, int x2, int y2)
{                                          /* plot any quadratic Bezier curve */
    int x = x0-x1, y = y0-y1;
    double t = x0-2*x1+x2, r;

    if ((long)x*(x2-x1) > 0) {                        /* horizontal cut at P4? */
        if ((long)y*(y2-y1) > 0)                     /* vertical cut at P6 too? */
            if (xm_fabs((y0-2*y1+y2)/t*x) > abs(y)) {               /* which first? */
                x0 = x2; x2 = x+x1; y0 = y2; y2 = y+y1;            /* swap points */
            }                            /* now horizontal cut at P4 comes first */
        t = (x0-x1)/t;
        r = (1-t)*((1-t)*y0+2.0*t*y1)+t*t*y2;                       /* By(t=P4) */
        t = (x0*x2-x1*x1)*t/(x0-x1);                       /* gradient dP4/dx=0 */
        x = xm_floor(t+0.5); y = xm_floor(r+0.5);
        r = (y1-y0)*(t-x0)/(x1-x0)+y0;                  /* intersect P3 | P0 P1 */
        __x_plot_quad_bezier_seg(x0,y0, x,xm_floor(r+0.5), x,y);
        r = (y1-y2)*(t-x2)/(x1-x2)+y2;                  /* intersect P4 | P1 P2 */
        x0 = x1 = x; y0 = y; y1 = xm_floor(r+0.5);             /* P0 = P4, P1 = P8 */
    }
    if ((long)(y0-y1)*(y2-y1) > 0) {                    /* vertical cut at P6? */
        t = y0-2*y1+y2; t = (y0-y1)/t;
        r = (1-t)*((1-t)*x0+2.0*t*x1)+t*t*x2;                       /* Bx(t=P6) */
        t = (y0*y2-y1*y1)*t/(y0-y1);                       /* gradient dP6/dy=0 */
        x = xm_floor(r+0.5); y = xm_floor(t+0.5);
        r = (x1-x0)*(t-y0)/(y1-y0)+x0;                  /* intersect P6 | P0 P1 */
        __x_plot_quad_bezier_seg(x0,y0, xm_floor(r+0.5),y, x,y);
        r = (x1-x2)*(t-y2)/(y1-y2)+x2;                  /* intersect P7 | P1 P2 */
        x0 = x; x1 = xm_floor(r+0.5); y0 = y1 = y;             /* P0 = P6, P1 = P7 */
    }
    __x_plot_quad_bezier_seg(x0,y0, x1,y1, x2,y2);                  /* remaining part */
}

/* https://github.com/Jnmattern/Minimalist_2.0/blob/master/src/bitmap.h */
#define __TRIG_MAX (1<<24)
#define __TRIG_NORM(v) ((v)>>24)
#define __TRIG_MULT(v) ((v)<<24)

const int32_t __sinTable__[91] = {
    0, 292802, 585516, 878051, 1170319, 1462230, 1753696, 2044628, 2334937, 2624534, 2913332, 3201243, 3488179, 3774052,
    4058775, 4342263, 4624427, 4905183, 5184444, 5462127, 5738145, 6012416, 6284855, 6555380, 6823908, 7090357, 7354647,
    7616696, 7876425, 8133755, 8388607, 8640905, 8890569, 9137526, 9381700, 9623015, 9861400, 10096780, 10329085, 10558244,
    10784186, 11006844, 11226148, 11442033, 11654433, 11863283, 12068519, 12270079, 12467901, 12661925, 12852093, 13038345,
    13220626, 13398880, 13573052, 13743090, 13908942, 14070557, 14227886, 14380880, 14529495, 14673683, 14813402, 14948608,
    15079261, 15205321, 15326749, 15443508, 15555563, 15662880, 15765426, 15863169, 15956080, 16044131, 16127295, 16205546,
    16278860, 16347217, 16410593, 16468971, 16522332, 16570660, 16613941, 16652161, 16685308, 16713373, 16736347, 16754223,
    16766995, 16774660, 16777216
};

static int32_t __SIN(int d) {
    d = d%360;
    if (d < 90) {
        return __sinTable__[d];
    } else if (d < 180) {
        return __sinTable__[180-d];
    } else if (d < 270) {
        return -__sinTable__[d-180];
    } else {
        return -__sinTable__[360-d];
    }
}

static int32_t __COS(int d) {
    d = d%360;
    if (d < 90) {
        return __sinTable__[90-d];
    } else if (d < 180) {
        return -__sinTable__[d-90];
    } else if (d < 270) {
        return -__sinTable__[270-d];
    } else {
        return __sinTable__[d-270];
    }
}

void xd_filled_arc(float centerx, float centery, int radius, int thickness, int degrees_begin, int degrees_end) {
    if(degrees_begin > degrees_end)
        puts("drawArc: s deve ser menor que e");
    XY center = {centerx, centery};
    degrees_begin = degrees_begin%360;
    degrees_end = degrees_end%360;

    while (degrees_begin < 0) degrees_begin += 360;
    while (degrees_end < 0) degrees_end += 360;

    if (degrees_end == 0) degrees_end = 360;

    float sslope = (float)__COS(degrees_begin) / (float)__SIN(degrees_begin);
    float eslope = (float)__COS(degrees_end) / (float)__SIN(degrees_end);

    if (degrees_end == 360) eslope = -1000000;

    int ir2 = (radius - thickness) * (radius - thickness);
    int or2 = radius * radius;
    int x, y;

    for (x = -radius; x <= radius; x++) {
        for (y = -radius; y <= radius; y++)
        {
            int x2 = x * x;
            int y2 = y * y;

            if (
                    (x2 + y2 < or2 && x2 + y2 >= ir2) && (
                        (y > 0 && degrees_begin < 180 && x <= y * sslope) ||
                        (y < 0 && degrees_begin > 180 && x >= y * sslope) ||
                        (y < 0 && degrees_begin <= 180) ||
                        (y == 0 && degrees_begin <= 180 && x < 0) ||
                        (y == 0 && degrees_begin == 0 && x > 0)
                        ) && (
                        (y > 0 && degrees_end < 180 && x >= y * eslope) ||
                        (y < 0 && degrees_end > 180 && x <= y * eslope) ||
                        (y > 0 && degrees_end >= 180) ||
                        (y == 0 && degrees_end >= 180 && x < 0) ||
                        (y == 0 && degrees_begin == 0 && x > 0)
                        )
                    )
                x_plot(center.x+x, center.y-y);
        }
    }
}


#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C" {
#endif

XY make_xy(float x, float y){
    XY v = {x, y};
    return v;
}

float xy_lenght(float x, float y){
    return xm_sqrt(x * x + y * y);
}

float xy_distance(float ax, float ay, float bx, float by){
    return xy_lenght(bx - ax, by - ay);
}

XY xy_sum(XY a, XY b){
    return make_xy(a.x + b.x, a.y + b.y);
}

XY xy_sub(XY a, XY b){
    return make_xy(a.x - b.x, a.y - b.y);
}

XY xy_dot(XY a, float value){
    return make_xy(a.x * value, a.y  * value);
}

XY xy_normalize(XY v){
    float lenght = xy_lenght(v.x, v.y);
    if(lenght == 0)
        return v;
    v.x = v.x * (1.0/lenght);
    v.y = v.y * (1.0/lenght);
    return v;
}

XY xy_ortho(XY v){
    return make_xy(v.y, -v.x);
}

#ifdef __cplusplus
}
#endif




#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

int   xm_rand(int min, int max){
    return rand() % (max + 1 - min) + min;
}

/* https://stackoverflow.com/questions/5122993/floor-int-function-implementaton?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa */
int xm_floor(double x) {
    int xi = (int) x;
    return x < xi ? xi - 1 : xi;
}


/* funcao necessario para o po */
float xm_sqrt(const float m)
{
   float i=0;
   float x1,x2;
   while( (i*i) <= m )
          i+=0.1f;
   x1=i;
   int j;
   for(j=0;j<10;j++)
   {
       x2=m;
      x2/=x1;
      x2+=x1;
      x2/=2;
      x1=x2;
   }
   return x2;
}

float xm_pow( float x, float z ){
    int y =  z;
    double temp;
    if (y == 0)
    return 1;
    temp = xm_pow (x, y / 2);
    if ((y % 2) == 0) {
        return temp * temp;
    } else {
        if (y > 0)
            return x * temp * temp;
        else
            return (temp * temp) / x;
    }
}

float xm_fmod(float a, float b)
{
    return (a - b * xm_floor(a / b));
}

int xm_ceil(float n){
    return -xm_floor(-n);
}


/* Sin e Cos retirados de
   http://forum.arduino.cc/index.php?topic=69723.0
*/

unsigned int __isinTable16[] = {
    0, 1144, 2287, 3430, 4571, 5712, 6850, 7987, 9121, 10252, 11380,
    12505, 13625, 14742, 15854, 16962, 18064, 19161, 20251, 21336, 22414,
    23486, 24550, 25607, 26655, 27696, 28729, 29752, 30767, 31772, 32768,

    33753, 34728, 35693, 36647, 37589, 38521, 39440, 40347, 41243, 42125,
    42995, 43851, 44695, 45524, 46340, 47142, 47929, 48702, 49460, 50203,
    50930, 51642, 52339, 53019, 53683, 54331, 54962, 55577, 56174, 56755,

    57318, 57864, 58392, 58902, 59395, 59869, 60325, 60763, 61182, 61583,
    61965, 62327, 62671, 62996, 63302, 63588, 63855, 64103, 64331, 64539,
    64728, 64897, 65047, 65176, 65286, 65375, 65445, 65495, 65525, 65535,
};


float __isin(long x)
{
    int bool_pos = 1;  /* positive - keeps an eye on the sign. */
    if (x < 0)
    {
        x = -x;
        bool_pos = !bool_pos;
    }
    if (x >= 360) x %= 360;
    if (x > 180)
    {
        x -= 180;
        bool_pos = !bool_pos;
    }
    if (x > 90) x = 180 - x;
    if (bool_pos) return __isinTable16[x] * 0.0000152590219; 
    return __isinTable16[x] * -0.0000152590219 ;
}

float __icos(long x)
{
    return __isin(x+90);
}

float xm_sin(float d)
{
    float a = __isin(d);
    float b = __isin(d+1);
    return a + (d-(int)d) * (b-a);
}

float xm_cos(float d)
{
    float a = __icos(d);
    float b = __icos(d+1);
    return a + (d-(int)d) * (b-a);
}

/* Nvidia */
float xm_acos(float x) {
    float negate = (float)(x < 0);
    x = (x >= 0) ? x : -x;
    float ret = -0.0187293;
    ret = ret * x;
    ret = ret + 0.0742610;
    ret = ret * x;
    ret = ret - 0.2121144;
    ret = ret * x;
    ret = ret + 1.5707288;
    ret = ret * xm_sqrt(1.0-x);
    ret = ret - 2 * negate * ret;
    return negate * 3.14159265358979 + ret;
}

float xm_fabs(float f){
    return f < 0 ? -f : f;
}

#ifdef __cplusplus
}
#endif

#endif /* H_ONLY */
#undef H_ONLY /* Para evitar a propagação da Flag ela deve ser apagada */
